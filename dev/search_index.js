var documenterSearchIndex = {"docs":
[{"location":"legacy/interfaces/MC/#Interface:-Monte-Carlo-(MC)-1","page":"MC","title":"Interface: Monte Carlo (MC)","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"Any model that wants to be simulated by means of MC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the Monte Carlo flavor Monte Carlo (MC).","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"Example models: Ising Model","category":"page"},{"location":"legacy/interfaces/MC/#Mandatory-fields-1","page":"MC","title":"Mandatory fields","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"l::Lattice: any Lattice","category":"page"},{"location":"legacy/interfaces/MC/#Index-of-all-methods-1","page":"MC","title":"Index of all methods","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"Pages = [\"MC.md\"]","category":"page"},{"location":"legacy/interfaces/MC/#Mandatory-methods-1","page":"MC","title":"Mandatory methods","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"CurrentModule = MonteCarlo","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"conftype(::Type{MC}, m::Model)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"energy(mc::MC, m::Model, conf)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"rand(::MC, ::Model)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"propose_local(mc::MC, m::Model, i::Int, conf, E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"accept_local!(mc::MC, m::Model, i::Int, conf, E::Float64, delta_i, delta_E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#Optional-methods-1","page":"MC","title":"Optional methods","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"global_move(mc::MC, m::Model, conf, E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"prepare_observables(mc::MC, m::Model)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"measure_observables!(mc::MC, m::Model, obs::Dict{String,Observable}, conf, E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"finish_observables!(mc::MC, m::Model, obs::Dict{String,Observable})","category":"page"},{"location":"legacy/models/hubbardattractive/#Attractive-Hubbard-Model-1","page":"Attractive Hubbard model","title":"Attractive Hubbard Model","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#Hamiltonian-1","page":"Attractive Hubbard model","title":"Hamiltonian","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The Hamiltonian of the attractive (negative U) Hubbard model reads","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} \\mathcal{H} = -t \\sum{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger{i\\sigma} c{j\\sigma} + \\text{h.c.} \\right) - |U| \\sumj \\left( n{j\\uparrow} - \\frac{1}{2} \\right) \\left( n{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sumj n{j}, \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"where sigma denotes spin, t is the hopping amplitude, U the on-site repulsive interaction strength, mu the chemical potential and langle i j rangle indicates that the sum has to be taken over nearest neighbors. Note that (1) is written in particle-hole symmetric form such that mu = 0 corresponds to half-filling.","category":"page"},{"location":"legacy/models/hubbardattractive/#Constructor-1","page":"Attractive Hubbard model","title":"Constructor","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"You can create an attractive Hubbard model instance as follows,","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"model = HubbardModelAttractive(dims=1, L=8)","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The following parameters can be set via keyword arguments:","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"dims::Int: dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)\nL::Int: linear system size\nt::Float64 = 1.0: hopping energy\nU::Float64 = 1.0: onsite interaction strength, \"Hubbard U\"\nmu::Float64 = 0.0: chemical potential","category":"page"},{"location":"legacy/models/hubbardattractive/#Supported-Monte-Carlo-flavors-1","page":"Attractive Hubbard model","title":"Supported Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Determinant Quantum Monte Carlo (DQMC), see details below","category":"page"},{"location":"legacy/models/hubbardattractive/#DQMC-formulation-1","page":"Attractive Hubbard model","title":"DQMC formulation","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"We decouple the onsite electron-electron interaction by performing a Hirsch transformation, i.e. a discrete Hubbard-Stratonovich transformation in the density/charge channel,","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} e^{|U|\\Delta \\tau \\left( n{i\\uparrow} - \\frac{1}{2} \\right) \\left(n{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum{s=\\pm 1} \\prod{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The interaction matrix of the model then reads","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} V{ij}(l) &= \\delta{ij} Vi(l), \\\\\nVi(l) &= - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"For completeness, the hopping matrix is \\begin{align} T_{ij} &= \\begin{cases} -t & \\text{if i and j are nearest neighbors,} \\\\\n-\\mu & \\text{if i == j,} \\\\\n0 & \\text{otherwise.} \\end{cases} \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"As neither T nor V depend on spin, neither does the equal-times Green's function. We can therefore restrict our computations to one spin flavor (flv=1) and benefit from operating with smaller matrices.","category":"page"},{"location":"legacy/models/hubbardattractive/#Potential-extensions-1","page":"Attractive Hubbard model","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Arbitrary lattices (so far only cubic lattices supported)","category":"page"},{"location":"DQMC/dqmc/#DQMC-1","page":"DQMC","title":"DQMC","text":"","category":"section"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"The DQMC struct represents both the determinant quantum monte carlo algorithm and the simulation as a whole. Because of that it includes a bunch of options that aren't directly relevant to the algorithm. The minimal default is given by dqmc = DQMC(model, beta=beta) and the simulation can then be started with run!(dqmc). Additional keyword arguments include:","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"beta: The inverse temperature of the simulation.\ndelta_tau = 0.1: The imaginary time discretization.\nslices = beta / delta_tau: The number of imaginary time slices.\nsafe_mult = 10: The number of save matrix multiplications.\nthermalization = 100: The number of thermalization sweeps.\nsweeps = 100: The number of measurement sweeps.\ncheck_sign_problem = true: Enables or disables checks for sign problems. (negative or imaginary probabilities)\ncheck_propagation_error = true: Enables or disables checks for time slices propagation errors. (Which may happen if safemult or deltatau is too large.)\nsilent = false: Enable or disable prints for the checks above.\nmeasure_rate = 10: Sets the frequency of measurements. Every measure_rate sweeps a new measurement is taken.\nprint_rate = 10: Sets the frequency of general information prints (not checks).\nseed = -1: Sets a random seed for the simulation. If set to -1 the seed will be chosen randomly.\nlast_sweep = 0: Sets the last finished sweep. Used internally for continued simulations.","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"Beyond this there are a couple of keyword arguments which are more involved and will be discussed in other chapters. These include","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"scheduler = SimpleScheduler(LocalSweep()): This sets up the sequence of updates performed by the simulation.\nmeasurements = Dict{Symbol, AbstractMeasurement}(): A collection of named measurements that run during the simulation. These are usually added after creating the simulation.\nthermalization_measurements = Dict{Symbol, AbstractMeasurement}(): Same as the above, but the measurements run during the thermalization stage. Might be useful to judge convergence or the number of necessary sweeps.\nrecorder = ConfigRecorder: A recorder for the configurations generated during the simulation.\nrecording_rate = measure_rate: The rate at which configurations are recorded.","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"Running a simulation also comes with a bunch of options via keyword arguments - most dealing with saving the simulation. The options for run(dqmc) include:","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"verbose = true: Enables or disables information printing during the runtime.\nignore = tuple(): Measurement keys to ignore during this run (none by default).\nsafe_before::TimeType = now() + Year(100): Sets a time stamp before which the simulation will cancel itself and save.\nsafe_every::TimePeriod = Hour(10000): Sets a time period interval for regular saves.\ngrace_period::TimePeriod = Minute(5): Sets a buffer time period for saving. By default saves at least 5 minutes before the requested time.\nresumable_filename = \"resumable_$(datestring).jld2: Sets the name the savefile generated from safebefore and safeevery.\noverwrite = true: Enables or disables overwriting of existing files. ","category":"page"},{"location":"legacy/manual/gettingstarted/#Getting-Started-1","page":"Getting started","title":"Getting Started","text":"","category":"section"},{"location":"legacy/manual/gettingstarted/#Installation-1","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"MonteCarlo.jl hasn't yet been released. To clone the package execute the following command in the Julia REPL:","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"Pkg.clone(\"https://github.com/crstnbr/MonteCarloObservable.jl\")\nPkg.clone(\"https://github.com/crstnbr/MonteCarlo.jl\")","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"To update to the latest version of the package just do Pkg.update() or specifically Pkg.update(\"MonteCarlo\").","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"warning: Warning\nThe package is still in pre-alpha phase and shouldn't yet be used for production runs.","category":"page"},{"location":"legacy/manual/gettingstarted/#Usage-1","page":"Getting started","title":"Usage","text":"","category":"section"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"This is a simple demontration of how to perform a Monte Carlo simulation of the 2D Ising model:","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"# load packages\nusing MonteCarlo\n\n# load your model\nm = IsingModel(dims=2, L=8);\n\n# choose a Monte Carlo flavor and run the simulation\nmc = MC(m, beta=0.35);\nrun!(mc, sweeps=1000, thermalization=1000, verbose=false);\n\n# analyze results\nobservables(mc) # what observables do exist for that simulation?\nm = mc.obs[\"m\"] # magnetization\nmean(m)\nstd(m) # one-sigma error\n\n# create standard plots\nhist(m)\nplot(m)","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"legacy/flavors/dqmc/#Determinant-Quantum-Monte-Carlo-(DQMC)-1","page":"DQMC","title":"Determinant Quantum Monte Carlo (DQMC)","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"This is determinant quantum Monte Carlo (MC) also known auxiliary field quantum Monte Carlo. It can be used to simulate interacting fermion systems, here the auxiliary boson arises from a Hubbard Stratonovich transformation, or fermions which are naturally coupled to bosons. An example is the Attractive Hubbard Model.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"You can initialize a determinant quantum Monte Carlo simulation of a given model simply through","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"dqmc = DQMC(model, beta=5.0)","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Mandatory keywords are:","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"beta: inverse temperature","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Allowed keywords are:","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"delta_tau::Float64 = 0.1: imaginary time step size\nsafe_mult::Int = 10: stabilize Green's function calculations every safe_mult step (How many slice matrices can be multiplied until singular value information is lost due to numerical unaccuracy?)\ncheckerboard::Float64 = false: use Checkerboard decomposition (faster)\nsweeps: number of measurement sweeps\nthermalization: number of thermalization (warmup) sweeps\nseed: initialize DQMC with custom seed\nall_checks::Bool = true: turn off to suppress some numerical checks","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Afterwards, you can run the simulation by","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"run!(dqmc)","category":"page"},{"location":"legacy/flavors/dqmc/#Technical-details-1","page":"DQMC","title":"Technical details","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#Symmetric-Suzuki-Trotter-decomposition-1","page":"DQMC","title":"Symmetric Suzuki-Trotter decomposition","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"We use the symmetric version of the Suzuki-Trotter decomposition, i.e.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"\\begin{align} e^{-\\Delta\\tau \\suml T+V(l)} = \\prodj e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"where T is the hopping matrix and V(l) is the interaction matrix with l an imaginary time slice index indicating an auxiliary field dependence.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"With the imaginary time slice matrices B_l = e^-Deltatau T2 e^-Deltatau V(l) e^-Deltatau T2 the equal-time Green's function is G = left( 1 + B_M cdots B_1 right)^-1.","category":"page"},{"location":"legacy/flavors/dqmc/#Checkerboard-decomposition-1","page":"DQMC","title":"Checkerboard decomposition","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"We provide a general algorithm to construct the \"checkerboard\" split up of a generic AbstractLattice. The only requirement is that the AbstractLattice has the following two fields,","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"n_bonds::Int: total number of bonds (lattice graph edges)\nbonds::Matrix{Int}: bond matrix of shape (n_bonds, 3). Rows correspond to bonds and columns indicate source site, target site, and bond type in this order.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Of course, one can also manually construct a (more efficient) checkerboard split up by overloading the following function for the specific AbstractLattice subtype.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"MonteCarlo.build_checkerboard(l::MonteCarlo.AbstractLattice)","category":"page"},{"location":"legacy/flavors/dqmc/#MonteCarlo.build_checkerboard-Tuple{AbstractLattice}","page":"DQMC","title":"MonteCarlo.build_checkerboard","text":"build_checkerboard(l::Lattice) -> checkerboard, groups, n_groups\n\nGeneric checkerboard construction.\n\nThe methods returns     * checkerboard::Matrix{Int}: size (3, n_bonds) where                 rows = source site, target site, bondid and cols                     correspond to bonds. Sorted (along columns) in such a way                     that checkerboard[3, groups[i]] are all the bond indices                     corresponding to the i-th group.     * groups::Vector{UnitRange}: ranges indicating which columns of checkerboard                     belong to which checkerboard group.     * n_groups::Int: number of checkerboard groups.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#Effective-slice-matrices-and-Green's-function-1","page":"DQMC","title":"Effective slice matrices and Green's function","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Combining the symmetric Suzuki-Trotter and checkerboard decomposition we can write (assuming two checkerboard groups a and b)","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"\\begin{align} e^{-\\Delta\\tau \\suml T+V(l)} &= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} \\\\\n&\\times \\left( \\prodj e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"For performance resons we internally work with effective imaginary time slice matrices","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"B_l^texteff = e^-Deltatau T_b2 e^-Deltatau T_a e^-Deltatau T_b2 e^-Deltatau V","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"instead of the original B_ls above.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"warning: Warning\nNote that one consequence is that the field dqmc.s.greens isn't the actual Green's function but an effective one defined by \\begin{align} G &= \\left( 1 + BM \\cdots B1 \\right)^{-1} \\\\\n&= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} \\left( 1 + B^{\\text{eff}}M \\cdots B^{\\text{eff}}1 \\right)^{-1} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta/2} \\\\\n&= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} G^{\\text{eff}} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta/2} \\end{align}To obtain the actual equal-times Green's function, for example for measuring, use greens(dqmc::DQMC). Note that although Goverset=G^texteff} one can readily show that det G = det G^texteff holds and the Metropolis acceptance is not affected by switching to the effective matrices.","category":"page"},{"location":"legacy/flavors/dqmc/#Exports-1","page":"DQMC","title":"Exports","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"DQMC.jl\"]","category":"page"},{"location":"legacy/flavors/dqmc/#MonteCarlo.replay!","page":"DQMC","title":"MonteCarlo.replay!","text":"replay(mc::DQMC[; configurations::Iterable = mc.recorder; kwargs...])\n\nReplays previously generated configurations and measures observables along the way.\n\nKeyword Arguments (both):\n\nverbose = true: If true, print progress messaged to stdout.\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, replay! will generate a\n\nresumable save file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nfilename: Name of the save file. The default is based on safe_before.\nstart=1: The first sweep in the simulation. This will be changed when using\n\nresume!(save_file).\n\nignore: A collection of measurement keys to ignore. Defaults to the key of\n\nthe configuration measurement.\n\nmeasure_rate = 1: Rate at which measurements are taken. Note that this is \n\nbased on the recorded configurations, not actual sweeps.\n\n\n\n\n\n","category":"function"},{"location":"legacy/flavors/dqmc/#MonteCarlo.run!-Tuple{DQMC}","page":"DQMC","title":"MonteCarlo.run!","text":"run!(mc::DQMC[; kwargs...])\n\nRuns the given Monte Carlo simulation mc. Returns true if the run finished and false if it cancelled early to generate a resumable save-file.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nthermalization: Number of thermalization sweeps. Uses the value passed to\n\nDQMC by default.\n\nsweeps: Number of measurement sweeps. Uses the value passed to DQMC by\n\ndefault.\n\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, run! will generate a resumable\n\nsave file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nresumable_filename: Name of the resumable save file. The default is based on\n\nsafe_before.\n\noverwrite = false: If set to true a file with the same name as\n\nresumable_filename will be overwritten. (This will create a temporary backup)\n\nSee also: resume!\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#MonteCarlo.DQMC-Tuple{Model, Dict{Symbol, V} where V}","page":"DQMC","title":"MonteCarlo.DQMC","text":"DQMC(m::M, params::Dict)\nDQMC(m::M, params::NamedTuple)\n\nCreate a determinant quantum Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#MonteCarlo.DQMC-Tuple{M} where M<:Model","page":"DQMC","title":"MonteCarlo.DQMC","text":"DQMC(m::M; kwargs...) where M<:Model\n\nCreate a determinant quantum Monte Carlo simulation for model m with keyword parameters kwargs.\n\nKeyword Arguments:\n\nseed: The random seed used by the simulation.\ncheckerboard=false: If true, the simulation uses a generic checkerboard\n\ndecomposition.\n\nthermalization_measurements::Dict{Symbol, AbstractMeasurement}: A collection\n\nof measurements run during the thermalization stage. By default, none are used.\n\nmeasurements::Dict{Symbol, AbstractMeasurement}: A collection of measurements\n\nrun during the measurement stage. Calls default_measurements if not specified.\n\nrecorder = ConfigRecorder: Type of recorder used for saving configurations\n\ngenerated during the simulation. Used (by default) when replay!ing simulations.  (Discarder or ConfigRecorder)\n\nrecording_rate = measure_rate: Rate at which configurations are recorded.\nthermalization = 100: Number of thermalization sweeps\nsweeps: Number of measurement sweeps\nall_checks = true: Check for Propagation instabilities and sign problems.\nsafe_mult = 10: Number of \"safe\" matrix multiplications. Every safe_mult\n\nmultiplications, a UDT decomposition is used to stabilize the product.\n\ndelta_tau = 0.1: Time discretization of the path integral\nbeta::Float64: Inverse temperature used in the simulation\nslices::Int = beta / delta_tau: Number of imaginary time slice in the\n\nsimulation\n\nmeasure_rate = 10: Number of sweeps discarded between every measurement.\nlast_sweep = 0: Sets the index of the last finished sweep. The simulation\n\nwill start with sweep last_sweep + 1.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#Potential-extensions-1","page":"DQMC","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"todo","category":"page"},{"location":"DQMC/measurements/#Measurements-1","page":"Measurements","title":"Measurements","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Measurements in DQMC primarily rely on (Wick's theorem)[https://en.wikipedia.org/wiki/Wick%27stheorem] to express observables in terms of Greens function elements. The greens function in DQMC is a matrix G{ij}(k, l) = \\langle ci(k \\Delta\\tau) cj^\\dagger(l \\Delta\\tau)\\ranglef$, where \\langle\\cdot\\ranglef$ represents the fermion average. ","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Measurement are created and added via dqmc[:name] = measurement(dqmc, model). The currently implemented measurements are the following","category":"page"},{"location":"DQMC/measurements/#Greens-1","page":"Measurements","title":"Greens","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The equal time greens function can be measured via greens_measurement(dqmc, model). The measurement will take the Monte Carlo or bosonic average of greens(dqmc, model).","category":"page"},{"location":"DQMC/measurements/#Occupation-1","page":"Measurements","title":"Occupation","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The per-site occupation langle n_i rangle can be measured via occupation(dqmc, model). This will average 1 - G_ii.","category":"page"},{"location":"DQMC/measurements/#Charge-Density-1","page":"Measurements","title":"Charge Density","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The charge density correlation langle sum_r n(r) n(r+Delta r) rangle can be measured with charge_density_correlation(dqmc, model). The time integral of that, the charge density susceptibility can be measure with charge_density_susceptibility(mc, model).  Note that either way the result will be averaged over origin sites and saved by distance vectors. These vectors can be generated with directions(lattice)","category":"page"},{"location":"DQMC/measurements/#Magnetization-1","page":"Measurements","title":"Magnetization","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"magnetization(dqmc, model, dir::Symbol) measures the per-site x-, y- or z-magnetizations.","category":"page"},{"location":"DQMC/measurements/#Spin-Density-1","page":"Measurements","title":"Spin Density","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The spin density correlation langle S_gamma S_gamma rangle in x-, y- or z-direction can be measured with spin_density_correlation(dqmc, model, dir::Symbol). The respective susceptibilities follow from spin_density_susceptibility(dqmc, model, dir).","category":"page"},{"location":"DQMC/measurements/#Pairing-1","page":"Measurements","title":"Pairing","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The pairing susceptibility Delta_v(s_1 t_1)(tau) Delta_v^dagger(s_2 t_2)(0) can be calculated with pairing_susceptibility(dqmc, model). The tau = 0 pairing correlation follows from pairing_correlation(dqmc, model).","category":"page"},{"location":"DQMC/measurements/#Current-Current-Susceptibility-1","page":"Measurements","title":"Current-Current Susceptibility","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"current_current_susceptibility(dqmc, model) measures langle j_t_2 - s_2(s_2 l) j_t_1 - s_1(s_1 0)rangle with j_t - s(s tau) = lange i sum_sigma T_ts c_t^dagger(tau) c_s(tau) - T_st c_s^dagger(tau) c_t(tau) rangle where i^2 = -1 and T is the hopping matrix.","category":"page"},{"location":"DQMC/measurements/#Superfluid-Density-1","page":"Measurements","title":"Superfluid Density","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"superfluid_density(dqmc, model, L) computes the superfluid density using the current current susceptibility for a lattice of linear system size L.","category":"page"},{"location":"DQMC/measurements/#Energies-1","page":"Measurements","title":"Energies","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The energy can be measured with total_energy(dqmc, model). The interacting and noninteracting parts can be measured independently with interacting_energy(dqmc, model) and noninteracting_energy(dqmc, model)","category":"page"},{"location":"DQMC/measurements/#General-Notes-1","page":"Measurements","title":"General Notes","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"All measurements are implemented via","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"struct DQMCMeasurement{GI, LI, F <: Function, OT, T} <: AbstractMeasurement\n    greens_iterator::GI\n    lattice_iterator::LI\n    kernel::F\n    observable::OT\n    temp::T\nend","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The greens_iterator is a type that will be constructed when the simulation starts running. This allows measurements using the same set of greens matrices to be bundled, improving performance especially for unequal time measurements (susceptibilities). There are currently three greens iterators:","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Greens which forwards the equal time greens function\nGreensAt{k, l} which forwards the result of greens(dqmc, k, l)\nCombinedGreensIterator which goes through all time slices l = 1 .. M and forwards G(0 0), G(0 Deltatau l), G(Deltatau l 0) and G(Deltatau l Deltatau l). This implicitly sums results over different time slices and multiplies the result by Deltatau, i.e. it implicitly calculates O_idxs = int_0^beta O_idxs(tau) dtau.","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The lattice_iterator is also (usually) a type with deferred construction. This iterator generates site indices which are ultimately passed on to the kernel with the Greens matrices generated by greens_iterator. The iterators are given on the lattice page. Depending on the iterator in use, there may be some implicit summation:","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"DirectLatticeIterators do not perform summation, i.e. the indices idxs... are used as temp[idxs...] = kernel(..., idxs..., ...)\nDeferredLatticeIterators return directional indices which are used to index the output and site indices which are passed to kernel. This means there is an implicit summation here, which reduces a all site indices to directional indices. The result is then normalized by dividing by the number of summed results, which is the number of sites.\nSum{<: LatticeIterator} explicitly sums all kernel results. This will also apply normalizations of the wrapped iterator if it has any.\nApplySymmetries{<: DeferredLatticeIterator} performs the summation and normalization of the wrapped iterator, and then applies the symmetry weights to the second or second and third directional indices and sums up the result. This leaves the an array with one directional index.","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The kernel is a function that basically just applies the results from Wicks theorem. For example, the kernel for charge density susceptibilities is given by","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"function cdc_kernel(mc, model, ij::NTuple{2}, packed_greens::NTuple{4})\n    i, j = ij\n\tG00, G0l, Gl0, Gll = packed_greens\n    N = length(lattice(mc))\n\n    # ⟨n↑(l)n↑⟩\n    (1 - Gll[i, i]) * (1 - G00[j, j]) -\n    G0l[j, i] * Gl0[i, j] +\n    # ⟨n↑(l)n↓⟩\n    (1 - Gll[i, i]) * (1 - G00[j+N, j+N]) -\n    G0l[j+N, i] * Gl0[i, j+N] +\n    # ⟨n↓(l)n↑⟩\n    (1 - Gll[i+N, i+N]) * (1 - G00[j, j]) -\n    G0l[j, i+N] * Gl0[i+N, j] +\n    # ⟨n↓(l)n↓⟩\n    (1 - Gll[i+N, i+N]) * (1 - G00[j+N, j+N]) -\n    G0l[j+N, i+N] * Gl0[i+N, j+N]\nend","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The passed indices and greens matrices vary depending on the chosen iterators. The indices could be a single integer, a tuple of two or a tuple of four integers. packed_greens could be a greens matrix (which could be a special matrix type like BlockDiagonal) or a tuple of four greens matrices.","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The observable is the final storage of the measured values. By default this is a LogBinner from BinningAnalysis.jl but that can be changed. The only hard requirement is that the data structure implements push!. The shape and type of the values pushed to the container can be derived from the greens element type returned by geltype(dqmc) and the shape tuple returned by _get_final_shape(dqmc, model, lattice_iterator).","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The temp field is a temporary storage Array used as a target for summation before pushing the final result of the measurement. It should be initialized to ","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"temp = let\n    shape = _get_temp_shape(dqmc, _model, lattice_iterator)\n    shape === nothing ? nothing : Array{geltype(dqmc)}(undef, shape)\nend","category":"page"},{"location":"legacy/lattices/#Lattices-1","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"The package ships with a couple of standard lattices","category":"page"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"Type Description\nMonteCarlo.Chain 1-dimensional chain\nMonteCarlo.SquareLattice 2-dimensional square lattice\nMonteCarlo.CubicLattice D-dimensional cubic lattice","category":"page"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"It also provides routines to load the following common lattice formats","category":"page"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"Type Description\nMonteCarlo.ALPSLattice ALPS simple lattice graph (XML file)","category":"page"},{"location":"legacy/lattices/#Didn't-find-your-desired-lattice?-1","page":"Lattices","title":"Didn't find your desired lattice?","text":"","category":"section"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"Just implement your own lattice for later use in a model of choice. See Custom lattices.","category":"page"},{"location":"legacy/customize/#Customize-1","page":"Customize","title":"Customize","text":"","category":"section"},{"location":"legacy/customize/#Custom-models-1","page":"Customize","title":"Custom models","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Although MonteCarlo.jl already ships with famous models, foremost the Ising and Hubbard models, the central idea of the design of the package is to have a (rather) well defined interface between models and Monte Carlo flavors. This way it should be easy for you to extend the package and implement your own physical model (or variations of existing models). You can find the interfaces in the corresponding section of the documentation, for example: Interface: Monte Carlo (MC).","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Sometimes examples tell the most, so feel encouraged to have a look at the implementations of the above mentioned models to get a feeling of how to implement your own model.","category":"page"},{"location":"legacy/customize/#General-remarks-for-lattice-models-1","page":"Customize","title":"General remarks for lattice models","text":"","category":"section"},{"location":"legacy/customize/#Semantics-1","page":"Customize","title":"Semantics","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"For lattice models, we define a Model to be a Hamiltonian on a lattice. Therefore, the lattice is part of the model (and not the Monte Carlo flavor). The motivation for this modeling is that the physics of a system does not only depend on the Hamiltonian but also (sometime drastically) on the underlying lattice. This is for example very obvious for spin systems which due to the lattice might become (geometrically) frustrated and show spin liquids physics. Also, from a technical point of view, lattice information is almost exclusively processed in energy calculations which both relate to the Hamiltonian (and therefore the model).","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"note: Note\nWe will generally use the terminology Hamiltonian, energy and so on. However, this doesn't restrict you from defining your model as an Lagrangian with an action in any way as this just corresponds to a one-to-one mapping of interpretations.","category":"page"},{"location":"legacy/customize/#Lattice-requirements-1","page":"Customize","title":"Lattice requirements","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"The Hamiltonian of your model might impose some requirements on the AbstractLattice object that you use as it must provide you with enough lattice information.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"It might be educating to look at the structure of the simple SquareLattice struct.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"mutable struct SquareLattice <: AbstractCubicLattice\n   L::Int\n   sites::Int\n   neighs::Matrix{Int} # row = up, right, down, left; col = siteidx\n   neighs_cartesian::Array{Int, 3} # row (1) = up, right, down, left; cols (2,3) = cartesian siteidx\n   sql::Matrix{Int}\n   SquareLattice() = new()\nend","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"It only provides access to next nearest neighbors through the arrays neighs and neighs_cartesian. If your model's Hamiltonian requires higher order neighbor information, because of, let's say, a next next nearest neighbor hopping term, the SquareLattice doesn't suffice. You could either extend this lattice or implement a NNSquareLattice for example.","category":"page"},{"location":"legacy/customize/#Custom-lattices-1","page":"Customize","title":"Custom lattices","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"As described in Custom models a lattice is considered to be part of a model. Hence, most of the requirements for fields of a AbstractLattice subtype come from potential models (see Lattice requirements). Below you'll find information on which fields are mandatory from a Monte Carlo flavor point of view.","category":"page"},{"location":"legacy/customize/#Mandatory-fields-1","page":"Customize","title":"Mandatory fields","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Any concrete lattice type, let's call it MyLattice in the following, must be a subtype of the abstract type MonteCarlo.AbstractLattice. To work with a Monte Carlo flavor, it must internally have at least have the following field,","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"sites: number of lattice sites.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"However, as already mentioned above depending on the physical model of interest it will typically also have (at least) something like","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"neighs: next nearest neighbors,","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"as most Hamiltonian will need next nearest neighbor information.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"The only reason why such a field isn't generally mandatory is that the Monte Carlo routine doesn't care about the lattice much. Neighbor information is usually only used in the energy (difference) calculation of a particular configuration like done in energy or propose_local which both belong to a Model.","category":"page"},{"location":"legacy/customize/#Custom-Monte-Carlo-flavors-1","page":"Customize","title":"Custom Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Coming soon...","category":"page"},{"location":"legacy/interfaces/DQMC/#Interface:-Determinant-Quantum-Monte-Carlo-(DQMC)-1","page":"DQMC","title":"Interface: Determinant Quantum Monte Carlo (DQMC)","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Any model that wants to be simulated by means of DQMC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the determinant Monte Carlo flavor Determinant Quantum Monte Carlo (DQMC).","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Example models: Attractive Hubbard Model","category":"page"},{"location":"legacy/interfaces/DQMC/#Mandatory-fields-1","page":"DQMC","title":"Mandatory fields","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"l::AbstractLattice: any AbstractLattice\nflv::Int: number of distinct fermion flavors (e.g. spins, bands, etc.). The Green's function will have shape (flv*N, flv*N), where N is the number of sites. Note that different fermion flavors are often related by symmetry and it's advisable to use this symmetry to work with smaller Green's function matrices. Have a look at the Attractive Hubbard Model as an example where flv=1 although it has spinful fermions.","category":"page"},{"location":"legacy/interfaces/DQMC/#Index-of-all-methods-1","page":"DQMC","title":"Index of all methods","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Pages = [\"DQMC.md\"]","category":"page"},{"location":"legacy/interfaces/DQMC/#Mandatory-methods-1","page":"DQMC","title":"Mandatory methods","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"CurrentModule = MonteCarlo","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"conftype(::Type{DQMC}, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"rand(::DQMC, ::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"hopping_matrix(mc::DQMC, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.hopping_matrix-Tuple{DQMC, Model}","page":"DQMC","title":"MonteCarlo.hopping_matrix","text":"hopping_matrix(mc::DQMC, m::Model)\n\nCalculates the hopping matrix T_isigma jsigma  where i j are  site indices and sigma  sigma  are flavor indices (e.g. spin indices).  The hopping matrix should also contain potential chemical potential terms on the  diagonal.\n\nA matrix element is the hopping amplitude for a hopping process: jsigma   rightarrow isigma.\n\nRegarding the order of indices, if T[i, σ, j, σ'] is your desired 4D hopping  array, then reshape(T, (n_sites * n_flavors, :)) is the hopping matrix.\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"interaction_matrix_exp!(mc::DQMC, m::Model, result::Matrix, conf, slice::Int, power::Float64=1.)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.interaction_matrix_exp!","page":"DQMC","title":"MonteCarlo.interaction_matrix_exp!","text":"interaction_matrix_exp!(\n    mc::DQMC, m::Model, result::AbstractArray, conf, slice::Int, power::Float64=1.\n) -> nothing\n\nCalculate the interaction matrix exponential  expV = exp(- power * delta_tau * V(slice)) and store it in result::Matrix.  Potential chemical potential terms should be part of the hopping_matrix and  not the interaction.\n\nThis is a performance critical method and one might consider efficient in-place  (in result) construction.\n\n\n\n\n\n","category":"function"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"propose_local(mc::DQMC, m::Model, i::Int, conf, E_boson::Float64)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.propose_local-Tuple{DQMC, Model, Int64, Any, Float64}","page":"DQMC","title":"MonteCarlo.propose_local","text":"propose_local(mc::DQMC, m::Model, i::Int, conf) -> detratio, ΔE_boson, passthrough\n\nPropose a local move for lattice site i of current configuration conf .  Returns the Green's function determinant ratio, the boson energy difference  ΔE_boson = E_boson_new - E_boson, and potentially additional local move information passthrough (will be  forwarded to accept_local!).\n\nSee also accept_local!.\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"accept_local(mc::DQMC, m::Model, i::Int, slice::Int, conf, delta, detratio, delta_E_boson)","category":"page"},{"location":"legacy/interfaces/DQMC/#Optional-methods-1","page":"DQMC","title":"Optional methods","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"greenseltype(::Type{DQMC}, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.greenseltype-Tuple{Type{DQMC}, Model}","page":"DQMC","title":"MonteCarlo.greenseltype","text":"greenseltype(::Type{DQMC}, m::Model)\n\nReturns the type of the elements of the Green's function matrix. Defaults to      ComplexF64.\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"energy_boson(mc::DQMC, m::Model, conf)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.energy_boson-Tuple{DQMC, Model, Any}","page":"DQMC","title":"MonteCarlo.energy_boson","text":"energy_boson(mc::DQMC, m::Model, conf)\n\nCalculate bosonic part (non-Green's function determinant part) of energy for  configuration conf for Model m.\n\nThis is required for global and parallel updates as well as boson energy  measurements.\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"prepare_observables(mc::DQMC, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"measure_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable}, conf)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"finish_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable})","category":"page"},{"location":"legacy/flavors/mc/#Monte-Carlo-(MC)-1","page":"MC","title":"Monte Carlo (MC)","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"This is plain simple Monte Carlo (MC). It can for example be used to simulate the Ising model (see 2D Ising model).","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"You can initialize a Monte Carlo simulation of a given model simply through","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"mc = MC(model)","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Allowed keywords are:","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"beta: inverse temperature\nsweeps: number of measurement sweeps\nthermalization: number of thermalization (warmup) sweeps\nglobal_moves: wether global moves should be proposed\nglobal_rate: frequency for proposing global moves\nseed: initialize MC with custom seed","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Afterwards, you can run the simulation by","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"run!(mc)","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Note that you can just do another run!(mc, sweeps=1000) to continue the simulation.","category":"page"},{"location":"legacy/flavors/mc/#Examples-1","page":"MC","title":"Examples","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model.","category":"page"},{"location":"legacy/flavors/mc/#Exports-1","page":"MC","title":"Exports","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"MC.jl\"]","category":"page"},{"location":"legacy/flavors/mc/#MonteCarlo.replay!","page":"MC","title":"MonteCarlo.replay!","text":"replay(mc::MC[, configurations::Iterable = mc.configs; kwargs...])\n\nReplays previously generated configurations and measures observables along the way.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, replay! will generate a\n\nresumable save file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nfilename: Name of the save file. The default is based on safe_before.\nmeasure_rate = 1: Rate at which measurements are taken. Note that this is \n\nbased on the recorded configurations, not actual sweeps.\n\n\n\n\n\n","category":"function"},{"location":"legacy/flavors/mc/#MonteCarlo.run!-Tuple{MC}","page":"MC","title":"MonteCarlo.run!","text":"run!(mc::MC[; kwargs...])\n\nRuns the given Monte Carlo simulation mc. Returns true if the run finished and false if it cancelled early to generate a resumable save-file.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nthermalization: Number of thermalization sweeps. Uses the value passed to\n\nDQMC by default.\n\nsweeps: Number of measurement sweeps. Uses the value passed to DQMC by\n\ndefault.\n\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, run! will generate a resumable\n\nsave file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nresumable_filename: Name of the resumable save file. The default is based on\n\nsafe_before.\n\noverwrite = false: If set to true a file with the same name as\n\nresumable_filename will be overwritten. (This will create a temporary backup)\n\nSee also: resume!\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/mc/#MonteCarlo.MC","page":"MC","title":"MonteCarlo.MC","text":"Monte Carlo simulation\n\n\n\n\n\n","category":"type"},{"location":"legacy/flavors/mc/#MonteCarlo.MC-Tuple{M} where M<:Model","page":"MC","title":"MonteCarlo.MC","text":"MC(m::M; kwargs...) where M<:Model\n\nCreate a Monte Carlo simulation for model m with keyword parameters kwargs.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/mc/#MonteCarlo.MC-Union{Tuple{T}, Tuple{Model, Dict{Symbol, T}}} where T","page":"MC","title":"MonteCarlo.MC","text":"MC(m::M, params::Dict)\nMC(m::M, params::NamedTuple)\n\nCreate a Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/mc/#Potential-extensions-1","page":"MC","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Heat bath (instead of Metropolis) option","category":"page"},{"location":"DQMC/lattice/#Lattices-1","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Lattices are a generic component for both quantum and classical Monte Carlo simulations. At this point they are part of the model. We currently offer a couple of directly implemented lattices, an interface for loading ALPS lattices and an interface to LatticePhysics.jl.","category":"page"},{"location":"DQMC/lattice/#Available-Lattices-1","page":"Lattices","title":"Available Lattices","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"We currently have the following lattices. Unless mentioned, they all include nearest neighbor bonds.","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Chain(N): A one dimensional chain lattice with N sites.\nSquareLattice(L): A two dimensional square lattice with L² sites.\nCubicLattice(D, L): A D dimensional cubic lattice with L^D sites.\nTriangularLattice(L[; Lx = L, Ly = L]): A two dimensional triangular lattice with Lx * Ly sites. This lattice also includes next nearest neighbor bonds.","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Additionally we have ALPSLattice(file) which loads an ALPS lattice from an xml file and LatPhysLattice(lattice) which wraps a generic lattice from LatticePhysics.jl.","category":"page"},{"location":"DQMC/lattice/#Implementing-your-own-Lattice-1","page":"Lattices","title":"Implementing your own Lattice","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"If you want to implement your own lattice you need to implement a couple of things for compatibility. Your lattice should inherit from MonteCarlo.AbstractLattice. It should implement a method length(lattice) returning the total number of sites.  The more complex lattice iterators require a method positions(lattice) returning the positions of each site in matching order, and a method lattice_vectors(lattice) returning D vectors pointing from one end of the lattice to the other along nearest neighbor directions, where D is the dimensionality of the lattice.  If you are using the default models you will also need to implement some way to get nearest neighbor directions. You have two options here - either implement some traits and fields or implement the getter function directly. For the first option you need to implement: ","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"the field neighs::Matrix{Int} with target = neighs[neighbor_idx, source] and has_neighbors_table(lattice) = true\nthe field bonds::Matrix{Int} where (source, target, type) = bonds[total_bond_idx, :] and has_bonds_table(lattice) = true","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"For the second option you need to write your own neighbors(lattice, directed) where directed = Val{true} returns forward and backwards facing bonds and directed = Val{false} considers those the same, returning only one of them.","category":"page"},{"location":"DQMC/lattice/#Lattice-Iterators-1","page":"Lattices","title":"Lattice Iterators","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Lattice Iterators are to some degree a backend component. They specify and often cache a way to iterate through the lattice. They are mainly used for DQMC measurements, which frequently require specific pairing of sites. There are currently three abstract subtypes of lattice iterators, each with multiple concrete types. Each concrete iterator can be created via iterator(dqmc, model).","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"First we have DirectLatticeIterator. These iterators return just site indices, e.g. (source_index, target_index). The concrete implementations include:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"EachSiteAndFlavor iterates all indices from 1 to length(lattice) * nflavors(model)\nEachSite iterates all indices from 1 to length(lattice)\nOnSite also iterates from 1:length(lattice), however returns two indices (i, i) at each step\nEachSitePair iterates through all possible pairs (i, j) where both i and j run from 1 to length(lattice).","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Next we have DeferredLatticeIterator. These iterators return some meta information with each site index, for example a directional index. They are used to do partial summation. The concrete implementations include:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"EachSitePairByDistance which iterates the same range as EachSitePair but returns (dir_idx, i, j) at each step.\nEachLocalQuadByDistance{K} iterates through four sets (1, length(lattice)), returning (combined_dir_idx, src1, trg1, src2, trg2) at each step. Here the directional index relates to three directional indices (dir_idx, dir_idx1, dir_idx2) representing the vectors between src1 and src2, src1 and trg1, and src2 and trg2 respectively. K restricts the included number of bonds between src1 and trg1 (and src2 and trg2). Note that an on-site connection is also counted here - i.e. to include four nearest neighbors you must set K = 5.\nEachLocalQuadBySyncedDistance{K} does the same thing as EachLocalQuadByDistance{K} with the additional of synchronizing the direction between (src1, trg1) and (src2, trg2).","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Note that you can get the directions matching the indices from directions(lattice/model/dqmc).","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Lastly we have LatticeIterationWrapper{LI <: LatticeIterator}. Generally results from DeferredLatticeIterators will be saved in a vector, where values[dir_idx] is the sum of all values with the same directional index. The wrappers are there to further process what happens to these values before they are saved. The parametric type of them specifies the iteration procedure that is used. The concrete implementations are:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Sum{LI} tells the measurement to sum up all values before saving.\nApplySymmetry{LI}(symmetries...) tells the measurement to do sum directional indices past the first with some weights given as symmetries. For example you may use ApplySymmetry{EachLocalQuadByDistance}([1], [0, 1, 1, 1, 1]) to generate s-wave and extended s-wave summations for square lattices.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"(Image: logo)","category":"page"},{"location":"legacy/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is a Julia software library for the simulation of physical models by means of the Markov Chain Monte Carlo technique. The package implements classical and quantum Monte Carlo flavors which can be used to study spin systems, interacting fermions, and boson-fermion mixtures.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe documentation is out-of-date!","category":"page"},{"location":"legacy/#Included-models:-1","page":"Introduction","title":"Included models:","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Ising model\nAttractive Hubbard model","category":"page"},{"location":"legacy/#Included-Monte-Carlo-flavors-1","page":"Introduction","title":"Included Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Classical Monte Carlo\nDeterminant Quantum Monte Carlo (also known as auxiliary field Monte Carlo)","category":"page"},{"location":"legacy/#Included-lattices-1","page":"Introduction","title":"Included lattices","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Cubic lattices (chain, square, cube, ...)\nAny ALPS lattice","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Have a look at the Showcase section to get some inspiration.","category":"page"},{"location":"legacy/#Study-your-own-model-1","page":"Introduction","title":"Study your own model","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"A major idea behind the design of the package is convenient customization. Users should be able to define their own custom physical models (or extend existing ones) and explore their physics through Monte Carlo simulations. We hope that MonteCarlo.jl allows the user to put his focus on his physical model rather than tedious implementations of Monte Carlo schemes.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"To that end, each (quantum) Monte Carlo flavor has a well-defined model interfaces, i.e. a precise specification of mandatory and optional fields and methods. An example can be found here: Interface: Monte Carlo (MC). Practically, it makes sense to start by taking a look at the implementation of one of the predefined models.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"If you implement a custom model that might be worth being added to the collection of supplied models, please consider creating a pull request!","category":"page"},{"location":"legacy/#GitHub-1","page":"Introduction","title":"GitHub","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is open-source. The source code can be found on github. Criticism and contributions are very much welcome - just open an issue. For more details see the Contribution Guide.","category":"page"},{"location":"legacy/models/ising/#Ising-Model-1","page":"Ising model","title":"Ising Model","text":"","category":"section"},{"location":"legacy/models/ising/#Hamiltonian-1","page":"Ising model","title":"Hamiltonian","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"The famous Hamiltonian of the Ising model is given by","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"\\begin{align} \\mathcal{H} = -\\sum{\\langle i,j \\rangle} \\sigmai \\sigma_j , \\end{align}","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"where langle i j rangle indicates that the sum has to be taken over nearest neighbors.","category":"page"},{"location":"legacy/models/ising/#Creating-an-Ising-model-1","page":"Ising model","title":"Creating an Ising model","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"You can create an Ising model as follows,","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"model = IsingModel(; dims::Int=2, L::Int=8)","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"The following parameters can be set via keyword arguments:","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"dims: dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)\nL: linear system size","category":"page"},{"location":"legacy/models/ising/#Supported-Monte-Carlo-flavors-1","page":"Ising model","title":"Supported Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Monte Carlo (MC) (Have a look at the examples section below)","category":"page"},{"location":"legacy/models/ising/#Examples-1","page":"Ising model","title":"Examples","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model.","category":"page"},{"location":"legacy/models/ising/#Exports-1","page":"Ising model","title":"Exports","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"IsingModel.jl\"]","category":"page"},{"location":"legacy/models/ising/#MonteCarlo.IsingModel","page":"Ising model","title":"MonteCarlo.IsingModel","text":"Famous Ising model on a cubic lattice.\n\nIsingModel(; dims, L)\n\nCreate Ising model on dims-dimensional cubic lattice with linear system size L.\n\n\n\n\n\n","category":"type"},{"location":"legacy/models/ising/#MonteCarlo.IsingModel-Union{Tuple{Dict{Symbol, T}}, Tuple{T}} where T","page":"Ising model","title":"MonteCarlo.IsingModel","text":"IsingModel(params::Dict)\nIsingModel(params::NamedTuple)\n\nCreate an Ising model with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"legacy/models/ising/#Analytic-results-1","page":"Ising model","title":"Analytic results","text":"","category":"section"},{"location":"legacy/models/ising/#Square-lattice-(2D)-1","page":"Ising model","title":"Square lattice (2D)","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"The model can be solved exactly by transfer matrix method (Onsager solution). This gives the following results.","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Critical temperature: T_c = frac2ln1+sqrt2","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Magnetization (per site): m = left(1-leftsinh 2beta right^-4right)^frac 18","category":"page"},{"location":"legacy/models/ising/#Potential-extensions-1","page":"Ising model","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Arbitrary dimensions\nMagnetic field\nMaybe explicit J instead of implicit J=1\nNon-cubic lattices (just add lattice::AbstractLattice keyword)","category":"page"},{"location":"DQMC/scheduler/#Update-Scheduler-1","page":"Update Scheduler","title":"Update Scheduler","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The update scheduler keeps track of and iterates through various Monte Carlo updates. Currently there are two schedulers, SimpleScheduler and AdaptiveScheduler, and five (full) updates.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"note: Note\nThis is a DQMC only feature at the moment.","category":"page"},{"location":"DQMC/scheduler/#Schedulers-1","page":"Update Scheduler","title":"Schedulers","text":"","category":"section"},{"location":"DQMC/scheduler/#SimpleScheduler-1","page":"Update Scheduler","title":"SimpleScheduler","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The SimpleScheduler keeps track of a sequence of updates and cycles through them as update(scheduler, mc, model) is called. It is constructed by simply passing a sequence of updates, i.e. SimpleScheduler(update1, update2, ...).","category":"page"},{"location":"DQMC/scheduler/#AdaptiveScheduler-1","page":"Update Scheduler","title":"AdaptiveScheduler","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The AdaptiveScheduler also has a static sequence of updates, but allows some of these updates to be Adaptive(). Any Adaptive() update in the sequence is replaced with an update from a pool based on their relative weights. These weights are derived from their acceptance rates with some lag.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"An adaptive scheduler is created with a sequence of updates and a pool of updates, i.e.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"sequence = (update1, Adaptive())\npool = (update2, update3)\nscheduler = AdaptiveScheduler(sequence, pool)","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Additionally there are a couple of keywords to configure how weights are adjusted.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"minimum_sampling_rate = 0.01: This defines the threshold under which the ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"sampling rate is set to 0.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"grace_period = 99: This sets a minimum number of times an update needs to ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"be called before its sampling rate is adjusted. ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"adaptive_rate = 9.0: Controls how fast the sampling rate is adjusted to the ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"acceptance rate. More means slower.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The adjustments of the sampling rate follow the formula \\begin{equation} \\frac{(adaptiverate * samplingrate + \\frac{accepted}{total} }{ adaptive_rate + 1 } \\end{equation}","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"note: Note\nAll schedulers wrap their updates in AcceptanceStatistics. This wrapper keeps track of the total number of update attempts and the number of accepted updates.","category":"page"},{"location":"DQMC/scheduler/#Updates-1","page":"Update Scheduler","title":"Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Updates are small or even empty structs used to dispatch to different update functions. They are assumed to implement name(::MyUpdate) = \"MyUpdate\" and a method update(::MyUpdate, mc, model). ","category":"page"},{"location":"DQMC/scheduler/#Local-Updates-1","page":"Update Scheduler","title":"Local Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Local updates affect one site at one time slice. In order for this to be on a similar scale as global and parallel updates, local updates should come in full sweeps. ","category":"page"},{"location":"DQMC/scheduler/#LocalSweep-1","page":"Update Scheduler","title":"LocalSweep","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Currently there is only one local update - LocalSweep([N=1]). It performs N standard sweeps of local updates, which means two updates per site and time slice each in DQMC. (Two because we go from tau = 0 to tau = beta back to tau = 0.) This update returns a float corresponding to its internal acceptance rate accepted  (2 N_sites M_slices","category":"page"},{"location":"DQMC/scheduler/#Global-Updates-1","page":"Update Scheduler","title":"Global Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Global updates affect not just one site at one time slice, but most if not all sites at all time slices. In other words they attempt to adjust the full configuration. We currently have two global updates.","category":"page"},{"location":"DQMC/scheduler/#GlobalFlip-1","page":"Update Scheduler","title":"GlobalFlip","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The GlobalFlip() proposes a flip of the full configuration, i.e. pm 1 to mp 1, and return 0 or 1 depending on whether this update is rejected or not.","category":"page"},{"location":"DQMC/scheduler/#GlobalShuffle-1","page":"Update Scheduler","title":"GlobalShuffle","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"GlobalShuffle() performs a shuffle(current_configuration) to generate a new configuration and return 0 or 1 depending on whether that configuration is rejected or not.","category":"page"},{"location":"DQMC/scheduler/#Parallel-Updates-1","page":"Update Scheduler","title":"Parallel Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Parallel updates communicate between different simulations running on different workers. Note that these simulations must produce configurations of the same size, i.e. have same number of time slices and sites.","category":"page"},{"location":"DQMC/scheduler/#ReplicaExchange-1","page":"Update Scheduler","title":"ReplicaExchange","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The ReplicaExchange(target) update requires a target worker, and it requires that worker to be in sync. Specifically that means if worker 1 has a ReplicaExchange(2) followed by ReplicaExchange(3), worker 2 must have ReplicaExchange(1) as its first replica exchange update and worker 3 must have ReplicaExchange(1) as its second replica exchange update.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The idea of a replica exchange update is to propose swapping configurations between two simulations. The exchange is based on the product of both of their acceptance probabilities. With C_i the configuration of simulation i and w_i(C) the weight of simulation i with the given configuration the acceptance probability is given by","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"p = fracw_1(C_2)w_1(C_1) cdot fracw_2(C_1)w_2(C_2)","category":"page"},{"location":"DQMC/scheduler/#ReplicaPull-1","page":"Update Scheduler","title":"ReplicaPull","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"ReplicaPull() is an experimental parallel update. Instead of synchronizing with another simulations it pulls a configuration asynchronously and uses that for a global update. This means that there is little waiting on other simulations, but configurations will be duplicated.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"This update cycles through a pool of connected workers. This pool can be of any size. Each simulation must make itself available for pulling via connect(target_workers). The target_workers should generally be the workers the simulation wants to receive configurations from. When a simulation reaches the end it will automatically disconnect(target_workers).","category":"page"},{"location":"DQMC/model/#Models-1","page":"Model","title":"Models","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"The Model is an abstract type whose concrete versions should implement lightweight description of a Hamiltonian. There are two Models implemented for DQMC - the attractive and repulsive Hubbard model.","category":"page"},{"location":"DQMC/model/#Attractive-Hubbard-Model-1","page":"Model","title":"Attractive Hubbard Model","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"The attractive (negative U) Hubbard model is given by","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"mathcalH = -t sum_langle ij rangle sigma left( c^dagger_isigma c_jsigma + texthc right) - U sum_j left( n_juparrow - frac12 right) left( n_jdownarrow - frac12 right) - musum_j n_j","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"where sigma denotes spin, t is the hopping amplitude, U the on-site attractive interaction strength, mu the chemical potential and langle i j rangle indicates that the sum has to be taken over nearest neighbors. Note that (1) is written in particle-hole symmetric form such that mu = 0 corresponds to half-filling.","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"The parameters U = 10, t = 10 and mu = 0 as well as the lattice are saved in the model. They can be specified via keyword arguments when calling HubbardModelAttractive().","category":"page"},{"location":"DQMC/model/#Repulsive-Hubbard-Model-1","page":"Model","title":"Repulsive Hubbard Model","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"The repulsive (positive U) Hubbard model is given by","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"mathcalH = -t sum_langle ij rangle sigma left( c^dagger_isigma c_jsigma + texthc right) + U sum_j left( n_juparrow - frac12 right) left( n_jdownarrow - frac12 right)","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"where sigma denotes spin, t is the hopping amplitude, U the on-site repulsive interaction strength and langle i j rangle indicates that the sum has to be taken over nearest neighbors. This model does not include a chemical potential due to the sign problem.","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"The parameters U = 10 and t = 10 as well as the lattice are saved in the model. They can be specified via keyword arguments when calling HubbardModelRepulsive().","category":"page"},{"location":"DQMC/model/#Creating-your-own-Model-1","page":"Model","title":"Creating your own Model","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"To create your own model you will need to inherit from Model. There is a set of mandatory and optional methods you must/can implement:","category":"page"},{"location":"DQMC/model/#Mandatory-Methods-1","page":"Model","title":"Mandatory Methods","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"rand(::Type{DQMC}, m::Model, nslices) should return a full new random configuration, where nslices is the number of imaginary time slices.\nnflavors(m::Model) should return the number of fermion flavors used by the model. This controls the size of most simulation matrices, e.g. the greens matrix, hopping and interaction matrices, etc.\nhopping_matrix(dqmc::DQMC, m::Model) should return the hopping matrix of the model. This includes all terms that are not connected to a bosonic field.\ninteraction_matrix_exp!(dqmc::DQMC, m::Model, result::AbstractArray, conf, slice, power=1.0) should calculate exp(- power cdot delta_tau cdot V_slice) for the current conf at time slice slice and save it to result. Note that this method is performance critical.\npropose_local(dqmc::DQMC; m::Model, i, slice, conf) should propose a local update at site i and the current tiem slice. It should calculate the determinant ratio and bosonic energy difference (which maybe 0 for some models) and return determinant_ratio, bosonic_energy, passthrough where passthrough are a tuple of variables you may want to use in accept_local!. Note this is also a performance critical method.\naccept_local!(mc::DQMC, m::Model, i, slice, conf, detratio, ΔE_boson, passthrough) should update the greens function when the proposed change is accepted. Specifically this means updating dqmc.stack.greens. This is a performance critical method.","category":"page"},{"location":"DQMC/model/#(Semi-)-Optional-Methods-1","page":"Model","title":"(Semi-) Optional Methods","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"greenseltype(::Type{DQMC}, m::Model) = ComplexF64 sets the element type of the greens function. If your greens function is real this function should be implemented for better performance.\nhoppingeltype(::Type{DQMC}, m::Modle) = Float64 sets the expected element type of the hopping matrix. Adjust this if it is wrong.\ninteraction_matrix_type(::Type{DQMC}, m::Model) = Matrix{greenseltype(DQMC, m)} Sets the matrix type of the interaction matrix. For the Hubbard model this is Diagonal{Float64}.\nhopping_matrix_type(::Type{DQMC}, m::Model) = Matrix{hoppingeltype(DQMC, m)} Sets the matrix type of the hopping matrix. If there is a more efficient way to represent your matrix you may use this to change to that representation. The repulsive Hubbard model uses BlockDiagonal matrices, for example, which are implemented by MonteCarlo.jl\ngreens_matrix_type(::Type{DQMC}, m::Model) = Matrix{greenseltype(DQMC, m)} Sets the matrix type of the greens matrix. The repulsive Hubbard model also uses BlockDiagonal here.\ninit_interaction_matrix(m::Model) initializes the interaction matrix. If you are using a custom matrix type you must implement this. Note that the values are irrelevant.\nenergy_boson(dqmc::DQMC, m::Model, conf) should be implemented if you want to measure energies in your simulation.\nparameters(m::Model) should collect the parameters from the model and lattice in a NamedTuple. This is purely utility.","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"Also note that you may need to update the measurement kernels. More information about that on the measurement page.","category":"page"},{"location":"DQMC/Introduction/#Determinant-Quantum-Monte-Carlo-1","page":"Introduction","title":"Determinant Quantum Monte Carlo","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"Determinant Quantum Monte Carlo is a Quantum Monte Carlo algorithm for fermionic Hamiltonians. The general idea is to use the Hubbard-Stranovich transformation to simplify the Hamiltonian to one with only quadratic fermionic degrees of freeedom. This introduces a bosonic fields for quartic terms, which can be sampled by a Monte Carlo procedure.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"The minimal working example for a DQMC simulation is the following.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"using MonteCarlo\n\nmodel = HubbardModelAttractive(4, 2)\ndqmc = DQMC(model, beta=1.0)\nrun(dqmc)","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"This will set up and run a DQMC simulation at inverse temperature beta = 10 using an attractive Hubbard model with a four by four square lattice. Note that by default no measurements are taken. ","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"In the following pages we will discuss the various components that go into a DQMC simulation.","category":"page"},{"location":"DQMC/Introduction/#Derivation-1","page":"Introduction","title":"Derivation","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"If you are interested in the derivation of DQMC you may check Introduction to Quantum Monte Carlo Simulations for fermionic Systems, the book Quantum Monte Carlo Methods or World-line and Determinantal Quantum Monte Carlo Methods for Spins, Phonons and Electrons. The first reference is most in-line with the implementation of this package.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"If you want to go through the source code, compare it and verify for yourself that it is correct there a couple of things that should be pointed out. Most educational sources use the asymmetric two term Suzuki-Trotter decomposition. We use the symmetric three term version for increased accuracy.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"B(l) = e^-Deltatau sum_l T+V(l) = prod_j e^-Deltatau T2 e^-Deltatau V e^-Deltatau T2 + mathcalO(Deltatau^2)","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"This change is however no trivial as the first or last element of the B matrix/operator needs to be an exponentiated interaction. To get this we use an effective greens function, which cyclically permutes one exponentiation hopping term to the other end of the chain. This adjustment needs to be undone for the actual greens function, which happens in greens().","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"Another thing worth mentioning is that depending on the choices made at the start of the derivation, matrix products may have different order and indices may vary. The first source should have the same definitions.","category":"page"},{"location":"examples/triangular_Hubbard/#Triangular-Attractive-Hubbard-1","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"This example implements the model from the paper Attractive Hubbard model on a triangular lattice. This also serves as a cross-check for the DQMC and a few measurements, such as pairing correlations and occupations. ","category":"page"},{"location":"examples/triangular_Hubbard/#Simulation-1","page":"Triangular Attractive Hubbard","title":"Simulation","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"In the paper simulations were done with 500-1000 sweeps and Deltatau = 0125. The first figure is done with interaction strength U = -4, linear system size L = 4 at beta = 2 5 7 for varying mu. The following simulations should take about 2 minutes.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"using MonteCarlo\n\nbetas = (2.0, 5.0, 7.0)\nmus = vcat(-2.0, -1.5, -1.25:0.05:-1.0, -0.8:0.2:0.8, 0.9:0.05:1.25, 1.5, 2.0)\nlattice = TriangularLattice(4)\ndqmcs = []\n\ncounter = 0\nN = length(mus) * length(betas)\n@time for beta in betas, mu in mus\n    counter += 1\n    print(\"\\r[\", lpad(\"$counter\", 2), \"/$N]\")\n    m = HubbardModelAttractive(l = lattice, t = 1.0, U = 4.0, mu = mu)\n    dqmc = DQMC(\n        m, beta = beta, delta_tau = 0.125, safe_mult = 8, \n        thermalization = 1000, sweeps = 1000, measure_rate = 1,\n        recorder = Discarder\n    )\n    dqmc[:occ] = occupation(dqmc, m)\n    dqmc[:PC] = pairing_correlation(dqmc, m)\n    run!(dqmc, verbose = false)\n\n    # for simplicity we just keep the whole simulation around\n    push!(dqmcs, dqmc)\nend","category":"page"},{"location":"examples/triangular_Hubbard/#Processing-Data-1","page":"Triangular Attractive Hubbard","title":"Processing Data","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"After running all the simulations we need to do a little bit of post-processing on the measured data. ","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"N = length(mus)\noccs = []\nΔoccs = []\npcs = []\nΔpcs = []\n\nfor i in 0:2\n    # Measurements are saved in a LogBinner from BinningAnalysis by default.\n    # Taking the mean (std_error) of a LogBinner will return the Monte Carlo \n    # average (error). Occupation measurements happen per site, so we need \n    # another mean afterwards. \n    _occs = [2 * mean(mean(dqmcs[N*i + j][:occ])) for j in 1:N]\n    doccs = [2 * sqrt(mean(std_error(dqmcs[N*i + j][:occ]).^2)) for j in 1:N]\n    push!(occs, _occs)\n    push!(Δoccs, doccs)\n\n    # pairing correlations are saved in a partially processed state - a 3D matrix\n    # where each index corresponds to vectors between sites\n    # y_{i, j, k} = ∑_x ⟨c_{x, ↑} c_{x+j, ↓} c_{x+i+k, ↓}^† c_{x+i, ↑}^†\n    # The vectors corresponding to the indices i, j, k are returned by \n    # directions(lattice(dqmc)). To compute the pairing correlation of a certain\n    # symmetry, we need to apply the weights corresponding vector indices j, k.\n    # For s-wave symmetry these weights are always (1, 0, ..., 0) (only vector 0).\n    # To match the paper the index i should just be summed over. This is \n    # equivalent to a q=0 Fourier transform.\n    _pcs = [sum(mean(dqmcs[N*i + j][:PC])[:, 1, 1]) for j in 1:N]\n    dpcs = [sqrt(sum(std_error(dqmcs[N*i + j][:PC])[:, 1, 1].^2)) for j in 1:N]\n    push!(pcs, _pcs)\n    push!(Δpcs, dpcs)\nend","category":"page"},{"location":"examples/triangular_Hubbard/#Plotting-1","page":"Triangular Attractive Hubbard","title":"Plotting","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"With the data in a processed form we can now plot it. To make comparison easier, we plot our data directly over figure 1 from our reference.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"using CairoMakie, FileIO, Colors\n\n\nfig = Figure(resolution = (800, 800))\ntop = Axis(fig[1, 1])\nbot = Axis(fig[2, 1])\n\n# References\np = pkgdir(MonteCarlo)\ntop_ref = FileIO.load(joinpath(p, \"docs/src/examples/assets/tri_Hub_ref1_1.png\"))\nbot_ref = FileIO.load(joinpath(p, \"docs/src/examples/assets/tri_Hub_ref1_2.png\"))\nip = image!(top, -2..2, 0..2, top_ref'[:, end:-1:1])\ntranslate!(ip, 0, 0, -1)\nip = image!(bot, -2..2, 0..2.5, bot_ref'[:, end:-1:1], transparency=true)\ntranslate!(ip, 0, 0, -1)\n\nc = HSV(250, 0.6, 1)\nfor (i, (ys, dys)) in enumerate(zip(occs, Δoccs))\n    band!(top, mus, ys .- dys, ys .+ dys, color = (:red, 0.3))\n    lines!(top, mus, ys, color = (c, 0.5), linewidth=2)\n    scatter!(top, mus, ys, color = c, marker = ('■', '□', 'o')[i])\nend\n\naxislegend(top, top.scene.plots[4:3:end], [\"β = 2\", \"β = 5\", \"β = 7\"], position = :rb)\n\nfor (i, (ys, dys)) in enumerate(zip(pcs, Δpcs))\n    band!(bot, mus, ys .- dys, ys .+ dys, color = (:red, 0.3), transparency=true)\n    lines!(bot, mus, ys, color = (c, 0.5), linewidth=2)\n    scatter!(bot, mus, ys, color = c, marker = ('■', '□', 'o')[i])\nend\n\nxlims!(top, -2 , 2)\nylims!(top, 0 , 2)\nxlims!(bot, -2 , 2)\nylims!(bot, 0 , 2.5)\n\nCairoMakie.save(joinpath(p, \"docs/src/examples/assets/fig1_comparison.png\"), fig)","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#Other-runs-1","page":"Triangular Attractive Hubbard","title":"Other runs","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The paper has two more versions of the above plot for system sizes L = 6 and L = 8. These show significantly different results.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"For L = 6 we use mus = vcat(-2.0:0.25:-0.25, -0.1:0.1:1.1, 1.25, 1.5, 2.0) with the same parameters other than that. The simulation should take about 5 minutes.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"For L=8 we use mus = vcat(-2.0:0.5:-0.5, -0.1:0.1:1.1, 1.25, 1.5, 2.0) and betas = (2.0, 5.0, 6.0, 7.0). The resulting simulation takes about 30min.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#Charge-Density-Structure-Factor-1","page":"Triangular Attractive Hubbard","title":"Charge Density Structure Factor","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The paper also investigates the charge density structure factor as a function of reciprocal lattice vectors q. Usually this could be calculated from the charge density correlation measurement in MonteCarlo.jl which measures langle n_i n_j rangle. In this case however the paper to use only part of that measurement.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"To show what measurement we are taking, let us go through the derivation for charge density correlations. We will consider a term with variable spin s. ","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"beginaligned\n\tlangle n_i s n_j s^prime rangle\n\t= langle c_i s^dagger c_i s c_j s^prime^dagger c_j s^prime rangle \n\t= langle c_i s^dagger c_i s rangle langle c_j s^prime^dagger c_j s^prime rangle + langle c_i s^dagger c_j s^prime rangle langle c_i s c_j s^prime^dagger rangle\n\t= (1 - G_ii^ss) (1 - G_jj^s^prime s^prime) + (delta_ij delta_ss^prime - G_ji^s^prime s) G_ij^ss^prime\nendaligned","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"Here we expanded the term into creation and annihilation operators, applied Wicks theorem and finally used G_ij^ss^prime = langle c_i c_j^dagger rangle to express the term with Greens function elements. (We note that expectation values of two creation or two annihilation operators are always zero in DQMC and therefore dropped.) For the attractive Hubbard model, greens function elements with different spins G_ij^ss^prime are zero and G_ij^uparrowuparrow = G_ij^downarrowdownarrow. Thus the full expectation value is given by","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"langle n_i n_j rangle = 4 (1 - G_ii^ss) (1 - G_jj^s^prime s^prime) + 2 (delta_ij delta_ss^prime - G_ji^s^prime s) G_ij^ss^prime","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"This is what is implemented in MonteCarlo.jl. The paper on the other hand seems to only use the second term of this, and double the prefactor. Thus we will need to implement our own measurement. ","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"function my_kernel(::DQMC, ::HubbardModelAttractive, ij::NTuple{2}, G::AbstractArray)\n    i, j = ij\n    4 * (I[j, i] - G[j, i]) * G[i, j]\nend\n\ndqmc[:CDC] = MonteCarlo.Measurement(mc, model, Greens, EachSitePairByDistance, my_kernel)","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"In the above, Greens is a greens function iterator used by the measurement. It yields a equal time greens function to the measurement which is eventually passed as G to the kernel. EachSitePairByDistance defines which lattice indices are passed to the kernel and how they are saved. In this case i and j run through each site index independently and the results are summed such that we have one value per unique distance vector.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"With that measurement we can now compare to the paper. We simulate with L = 6 8, beta = 8, mu = 0 and U = 4, which should take about a minute.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"To match the paper we simulate L = 6 8, beta = 8, mu = 0 and U = -4 with the new measurement. This should take about a minute. After the simulation we compute the fourier transform at various q with","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"qs = vcat(\n    range(Float64[0, 0],   Float64[pi, 0], length=10),\n    range(Float64[pi, 0],  Float64[pi, pi], length=10),\n    range(Float64[pi, pi], Float64[0, 0], length=10),\n)\nys = map(dqmcs) do dqmc\n    MonteCarlo.fourier_transform(\n        qs, directions(MonteCarlo.lattice(dqmc)), mean(dqmc[:CDC])\n    ) |> real\nend","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#Magnetic-Susceptibility-1","page":"Triangular Attractive Hubbard","title":"Magnetic Susceptibility","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The uniform susceptibility featured in figure 7 of the paper can be reproduced more easily. For it we need to run our simulation with a spin_density_susceptibility(dqmc, model, :z) measurement. The result will again be in a partially summed per-distance-vector form. The q=0 Fourier transform follows from simple summation. With L = 6 and betas = [1.0, 2.0, 4.0, 5.0, 6.0, 7.0, 8.0] this simulation should take about a minute.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"legacy/methods/general/#Methods:-General-1","page":"General","title":"Methods: General","text":"","category":"section"},{"location":"legacy/methods/general/#","page":"General","title":"General","text":"Below you find all general exports.","category":"page"},{"location":"legacy/methods/general/#Index-1","page":"General","title":"Index","text":"","category":"section"},{"location":"legacy/methods/general/#","page":"General","title":"General","text":"Pages = [\"general.md\"]","category":"page"},{"location":"legacy/methods/general/#Documentation-1","page":"General","title":"Documentation","text":"","category":"section"},{"location":"legacy/methods/general/#","page":"General","title":"General","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"abstract.jl\"]","category":"page"},{"location":"legacy/methods/general/#Base.length-Tuple{AbstractLattice}","page":"General","title":"Base.length","text":"length(l::AbstractLattice)\n\nNumber of lattice sites.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#Base.size-Tuple{AbstractLattice}","page":"General","title":"Base.size","text":"size(l::AbstractLattice)\n\nReturns the linear system size of a lattice.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.lattice-Tuple{T} where T<:Model","page":"General","title":"MonteCarlo.lattice","text":"lattice(model)\n\nReturns the lattice of a given model.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.neighbors-Tuple{AbstractLattice, Integer}","page":"General","title":"MonteCarlo.neighbors","text":"neighbors(l::AbstractLattice, site_index::Integer)\n\nReturns a list of site indices neighboring the specified site_index.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.neighbors-Tuple{AbstractLattice}","page":"General","title":"MonteCarlo.neighbors","text":"neighbors(l::AbstractLattice[, directed=Val(false)])\n\nReturns an iterator over bonds, given as tuples (source index, target index). If directed = Val(true) bonds are assumed to be directed, i.e. both (1, 2) and (2, 1) are included. If directed = Val(false) bonds are assumed to be undirected, i.e. (1, 2) and (2, 1) are assumed to be equivalent and only one of them will be included.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.parameters-Tuple{Model}","page":"General","title":"MonteCarlo.parameters","text":"parameters(model)\n\nCollects relevant parametrs of a model into a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.reset!-Tuple{MonteCarloFlavor}","page":"General","title":"MonteCarlo.reset!","text":"reset!(mc::MonteCarloFlavor)\n\nResets the Monte Carlo simulation mc. Previously set parameters will be retained.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.run!-Tuple{MonteCarloFlavor}","page":"General","title":"MonteCarlo.run!","text":"run!(mc)\n\nRun the Monte Carlo Simulation.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.AbstractLattice","page":"General","title":"MonteCarlo.AbstractLattice","text":"Abstract definition of a lattice.\n\n\n\n\n\n","category":"type"},{"location":"legacy/methods/general/#MonteCarlo.Model","page":"General","title":"MonteCarlo.Model","text":"Abstract model.\n\n\n\n\n\n","category":"type"},{"location":"legacy/methods/general/#MonteCarlo.MonteCarloFlavor","page":"General","title":"MonteCarlo.MonteCarloFlavor","text":"Abstract definition of a Monte Carlo flavor.\n\n\n\n\n\n","category":"type"},{"location":"legacy/manual/showcase/#Showcase-1","page":"Showcase","title":"Showcase","text":"","category":"section"},{"location":"legacy/manual/showcase/#D-Ising-model-1","page":"Showcase","title":"2D Ising model","text":"","category":"section"},{"location":"legacy/manual/showcase/#","page":"Showcase","title":"Showcase","text":"Results: (Image: )","category":"page"},{"location":"legacy/manual/showcase/#","page":"Showcase","title":"Showcase","text":"Code:","category":"page"},{"location":"legacy/manual/showcase/#","page":"Showcase","title":"Showcase","text":"using MonteCarlo, Distributions, PyPlot, DataFrames, JLD\n\nTdist = Normal(MonteCarlo.IsingTc, .64)\nn_Ts = 2^8\nTs = sort!(rand(Tdist, n_Ts))\nTs = Ts[Ts.>=1.2]\nTs = Ts[Ts.<=3.8]\ntherm = 10^4\nsweeps = 10^3\n\ndf = DataFrame(L=Int[], T=Float64[], M=Float64[], χ=Float64[], E=Float64[], C_V=Float64[])\n\nfor L in 2 .^ [3, 4, 5, 6]\n\tprintln(\"L = \", L)\n\tfor (i, T) in enumerate(Ts)\n\t\tprintln(\"\\t T = \", T)\n\t\tbeta = 1/T\n\t\tmodel = IsingModel(dims=2, L=L)\n\t\tmc = MC(model, beta=beta)\n\t\trun!(mc, sweeps=sweeps, thermalization=therm, verbose=false)\n\t\tpush!(df, [L, T, mean(mc.obs[\"m\"]), mean(mc.obs[\"χ\"]), mean(mc.obs[\"e\"]), mean(mc.obs[\"C\"])])\n\tend\n\tflush(stdout)\nend\n\nsort!(df, [:L, :T])\n@save \"ising2d.jld\" df\n\n# plot results together\ngrps = groupby(df, :L)\nfig, ax = subplots(2,2, figsize=(12,8))\nfor g in grps\n\tL = g[:L][1]\n\tax[1].plot(g[:T], g[:E], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[2].plot(g[:T], g[:C_V], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[3].plot(g[:T], g[:M], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[4].plot(g[:T], g[:χ], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\nend\nax[1].legend(loc=\"best\")\nax[1].set_ylabel(\"Energy\")\nax[1].set_xlabel(\"Temperature\")\n\nax[2].set_ylabel(\"Specific heat\")\nax[2].set_xlabel(\"Temperature\")\nax[2].axvline(x=MonteCarlo.IsingTc, color=\"black\", linestyle=\"dashed\", label=\"\\$ T_c \\$\")\nax[2].legend(loc=\"best\")\n\nax[3].set_ylabel(\"Magnetization\")\nax[3].set_xlabel(\"Temperature\")\nx = range(1.2, stop=MonteCarlo.IsingTc, length=100)\ny = (1 .- sinh.(2.0 ./ (x)).^(-4)).^(1/8)\nax[3].plot(x,y, \"k--\", label=\"exact\")\nax[3].plot(range(MonteCarlo.IsingTc, stop=3.8, length=100), zeros(100), \"k--\")\nax[3].legend(loc=\"best\")\n\nax[4].set_ylabel(\"Susceptibility χ\")\nax[4].set_xlabel(\"Temperature\")\nax[4].axvline(x=MonteCarlo.IsingTc, color=\"black\", linestyle=\"dashed\", label=\"\\$ T_c \\$\")\nax[4].legend(loc=\"best\")\ntight_layout()\nsavefig(\"ising2d.pdf\")","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is a package implementing classical and quantum Monte Carlo simulations primarily for solid state physics. Currently the focus is on finding a overall design for the package and verifying that determinant Quantum Monte Carlo (DQMC) is working correctly. As such the package may still go through significant changes and the documentation may be outdated and incomplete.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Note that classical Monte Carlo is also not a focus at this point. It is probably usable, but a lot of the adjustments made to DQMC have not been added to classical Monte Carlo, or have been added without thorough testing.","category":"page"},{"location":"DQMC/recorder/#Configuration-Recorder-1","page":"Configuration Recorder","title":"Configuration Recorder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"Sometimes it's useful to keep configurations around, for example to perform new measurements after the original simulation has finished. This is especially true in the case of DQMC where simulations can take weeks to run, but measurement on their own are relatively fast. We currently offer two objects for this purpose - Discarder and ConfigRecorder.","category":"page"},{"location":"DQMC/recorder/#General-Interface-1","page":"Configuration Recorder","title":"General Interface","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"Any AbstractRecorder follows an array-like interface. Configurations are added via push!(recorder, mc, model, sweep) and can be retrieved via getindex. The recorder has a length and implements isempty. Furthermore it can be iterated, saved and loaded.","category":"page"},{"location":"DQMC/recorder/#Discarder-1","page":"Configuration Recorder","title":"Discarder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"As the name suggests this recorder simply discards all configurations. It is used by default for classical Monte-Carlo simulations.","category":"page"},{"location":"DQMC/recorder/#ConfigRecorder-1","page":"Configuration Recorder","title":"ConfigRecorder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"This recorder keeps track of compressed configurations in memory. On creation a rate can be specified as the last argument in the constructor to reduce the amount of configurations saved. Compression relies on overloads of compress(mc, model, conf) and decompress(mc, model, conf). For the available Hubbard models these simply transform from and to BitArray.","category":"page"}]
}
