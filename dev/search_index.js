var documenterSearchIndex = {"docs":
[{"location":"devdocs/FileIO/#FileIO-1","page":"FileIO","title":"FileIO","text":"","category":"section"},{"location":"devdocs/FileIO/#","page":"FileIO","title":"FileIO","text":"MonteCarlo.jl uses JLD2 for FileIO. While it is possible to save structs directly with JLD2, it becomes difficult to load when the struct has changed. Therefore MonteCarlo.jl implements a custom _save and _load function for most structs. In general these functions are implemented as","category":"page"},{"location":"devdocs/FileIO/#","page":"FileIO","title":"FileIO","text":"function _save(file::FileLike, key::String, object)\n    write(file, \"$key/VERSION\", some_int)\n    write(file, \"$key/tag\", \"some identifiying name\")\n    # write data ...\nend\n\nfunction _load(data::FileData, ::Val{:some_tag})\n    # maybe check data[\"VERSION\"]\n    # load file from data\nend","category":"page"},{"location":"devdocs/FileIO/#","page":"FileIO","title":"FileIO","text":"where FileData is a wrapper around Dict{String, Any}, which allows accessing the dictionary returned by JLD2.load as if it were a nested dictionary. I.e. rather than data[\"key1/key2/key3\"] you can use data[\"key1\"][\"key2\"][\"key3\"] with it, which aligns better to the way data is saved and loaded. FileLike is a Union{JLD2.JLDFile, JLD2.Group, FileData}. The \"tag\" saved in each _save function is used to identify what is saved, and it later used for dispatch in _load.","category":"page"},{"location":"devdocs/FileIO/#","page":"FileIO","title":"FileIO","text":"The entrypoint for saving is the save function \"src/FileIO.jl\". The function includes functionality to rename a file to avoid overwriting an existing and includes compression. It also writes some GIT information which is printed in load if the load fails.","category":"page"},{"location":"legacy/interfaces/MC/#Interface:-Monte-Carlo-(MC)-1","page":"MC","title":"Interface: Monte Carlo (MC)","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"Any model that wants to be simulated by means of MC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the Monte Carlo flavor Monte Carlo (MC).","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"Example models: Ising Model","category":"page"},{"location":"legacy/interfaces/MC/#Mandatory-fields-1","page":"MC","title":"Mandatory fields","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"l::Lattice: any Lattice","category":"page"},{"location":"legacy/interfaces/MC/#Index-of-all-methods-1","page":"MC","title":"Index of all methods","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"Pages = [\"MC.md\"]","category":"page"},{"location":"legacy/interfaces/MC/#Mandatory-methods-1","page":"MC","title":"Mandatory methods","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"CurrentModule = MonteCarlo","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"conftype(::Type{MC}, m::Model)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"energy(mc::MC, m::Model, conf)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"rand(::MC, ::Model)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"propose_local(mc::MC, m::Model, i::Int, conf, E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#MonteCarlo.propose_local-Tuple{MC, Model, Int64, Any, Float64}","page":"MC","title":"MonteCarlo.propose_local","text":"propose_local(mc::DQMC, m::Model, field::AbstractField, i::Int, slice::Int)\n\nPropose a local move for lattice site i at time slice slice for a field  holding the current configuration. Returns the Green's function determinant  ratio, the boson energy difference ΔE_boson = E_boson_new - E_boson, and any extra information passthrough that might be useful in accept_local.\n\nBy default this function will call propose_local(mc, field, i, slice).\n\nSee also accept_local!.\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"accept_local!(mc::MC, m::Model, i::Int, conf, E::Float64, delta_i, delta_E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#Optional-methods-1","page":"MC","title":"Optional methods","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"global_move(mc::MC, m::Model, conf, E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"prepare_observables(mc::MC, m::Model)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"measure_observables!(mc::MC, m::Model, obs::Dict{String,Observable}, conf, E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"finish_observables!(mc::MC, m::Model, obs::Dict{String,Observable})","category":"page"},{"location":"legacy/models/hubbardattractive/#Attractive-Hubbard-Model-1","page":"Attractive Hubbard model","title":"Attractive Hubbard Model","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#Hamiltonian-1","page":"Attractive Hubbard model","title":"Hamiltonian","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The Hamiltonian of the attractive (negative U) Hubbard model reads","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} \\mathcal{H} = -t \\sum{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger{i\\sigma} c{j\\sigma} + \\text{h.c.} \\right) - |U| \\sumj \\left( n{j\\uparrow} - \\frac{1}{2} \\right) \\left( n{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sumj n{j}, \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"where sigma denotes spin, t is the hopping amplitude, U the on-site repulsive interaction strength, mu the chemical potential and langle i j rangle indicates that the sum has to be taken over nearest neighbors. Note that (1) is written in particle-hole symmetric form such that mu = 0 corresponds to half-filling.","category":"page"},{"location":"legacy/models/hubbardattractive/#Constructor-1","page":"Attractive Hubbard model","title":"Constructor","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"You can create an attractive Hubbard model instance as follows,","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"model = HubbardModelAttractive(dims=1, L=8)","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The following parameters can be set via keyword arguments:","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"dims::Int: dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)\nL::Int: linear system size\nt::Float64 = 1.0: hopping energy\nU::Float64 = 1.0: onsite interaction strength, \"Hubbard U\"\nmu::Float64 = 0.0: chemical potential","category":"page"},{"location":"legacy/models/hubbardattractive/#Supported-Monte-Carlo-flavors-1","page":"Attractive Hubbard model","title":"Supported Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Determinant Quantum Monte Carlo (DQMC), see details below","category":"page"},{"location":"legacy/models/hubbardattractive/#DQMC-formulation-1","page":"Attractive Hubbard model","title":"DQMC formulation","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"We decouple the onsite electron-electron interaction by performing a Hirsch transformation, i.e. a discrete Hubbard-Stratonovich transformation in the density/charge channel,","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} e^{|U|\\Delta \\tau \\left( n{i\\uparrow} - \\frac{1}{2} \\right) \\left(n{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum{s=\\pm 1} \\prod{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The interaction matrix of the model then reads","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} V{ij}(l) &= \\delta{ij} Vi(l), \\\\\nVi(l) &= - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"For completeness, the hopping matrix is \\begin{align} T_{ij} &= \\begin{cases} -t & \\text{if i and j are nearest neighbors,} \\\\\n-\\mu & \\text{if i == j,} \\\\\n0 & \\text{otherwise.} \\end{cases} \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"As neither T nor V depend on spin, neither does the equal-times Green's function. We can therefore restrict our computations to one spin flavor (flv=1) and benefit from operating with smaller matrices.","category":"page"},{"location":"legacy/models/hubbardattractive/#Potential-extensions-1","page":"Attractive Hubbard model","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Arbitrary lattices (so far only cubic lattices supported)","category":"page"},{"location":"devdocs/dqmc_stacks/#DQMC-Stacks-1","page":"DQMC Stacks","title":"DQMC Stacks","text":"","category":"section"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"There are currently two \"stacks\" associated with DQMC which mostly hold matrices for the calculations involved. The first one is DQMCStack (in \"DQMC/stack.jl\") which is responsible for the main simulation and the latter is UnequalTimeStack (in \"DQMC/unequal_time_stack.jl\") which is responsible for time displaced greens functions.","category":"page"},{"location":"devdocs/dqmc_stacks/#DQMCStack-1","page":"DQMC Stacks","title":"DQMCStack","text":"","category":"section"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"The DQMCStack struct contains:","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"the field_cache which includes a set of temporary variables used in local updates (see fields devdocs)\nu_stack, d_stack and t_stack which hold on to a set of UDT decomposed matrices necessary to compute the next Greens function in imaginary time\na bunch of matrices and vectors which are used as short to mid term temporary buffers\ngreens which contains the current effective greens function (there is further computation needed to get to the correct greens function for measurements, see \"DQMC/greens.jl\")\ninfortmation about the current time slice, the total number, safe_mult blocks, etc\na buffer for the exponentiated interaction matrix\nconstant buffers for different forms of the exponentiated hopping matrix ","category":"page"},{"location":"devdocs/dqmc_stacks/#Matrix-product-chain-1","page":"DQMC Stacks","title":"Matrix product chain","text":"","category":"section"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"To calculate the (equal time) Greens function at some time slice l we need to calculate ","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"G(l) = 1 + B(l-1) B(l-2) cdots B(1) B(M) cdots B(l)^-1","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"where B(l) = e^-Deltatau H(l) are propagation matrices. Specifically we will need two matrix product chains here, B(l-1) cdots B(1) and B(M) cdots B(l). When the simulation runs, we alternative between going from l = 1 to l = M and back. Let us consider the former case for an example. We will need:","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"I and B(M) cdots B(1) at l = 1\nB(1) and B(M) cdots B(2) at l = 2\nB(k-1) cdots B(1) and B(M) cdots B(k) at l = k\nB(M-1) cdots B(1) and B(M) at l = M","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"Thus at the start we will want a full product chain for the right term and an empty chain i.e. an identity for the left side. In every step we multiply a propagation matrix to the left on the left chain and its inverse to right side of the right chain. The opposite direction then simply does the reverse of this. ","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"One way to deal with this calculation is to store matrices for each step in a big array, and then update parts of the array as you move from one time to another. Matching the list above we would have","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"I B(M) cdots B(1) B(M) cdots B(2) dots B(M) at l = 1\nI B(1) B(M) cdots B(2) dots B(M) at l = 2\nI dots B(k-1) cdots B(1) B(M) cdots B(k) dots B(M) at l = k\nI dots B(M-1) cdots B(1) B(M) at l = M","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"which contains the necessary matrices at each step. Going backwards in time would rebuild this vector, so only need to fully populate it once. We can also cut a few values: The identity at the start is unnecessary and we can have the new value from the left chain overwrite it's partner from the right. This is effectively what u_stack, d_stack and t_stack contain before considering float precision problems and optimizations.","category":"page"},{"location":"devdocs/dqmc_stacks/#Float-Precision-1","page":"DQMC Stacks","title":"Float Precision","text":"","category":"section"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"Let us start with float precision errors as they are relevant to most of the other details. Before going into solving the problem we will briefly explain how float precision errors occur. A floating point number is effecitvely a number represented in scientific notation with a certain number of digits for the significand and exponent. Consider for example 3 digits for the significant, e.g. 123 cdot 10^0 and 987 cdot 10^-6. These numbers can be multiplied and divided by each other without issues, however adding or subtracting one from the other will lead to the information stores in the second number to be erased, as it cannot be stored in the three digits available in the first. If further calculations cancel out the 123 cdot 10^0 we will no longer have the information from 987 cdot 10^-6 available, resulting in a significantly wrong result. ","category":"page"},{"location":"devdocs/dqmc_stacks/#UDT-Decomposition-1","page":"DQMC Stacks","title":"UDT Decomposition","text":"","category":"section"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"(Chains of) Matrix multiplications, which are packed with additions, suffer from such floating point precision errors especially when their eigenvalues are spread across a large range of values. This is the case in DQMC. To avoid precision errors, we need to keep the spread of eigenvalues small in consecutive matrix multiplications. Various matrix decomposition can achieve this to varying degrees, see StableDQMC.jl for details. In MonteCarlo.jl we use introduced a UDT decomposition, which is simply a QR decompoisition where the unitary matrix U = Q and the R matrix is further split into a Diagonal D matrix and the remaining upper triangular T matrix.","category":"page"},{"location":"devdocs/dqmc_stacks/#add_slice_matrix_left!-1","page":"DQMC Stacks","title":"add_slice_matrix_left!","text":"","category":"section"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"Let's get back to our product chain of propagators. The product of two such matrices will not immediately be critical in terms of float precision. Instead there is some empiral number of multiplications safe_mult which is fine to do. Thus we perform a stabilization step every safe_mult multiplications. The stabilization step looks roughly like this for increasing time:","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"# builds up error, stops before it gets too much\ncur_U = B[n+safe_mult] * ... * B[n+1] * prev_U \n# Diagonal multiplication involves no addition - no extra error\ntemp = cur_U * prev_D \n# Increases error, but on the scale we still consider fine\ncur_U, cur_D, temp = UDT(temp)\n# low error\ncur_T = temp * prev_T","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"This happens in add_slice_sequence_left. Since we have U, D and T matrices here that need to be kept track of the vector of propagation matrices we introduced earlier now becomes three vectors of U, D and T matrices respectively. For the reverse direction we effectively do the same, however we use adjoint matrices. The reason for this follows from the computation of the Greens matrix, so let us look at that next. ","category":"page"},{"location":"devdocs/dqmc_stacks/#calculate_greens-1","page":"DQMC Stacks","title":"calculate_greens","text":"","category":"section"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"To compute the Greens matrix we also need to be careful about float precision. Inversion specifically can be quite sensetive to such errors. After UDT decompositions we have unitary matrices, which can be inverted exactly by taking the adjoint, Diagonal matrices which can be inverted exactly by inverting each element, triangular matrices which may produce errors and normal matrices which may also produce errors. To make a stable inversion happen we use U_l D_l T_l = B(l-1) B(l-2) cdots B(1) and U_r D_r Tr =  B^dagger(l) cdots B^dagger(M) which results in","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"G(l) = 1 + U_l D_l T_l T_r^dagger D_r U_r^dagger^-1","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"Here we can combine the left and right scales without introducing significant errors by calculating X = D_l (T_l T_r^dagger) D_r and decompose it into a single scale matrix U D T = X. After this we have","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"G(l) = 1 + U_l U D T U_r^dagger^-1","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"we can now pull all the scale-free matrices out of the inverse.","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"G(l) = U_r T^-1 U^dagger U_l^dagger U_r T^-1 + D^-1 U^dagger U_l^dagger","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"This leaves the scale-full diagonal matrix isolated on the right and a product of scale-free matrices on the left. We now calculate all the matrix products to get to L X + D^-1 R where L and X are generic matrices, D is diagonal and R is unitary. At this point we have nothing left to do but calculate X + D, which involves some amount of error. We however do not invert yet, but do another UDT decomposition to get to","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"G(l) = L u d t^-1 R = L t^-1 d^-1 u^dagger R","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"which resolves without further complications. This is what calculate_greens does, obscured behind variable reuse. ","category":"page"},{"location":"devdocs/dqmc_stacks/#Optimizing-stack-sizes-1","page":"DQMC Stacks","title":"Optimizing stack sizes","text":"","category":"section"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"Let us step away from floating point precision for a bit and look back at our matrix product chain. We now have 3 vectors of matrices u_stack, d_stack and t_stack containing a somewhat unclear amount of matrices. In the worst/naive case, we have one matrix per time slice, which is quite a lot. We can reduce the amount of matrices we need to store by using another formula for updating greens matrices","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"G(l+1) = B(l) G(l) B^-1(l)","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"which follows A^-1 B^-1 = (BA)^-1. This is implemented in MonteCarlo.jl as wrap_greens!. Much like our matrix product chain this too will build up a significant amount of float precision error over time, which means that we can only use it for so many steps before we need to stabilize.","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"The way MonteCarlo.jl handles the different formulas for updating the greens function is as follows:","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"At l = 1 (l = M) the greens function is calculated from the product chain. At this point the product chain contains a fresh UDT decomposition.\nFor the next safe_mult time steps, wrap_greens is used to calculate the corresponding greens function. This avoids using the rather involved inversion which is part of the other method.\nAfter safe_mult steps the product chains update, writing one new set of UDT decomposed matrices to the relevant vectors. These are then used to recompute the Greens function at l = 1 + safe_mult. (There are no U, D and T matrices saved for l = 2 to l = safe_mult.)","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"This process then repeats until we reach l = M (l = 1). During the stabilization step (last in the list) we also compared the result from one extra wrap_greens with the stabilized greens function to make sure float precision errors aren't getting out of hand. These errors are referred to as propagation errors. All of this happens in propagate.","category":"page"},{"location":"devdocs/dqmc_stacks/#Propagation-Matrix-1","page":"DQMC Stacks","title":"Propagation Matrix","text":"","category":"section"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"One more thing we have yet to properly define are the propagation matrices B(l) = e^-Deltatau H(l). Their exact form depends on the Trotter decomposition and the way local updates are implemented. In MonteCarlo.jl local updates assume the right most matrix in the matrix product chain to be an exponentiated interaction matrix. I.e. for an asymmetric Trotter decomposition we would have","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"G(l) = 1 + e^-Deltatau T e^-Deltatau V(l-1) cdots e^-Deltatau T e^-Deltatau V(1) e^-Deltatau T e^-Deltatau V(M) cdots e^-Deltatau T e^-Deltatau V(l)^-1","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"We can (and do) however use the more precise symmetric Trotter decomposition B(l) = e^-05Deltatau T e^-Deltatau V(l) cdots e^-05Deltatau T. For this we use the same trick used in wrap_greens which allows us to rewrite the Greens function as","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"G(l) = e^05Deltatau T 1 + e^-05Deltatau T e^-05Deltatau T e^-Deltatau V(l-1) cdots e^-05Deltatau T e^-05Deltatau T e^-Deltatau V(1) e^-05Deltatau T e^-05Deltatau T e^-Deltatau V(M) cdots e^-05Deltatau T e^-05Deltatau T e^-Deltatau V(l)^-1 e^-05Deltatau T","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"where we consider the inverse [...]^{-1} as the effective Greens function saved as greens in the DQMCStacj and whole expression, i.e. G(l) as the true greens function.","category":"page"},{"location":"devdocs/dqmc_stacks/#Further-Details-Caveats-1","page":"DQMC Stacks","title":"Further Details Caveats","text":"","category":"section"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"We are now done discussing the main aspects of the DQMCStack. There are however some more details that might be worth mentioning:","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"We do not actually adhere to safe_mult tightly, as that would reduce the already low number of temperatures we can consider for a given Deltatau in a certain temperature range. Instead we generate ranges which contain le mathrmsafe_mult time slices to identify safe matrix multiplications. When stepping from one range to the next we stabilize.\nWe do not actually use e^-05Deltatau T e^-05Deltatau T in the calculations. The formula is equivalent to e^{-\\Delta\\tau T}, which is precomputed as hopping_matrix_exp_squared.\nGlobal updates assume to happen when the stack is at time slice 1, going up. They further assume that calculate_greens has just happened. Adjusting how the stack is initialized is therefore likely to break global updates.","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"","category":"page"},{"location":"devdocs/dqmc_stacks/#Unequal-Time-Stack-1","page":"DQMC Stacks","title":"Unequal Time Stack","text":"","category":"section"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"The unequal time stack is more of the same, though more complicated and error prone. The time displaced Greens function is given by","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"G(k l) = B(l+1)^-1 B(l+2)^-1 cdots B(k)^-1 + B(l) cdots B(1) B(M) cdots B(k+1)^-1","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"if k ge l or","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"G(k l) = B(l) B(l-1) cdots B(k+1) + (B(k) cdots B(1) B(M) cdots B(l+1))^-1^-1","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"if k le l. To calculate these, three propagator stacks are introduced in UnequalTimeStack:","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"the forward stack, which calculates B(n cdot mathrmsafe_mult) cdots B(1)\nthe backward stack, which calculates B^dagger(n cdot mathrmsafe_mult) cdots B^dagger(M)\nthe inverse stack, which calculates small blocks of B^-1(n cdot mathrmsafe_mult + 1) cdots B^-1((n+1) cdot mathrmsafe_mult)","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"Their calculation is very similar to the DQMCStack. Time displaced Greens function are usually used in measurements to calculate susceptibilities, which requires G(0, l) and G(l, 0) which in turn require values from a wider range of positions in the forward, backward and inverse stack. Thus we use multiple stacks here, rather than having them overwrite entries in one stack like for DQMCStack. Filling these stacks is handled by the lazy_build_<forward/backward/inverse>! functions, which only compute as much as is requested.","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"To then compute the relevant Greens function, calculate_greens_full is called. In the first step the compute_<forward/backward/inverse>_udt_block! functions are called to get the specific UDT decomposed matrix product chains. Then another stabilized inversion like calculate_greens from DQMCStack is called. There is another quirk here however, which is that the scale-full diagonal matrices are split into parts smaller and larger than unit scale. This further boosts precision/stability which is necessary here.","category":"page"},{"location":"devdocs/dqmc_stacks/#","page":"DQMC Stacks","title":"DQMC Stacks","text":"Note that the time displaced greens functions used for susceptibilities in measurements don't directly call the methods here. Instead they go through CombinedGreensIterator, which essentially implements wrap_greens and only refers back to UnequalTimeStack every so often to get a stabilized result. You can find the iterator in \"DQMC/measurements/greens_iterators.jl\".","category":"page"},{"location":"DQMC/dqmc/#DQMC-1","page":"DQMC","title":"DQMC","text":"","category":"section"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"The DQMC struct represents both the determinant quantum monte carlo algorithm and the simulation as a whole. Because of that it includes a bunch of options that aren't directly relevant to the algorithm. The minimal default is given by dqmc = DQMC(model, beta=beta) and the simulation can then be started with run!(dqmc). Additional keyword arguments include:","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"beta: The inverse temperature of the simulation.\ndelta_tau = 0.1: The imaginary time discretization.\nslices = beta / delta_tau: The number of imaginary time slices.\nsafe_mult = 10: The number of save matrix multiplications.\nthermalization = 100: The number of thermalization sweeps.\nsweeps = 100: The number of measurement sweeps.\ncheck_sign_problem = true: Enables or disables checks for sign problems. (negative or imaginary probabilities)\ncheck_propagation_error = true: Enables or disables checks for time slices propagation errors. (Which may happen if safemult or deltatau is too large.)\nsilent = false: Enable or disable prints for the checks above.\nmeasure_rate = 10: Sets the frequency of measurements. Every measure_rate sweeps a new measurement is taken.\nprint_rate = 10: Sets the frequency of general information prints (not checks).\nseed = -1: Sets a random seed for the simulation. If set to -1 the seed will be chosen randomly.\nlast_sweep = 0: Sets the last finished sweep. Used internally for continued simulations.","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"Beyond this there are a couple of keyword arguments which are more involved and will be discussed in other chapters. These include","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"scheduler = SimpleScheduler(LocalSweep()): This sets up the sequence of updates performed by the simulation.\nmeasurements = Dict{Symbol, AbstractMeasurement}(): A collection of named measurements that run during the simulation. These are usually added after creating the simulation.\nthermalization_measurements = Dict{Symbol, AbstractMeasurement}(): Same as the above, but the measurements run during the thermalization stage. Might be useful to judge convergence or the number of necessary sweeps.\nrecorder = ConfigRecorder: A recorder for the configurations generated during the simulation.\nrecording_rate = measure_rate: The rate at which configurations are recorded.\nfield::Type = choose_field(model): The type of the field used by the simulation","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"Running a simulation also comes with a bunch of options via keyword arguments - most dealing with saving the simulation. The options for run(dqmc) include:","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"verbose = true: Enables or disables information printing during the runtime.\nignore = tuple(): Measurement keys to ignore during this run (none by default).\nsafe_before::TimeType = now() + Year(100): Sets a time stamp before which the simulation will cancel itself and save.\nsafe_every::TimePeriod = Hour(10000): Sets a time period interval for regular saves.\ngrace_period::TimePeriod = Minute(5): Sets a buffer time period for saving. By default saves at least 5 minutes before the requested time.\nresumable_filename = \"resumable_$datestring.jld2: Sets the name the savefile generated from safebefore and safeevery.\noverwrite = true: Enables or disables overwriting of existing files. \nmin_update_rate = 0.001: Sets a minimum update acceptance rate under which a simulation is considered \"failed\". This will only trigger after 1 / min_update_rate sweeps and only if all updates fall below this rate.\nfail_filename = \"failed_$datestring.jld2\": Sets the filename of a failed simulation.","category":"page"},{"location":"legacy/manual/gettingstarted/#Getting-Started-1","page":"Getting started","title":"Getting Started","text":"","category":"section"},{"location":"legacy/manual/gettingstarted/#Installation-1","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"MonteCarlo.jl hasn't yet been released. To clone the package execute the following command in the Julia REPL:","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"Pkg.clone(\"https://github.com/crstnbr/MonteCarloObservable.jl\")\nPkg.clone(\"https://github.com/crstnbr/MonteCarlo.jl\")","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"To update to the latest version of the package just do Pkg.update() or specifically Pkg.update(\"MonteCarlo\").","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"warning: Warning\nThe package is still in pre-alpha phase and shouldn't yet be used for production runs.","category":"page"},{"location":"legacy/manual/gettingstarted/#Usage-1","page":"Getting started","title":"Usage","text":"","category":"section"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"This is a simple demontration of how to perform a Monte Carlo simulation of the 2D Ising model:","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"# load packages\nusing MonteCarlo\n\n# load your model\nm = IsingModel(dims=2, L=8);\n\n# choose a Monte Carlo flavor and run the simulation\nmc = MC(m, beta=0.35);\nrun!(mc, sweeps=1000, thermalization=1000, verbose=false);\n\n# analyze results\nobservables(mc) # what observables do exist for that simulation?\nm = mc.obs[\"m\"] # magnetization\nmean(m)\nstd(m) # one-sigma error\n\n# create standard plots\nhist(m)\nplot(m)","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"legacy/flavors/dqmc/#Determinant-Quantum-Monte-Carlo-(DQMC)-1","page":"DQMC","title":"Determinant Quantum Monte Carlo (DQMC)","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"This is determinant quantum Monte Carlo (MC) also known auxiliary field quantum Monte Carlo. It can be used to simulate interacting fermion systems, here the auxiliary boson arises from a Hubbard Stratonovich transformation, or fermions which are naturally coupled to bosons. An example is the Attractive Hubbard Model.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"You can initialize a determinant quantum Monte Carlo simulation of a given model simply through","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"dqmc = DQMC(model, beta=5.0)","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Mandatory keywords are:","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"beta: inverse temperature","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Allowed keywords are:","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"delta_tau::Float64 = 0.1: imaginary time step size\nsafe_mult::Int = 10: stabilize Green's function calculations every safe_mult step (How many slice matrices can be multiplied until singular value information is lost due to numerical unaccuracy?)\ncheckerboard::Float64 = false: use Checkerboard decomposition (faster)\nsweeps: number of measurement sweeps\nthermalization: number of thermalization (warmup) sweeps\nseed: initialize DQMC with custom seed\nall_checks::Bool = true: turn off to suppress some numerical checks","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Afterwards, you can run the simulation by","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"run!(dqmc)","category":"page"},{"location":"legacy/flavors/dqmc/#Technical-details-1","page":"DQMC","title":"Technical details","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#Symmetric-Suzuki-Trotter-decomposition-1","page":"DQMC","title":"Symmetric Suzuki-Trotter decomposition","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"We use the symmetric version of the Suzuki-Trotter decomposition, i.e.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"\\begin{align} e^{-\\Delta\\tau \\suml T+V(l)} = \\prodj e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"where T is the hopping matrix and V(l) is the interaction matrix with l an imaginary time slice index indicating an auxiliary field dependence.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"With the imaginary time slice matrices B_l = e^-Deltatau T2 e^-Deltatau V(l) e^-Deltatau T2 the equal-time Green's function is G = left( 1 + B_M cdots B_1 right)^-1.","category":"page"},{"location":"legacy/flavors/dqmc/#Checkerboard-decomposition-1","page":"DQMC","title":"Checkerboard decomposition","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"We provide a general algorithm to construct the \"checkerboard\" split up of a generic AbstractLattice. The only requirement is that the AbstractLattice has the following two fields,","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"n_bonds::Int: total number of bonds (lattice graph edges)\nbonds::Matrix{Int}: bond matrix of shape (n_bonds, 3). Rows correspond to bonds and columns indicate source site, target site, and bond type in this order.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Of course, one can also manually construct a (more efficient) checkerboard split up by overloading the following function for the specific AbstractLattice subtype.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"MonteCarlo.build_checkerboard(l::MonteCarlo.AbstractLattice)","category":"page"},{"location":"legacy/flavors/dqmc/#MonteCarlo.build_checkerboard-Tuple{AbstractLattice}","page":"DQMC","title":"MonteCarlo.build_checkerboard","text":"build_checkerboard(l::Lattice)\n\nGenerates a collection of groups containing (src, trg) pairs where each group  only touches each site (src or trg) once. Each group also represents only one  bond direction, though multiple groups can represent the same direction. Bond  reversals (i.e. trg -> src relative to src -> trg) are not considered here, as  they are always present.\n\nReturns groups in a nested structure groups[idx1][idx2][idx3], where idx1 picks the bond direction, idx2 a subset with non-overlapping sites and idx3 the individual site pairs involved in a bond.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#Effective-slice-matrices-and-Green's-function-1","page":"DQMC","title":"Effective slice matrices and Green's function","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Combining the symmetric Suzuki-Trotter and checkerboard decomposition we can write (assuming two checkerboard groups a and b)","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"\\begin{align} e^{-\\Delta\\tau \\suml T+V(l)} &= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} \\\\\n&\\times \\left( \\prodj e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"For performance resons we internally work with effective imaginary time slice matrices","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"B_l^texteff = e^-Deltatau T_b2 e^-Deltatau T_a e^-Deltatau T_b2 e^-Deltatau V","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"instead of the original B_ls above.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"warning: Warning\nNote that one consequence is that the field dqmc.s.greens isn't the actual Green's function but an effective one defined by \\begin{align} G &= \\left( 1 + BM \\cdots B1 \\right)^{-1} \\\\\n&= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} \\left( 1 + B^{\\text{eff}}M \\cdots B^{\\text{eff}}1 \\right)^{-1} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta/2} \\\\\n&= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} G^{\\text{eff}} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta/2} \\end{align}To obtain the actual equal-times Green's function, for example for measuring, use greens(dqmc::DQMC). Note that although Goverset=G^texteff} one can readily show that det G = det G^texteff holds and the Metropolis acceptance is not affected by switching to the effective matrices.","category":"page"},{"location":"legacy/flavors/dqmc/#Exports-1","page":"DQMC","title":"Exports","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"DQMC.jl\"]","category":"page"},{"location":"legacy/flavors/dqmc/#MonteCarlo.replay!","page":"DQMC","title":"MonteCarlo.replay!","text":"replay(mc::DQMC[; configurations::Iterable = mc.recorder; kwargs...])\n\nReplays previously generated configurations and measures observables along the way.\n\nKeyword Arguments (both):\n\nverbose = true: If true, print progress messaged to stdout.\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, replay! will generate a\n\nresumable save file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nfilename: Name of the save file. The default is based on safe_before.\nstart=1: The first sweep in the simulation. This will be changed when using\n\nresume!(save_file).\n\nignore: A collection of measurement keys to ignore. Defaults to the key of\n\nthe configuration measurement.\n\nmeasure_rate = 1: Rate at which measurements are taken. Note that this is \n\nbased on the recorded configurations, not actual sweeps.\n\n\n\n\n\n","category":"function"},{"location":"legacy/flavors/dqmc/#MonteCarlo.run!-Tuple{DQMC}","page":"DQMC","title":"MonteCarlo.run!","text":"run!(mc::DQMC[; kwargs...])\n\nRuns the given Monte Carlo simulation mc. Returns SUCCESS::ExitCode = 0 if  the simulation finished normally or various other codes if failed or cancelled.  See ExitCode.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nthermalization: Number of thermalization sweeps. Uses the value passed to\n\nDQMC by default.\n\nsweeps: Number of measurement sweeps. Uses the value passed to DQMC by\n\ndefault.\n\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, run! will generate a resumable\n\nsave file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nresumable_filename: Name of the resumable save file. The default is based on\n\nsafe_before.\n\noverwrite = false: If set to true a file with the same name as\n\nresumable_filename will be overwritten. (This will create a temporary backup)\n\nSee also: resume!\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#MonteCarlo.DQMC-Tuple{Model, Dict{Symbol, V} where V}","page":"DQMC","title":"MonteCarlo.DQMC","text":"DQMC(m::M, params::Dict)\nDQMC(m::M, params::NamedTuple)\n\nCreate a determinant quantum Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#MonteCarlo.DQMC-Tuple{M} where M<:Model","page":"DQMC","title":"MonteCarlo.DQMC","text":"DQMC(m::M; kwargs...) where M<:Model\n\nCreate a determinant quantum Monte Carlo simulation for model m with keyword parameters kwargs.\n\nKeyword Arguments:\n\nseed: The random seed used by the simulation.\ncheckerboard=false: If true, the simulation uses a generic checkerboard\n\ndecomposition.\n\nthermalization_measurements::Dict{Symbol, AbstractMeasurement}: A collection\n\nof measurements run during the thermalization stage. By default, none are used.\n\nmeasurements::Dict{Symbol, AbstractMeasurement}: A collection of measurements\n\nrun during the measurement stage. Calls default_measurements if not specified.\n\nrecorder = ConfigRecorder: Type of recorder used for saving configurations\n\ngenerated during the simulation. Used (by default) when replay!ing simulations.  (Discarder or ConfigRecorder)\n\nrecording_rate = measure_rate: Rate at which configurations are recorded.\nthermalization = 100: Number of thermalization sweeps\nsweeps: Number of measurement sweeps\nall_checks = true: Check for Propagation instabilities and sign problems.\nsafe_mult = 10: Number of \"safe\" matrix multiplications. Every safe_mult\n\nmultiplications, a UDT decomposition is used to stabilize the product.\n\ndelta_tau = 0.1: Time discretization of the path integral\nbeta::Float64: Inverse temperature used in the simulation\nslices::Int = beta / delta_tau: Number of imaginary time slice in the\n\nsimulation\n\nmeasure_rate = 10: Number of sweeps discarded between every measurement.\nlast_sweep = 0: Sets the index of the last finished sweep. The simulation\n\nwill start with sweep last_sweep + 1.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#Potential-extensions-1","page":"DQMC","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"todo","category":"page"},{"location":"DQMC/measurements/#Measurements-1","page":"Measurements","title":"Measurements","text":"","category":"section"},{"location":"DQMC/measurements/#Construction-Measurements-1","page":"Measurements","title":"Construction Measurements","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Measurement are created and added to a Simulation via dqmc[:name] = measurement(dqmc, model). Various properties of the measurement can be adjusted via keyword arguments, such as the lattice iteration scheme or the Wicks expanded expectation value. This will be discussed in more detail later.","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The currently implemented measurements are the following:","category":"page"},{"location":"DQMC/measurements/#Greens-1","page":"Measurements","title":"Greens","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The equal time greens function can be measured via greens_measurement(dqmc, model). The measurement will take the Monte Carlo average of greens(dqmc, model).","category":"page"},{"location":"DQMC/measurements/#Occupation-1","page":"Measurements","title":"Occupation","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The per-site occupation langle n_i rangle can be measured via occupation(dqmc, model). This will average 1 - G_ii.","category":"page"},{"location":"DQMC/measurements/#Charge-Density-1","page":"Measurements","title":"Charge Density","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The charge density correlation langle sum_r n(r) n(r+Delta r) rangle can be measured with charge_density_correlation(dqmc, model). The time integral of that, the charge density susceptibility can be measure with charge_density_susceptibility(mc, model).","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Note that you can also pass kernel = MonteCarlo.reduced_cdc_kernel to measure just the correlated part, i.e. langle sum_r n(r) n(r+Delta r) rangle - langle n(r) rangle langle n(r+Delta r) rangle instead.","category":"page"},{"location":"DQMC/measurements/#Magnetization-1","page":"Measurements","title":"Magnetization","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"magnetization(dqmc, model, dir::Symbol) measures the per-site x-, y- or z-magnetizations.","category":"page"},{"location":"DQMC/measurements/#Spin-Density-1","page":"Measurements","title":"Spin Density","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The spin density correlation langle S_gamma S_gamma rangle in x-, y- or z-direction can be measured with spin_density_correlation(dqmc, model, dir::Symbol). The respective susceptibilities follow from spin_density_susceptibility(dqmc, model, dir).","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Like with charge density there are additional kernels that only measure the correlated part of the spin density. Use kernel = MonteCarlo.reduced_sdc_γ_kernel with gamma in x y z for the respective direction.","category":"page"},{"location":"DQMC/measurements/#Pairing-1","page":"Measurements","title":"Pairing","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The pairing susceptibility Delta_v(s_1 t_1)(tau) Delta_v^dagger(s_2 t_2)(0) can be calculated with pairing_susceptibility(dqmc, model). The tau = 0 pairing correlation follows from pairing_correlation(dqmc, model).","category":"page"},{"location":"DQMC/measurements/#Current-Current-Susceptibility-1","page":"Measurements","title":"Current-Current Susceptibility","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"current_current_susceptibility(dqmc, model) measures langle j_t_2 - s_2(s_2 l) j_t_1 - s_1(s_1 0)rangle with j_t - s(s tau) = langle i sum_sigma T_ts c_t^dagger(tau) c_s(tau) - T_st c_s^dagger(tau) c_t(tau) rangle where i^2 = -1 and T is the hopping matrix.","category":"page"},{"location":"DQMC/measurements/#Superfluid-Density-1","page":"Measurements","title":"Superfluid Density","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The superfluid density can be derived from the current-current susceptibility and the Greens function. MonteCarloAnalysis.jl provides functionality for that.","category":"page"},{"location":"DQMC/measurements/#Energies-1","page":"Measurements","title":"Energies","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The energy can be measured with total_energy(dqmc, model). The interacting and hopping parts can be measured independently with interaction_energy(dqmc, model) and kinetic_energy(dqmc, model)","category":"page"},{"location":"DQMC/measurements/#General-Notes-1","page":"Measurements","title":"General Notes","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"All measurements are implemented via","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"struct DQMCMeasurement{F <: Function, GI, LI, FI, OT, T} <: AbstractMeasurement\n    greens_iterator::GI\n    lattice_iterator::LI\n    flavor_iterator::FI\n    kernel::F\n    observable::OT\n    temp::T\nend","category":"page"},{"location":"DQMC/measurements/#kernel-1","page":"Measurements","title":"kernel","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The auxiliary field dependent greens function is readily available at any point in the simulation. As such it is the object on which measurements typically rely on. Using Wick's theorem most expectation values can be expressed in terms of greens function elements G_ij(k l) = langle c_i(k Deltatau) c_j^dagger(l Deltatau)rangle where i j represent sites and flavors (spins), and k l represent imaginary time. The kernel implements this expanded form. ","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"For example, the full_cdc_kernel implementing langle sum_r n(r) n(r+Delta r) rangle looks like this:","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"@inline Base.@propagate_inbounds function full_cdc_kernel(\n        mc, ::Model, ij::NTuple{2}, packed_greens::_GM4{<: Matrix}, flv\n    )\n    i, j = ij\n    f1, f2 = flv\n\tG00, G0l, Gl0, Gll = packed_greens\n    N = length(lattice(mc))\n    \n    id = I[i, j] * I[G0l.k, G0l.l] * I[f1, f2]\n    s1 = N * (f1 - 1)\n    s2 = N * (f2 - 1)\n\n    # ⟨n_{σ₁}(l) n_{σ₂}(0)⟩ =\n    #   ⟨n_{σ₁}(l)⟩ ⟨n_{σ₂}(0)⟩ + \n    #   ⟨c_{σ₁}^†(l) c_{σ₂}(0)⟩ ⟨c_{σ₁}(l) c_{σ₂}^†(0)⟩ =\n    return (1 - Gll.val[i+s1, i+s1]) * (1 - G00.val[j+s2, j+s2]) +\n            (id - G0l.val[j+s1, i+s2]) * Gl0.val[i+s1, j+s2]\nend","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Here i, j = ij are site indices representing r r + Delta r coming from the lattice iterator, G00, G0l, Gl0, Gll = packed_greens are Greens matrices at different imaginary times coming from the greens iterator, and f1, f2 = flv are flavor (spin) indices coming from the flavor iterator. The result of the kernel is the charge density expectation value for a specific set of those indices.","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"These functions generally have a specialized methods implemented for the different matrix types that are used in DQMC. You can check the source code under \"flavors/DQMC/measurements/constructors\" for more examples. ","category":"page"},{"location":"DQMC/measurements/#greens_iterator-1","page":"Measurements","title":"greens_iterator","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The greens_iterator controls which Greens functions are passed on to the kernel. Internally measurements that use the same greens_iterator will be bundled to avoid expensive recalculations. The available iterators include:","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"nothing specifies that no Greens function is needed\nGreens() forwards the equal time greens function G(0, 0) (which matches all other equal time greens functions)\nGreensAt(k, l) forwards the result of greens(dqmc, k, l), i.e. a greens function at the specific time indices k l.\nTimeIntegral([recalculate = 2 mc.parameters.safe_mult]) creates an iterator for calculating imaginary time integral of the form O_i = int_0^beta O_(tau) dtau as O_i approx sum_l = 0^M-1 05 Deltatau (O_(l Deltatau) + O_((l+1) Deltatau)). In every step this iterator will generate four greens matrices G(0 0), G(0 lDeltatau), G(lDeltatau 0), G(lDeltatau lDeltatau). This internally uses CombinedGreensIterator(mc[; start, stop, recalculate]) to generate these matrices.","category":"page"},{"location":"DQMC/measurements/#lattice_iterator-1","page":"Measurements","title":"lattice_iterator","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The lattice_iterator controls which combination of site indices are passed to the kernel and how they are further combined before saving the measurements. For example, EachSitePairByDistance passes any combination of two sites indices to the kernel and sums up site pairs which have the same distance between them. See the Lattices section for more detail.","category":"page"},{"location":"DQMC/measurements/#flavor_iterator-1","page":"Measurements","title":"flavor_iterator","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The flavor_iterator similarly specifies which flavor (spin) indices should be iterated. This is primarily an optimization used to pull a flavor sum out of the kernel. Note that this is not always possible/useful, so some measurements may not use this iterator even though multiple flavors are involved. As such this iterator should generally not be adjusted.","category":"page"},{"location":"DQMC/measurements/#observable-1","page":"Measurements","title":"observable","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The observable is the final storage of the measured values. By default this is a LogBinner from BinningAnalysis.jl but that can be changed. The only hard requirement is that the data structure implements push!. If you want to use your own storage structure you can get a zero element from MonteCarlo._binner_zero_element(dqmc, lattice_iterator, MonteCarlo.geltype(dqmc)) if you need it.","category":"page"},{"location":"DQMC/measurements/#temp-1","page":"Measurements","title":"temp","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The temp field is a temporary storage Array used as a target for summation before pushing the final result of the measurement. It should be initialized with MonteCarlo._measurement_buffer(dqmc, lattice_iterator, geltype(dqmc)). Note that this is often but not always the same as the zero element.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Topological-Flat-Band-Model-1","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"This will be a rather extensive example and crosscheck with the 2020 paper \"Superconductivity, pseudogap, and phase separation in topological flat bands:'a quantum Monte Carlo study\" (arxiv) by Hofmann, Berg and Chowdhury. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#Introduction-1","page":"Topological Flat Band Model","title":"Introduction","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The paper investigates an attractive square lattice Hubbard model with complex hoppings up to the 5th order. It generates a flat and a dispersive band, where the flatness of the former can increased with the right ratio of hoppings. At partial filling of the flat band superconductivity is observed. The model reads","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"beginaligned\n\tH_kin = left\n        -t_1 sum_langle i j rangle_1 sigma e^iphi_ij^sigma c_i sigma^dagger c_j sigma\n        -t_2 sum_langle i j rangle_2 sigma s_langle i j rangle_2 c_i sigma^dagger c_j sigma\n        -t_5 sum_langle i j rangle_5 sigma c_i sigma^dagger c_j sigma\n        + hc\n    right - mu sum_i n_i \n    H_int = - fracU2 sum_i (n_i - 1)^2\nendaligned","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where t_n refers to n-th nearest neighbor hopping and langle i j rangle_n refers to the involved site pairs. We will discuss the prefactors more closely when implementing the lattice model. The interactive term is a variation of what we use in our standard attractive Hubbard model and can be dealt with using the same Hirsch transformation.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Implementation-1","page":"Topological Flat Band Model","title":"Implementation","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#The-Lattice-1","page":"Topological Flat Band Model","title":"The Lattice","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The model is defined for a square lattice, however the paper suggests defining it via two site basis A = (0 0), B = (0 1) with lattice vector a_1 = (1 1) and a_2 = (1 -1). We will follow this suggestion. The model uses first, second and fifth neighbor hoppings.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The nearest neighbors are directed, catching different values for phi_ij^sigma as a result. We need to create two groups, one with directions as indicated in figure 1a) in the paper, and one with the reverse. For second nearest neighbors the prefactor s_langle i j rangle_2 depends on the combination of sublattice and direction. In a_1 direction the value is positive (negative) on the A (B) sublattice, and in a_2 it is negative (positive) on the A (B) sublattice. The fifth nearest neighbors always have the same weight and thus do not require special grouping.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"using MonteCarlo: UnitCell, Bond, Lattice\n\nfunction HBCLattice(Lx, Ly = Lx)\n    uc = UnitCell(\n        # name\n        \"HBC Square\",\n\n        # Bravais lattice vectors\n        ([1.0, +1.0], [1.0, -1.0]),\n        \n        # Sites\n        [[0.0, 0.0], [0.0, 1.0]],\n\n        # Bonds\n        [\n            # NN, directed\n            # bonds from ref plot, π/4 weight for spin up\n            Bond(1, 2, ( 0,  1), 1),\n            Bond(1, 2, (-1,  0), 1),\n            Bond(2, 1, (+1, -1), 1),\n            Bond(2, 1, ( 0,  0), 1),\n\n            # NN reversal\n            Bond(2, 1, ( 0, -1), 2),\n            Bond(2, 1, (+1,  0), 2),\n            Bond(1, 2, (-1, +1), 2),\n            Bond(1, 2, ( 0,  0), 2),\n            \n            # NNN\n            # positive weight (we need forward and backward facing bonds here too)\n            Bond(1, 1, (+1,  0), 3),\n            Bond(1, 1, (-1,  0), 3),\n            Bond(2, 2, ( 0, +1), 3),\n            Bond(2, 2, ( 0, -1), 3),\n            # negative weight\n            Bond(1, 1, ( 0, +1), 4),\n            Bond(1, 1, ( 0, -1), 4),\n            Bond(2, 2, (+1,  0), 4),\n            Bond(2, 2, (-1,  0), 4),\n            \n            # Fifth nearest neighbors\n            Bond(1, 1, (2, 0), 5),\n            Bond(2, 2, (2, 0), 5),\n            Bond(1, 1, (0, 2), 5),\n            Bond(2, 2, (0, 2), 5),\n            # backwards facing bonds\n            Bond(1, 1, (-2,  0), 5),\n            Bond(2, 2, (-2,  0), 5),\n            Bond(1, 1, ( 0, -2), 5),\n            Bond(2, 2, ( 0, -2), 5),\n        ]\n    )\n\n    return Lattice(uc, (Lx, Ly))\nend","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"With this implementation we can then generate a lattice of arbitrary size with","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"L = 8\nl = HBCLattice(L)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where L is the linear system size. Note that due to the two basis sites the total number of sites is 2L^2. To verify our lattice implementation it is useful to create a comparable plot. In Makie, for example, we may run","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"using GLMakie\n\n# get small lattice without periodic bonds\nl = HBCLattice(3)\n\n# create figure and axis without background grid and stretching\nfig = Figure()\nax = Axis(fig[1, 1], aspect=DataAspect(), xgridvisible = false, ygridvisible = false)\n\n# collect list of bonds grouped by label\nps = Point2f.(positions(l))\nls = [Point2f[] for _ in 1:5]\nfor b in bonds_open(l, true)\n    push!(ls[b.label], ps[b.from], ps[b.to])\nend\n\n# Draw arrows for NN groups\nds = ls[1][2:2:end] .- ls[1][1:2:end]\na = arrows!(ax, ls[1][1:2:end] .+ 0.35 .* ds, 0.55 .* ds, color = :black, arrowsize = 16)\nds = ls[2][2:2:end] .- ls[2][1:2:end]\narrows!(ax, ls[2][1:2:end] .+ 0.65 .* ds, 0.25 .* ds, color = :lightgray, arrowsize = 16)\n\n# NNN\nlinesegments!(ax, ls[3], color = :black, linewidth=1)\nlinesegments!(ax, ls[4], color = :black, linewidth=1, linestyle = :dash)\n\n# 5th nearest neighbors\nlinesegments!(ax, ls[5] .+ Point2f(0, 0.05), color = :red)\n\n# draw A and B sites\nAs = ps[1, :, :][:]\nBs = ps[2, :, :][:]\nscatter!(ax, As, color = :black, markersize = 10)\nscatter!(ax, Bs, color = :black, marker='■', markersize = 16)\n\n# Label A and B sites\ntext!(ax, \"A\", position = Point2f(2-0.2, 0), align = (:right, :center))\ntext!(ax, \"B\", position = Point2f(2-0.2, 1), align = (:right, :center))\n\nMakie.save(\"HBC_lattice.png\", fig)\nfig\n\n","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"In the plot we indicate the first group of nearest neighbors with black arrows and the second, i.e. the reversals with light gray ones. Next nearest neighbors are indicated with full (group 3) or dashed lines (group 4) like in the paper. The fifth nearest neighbors (group 5) are drawn in red like in the reference.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Hopping-and-Interaction-Matrix-1","page":"Topological Flat Band Model","title":"Hopping and Interaction Matrix","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Now that we have the lattice we can generate a fitting hopping matrix. But before we do this, let us briefly discuss some optimizations. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"LoopVectorization.jl is a great tool when pushing for peak single threaded/single core linear algebra performance. The linear algebra needed for DQMC is reimplemented in MonteCarlo.jl using it for both Float64 and ComplexF64. The latter uses MonteCarlo.CMat64 and MonteCarlo.CVec64 as concrete array types which are based on StructArrays.jl under the hood. They should be used in this model. Furthermore we can make use of MonteCarlo.BlockDiagonal as we have no terms with differing spin indices. Thus we set","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"using MonteCarlo: StructArray, BlockDiagonal, CMat64\n\nMonteCarlo.@with_kw_noshow struct HBCModel <: Model\n    # parameters with defaults based on paper\n    mu::Float64 = 0.0\n    U::Float64 = 1.0\n    @assert U >= 0. \"U must be positive.\"\n    t1::Float64 = 1.0\n    t2::Float64 = 1.0 / sqrt(2.0)\n    t5::Float64 = (1 - sqrt(2)) / 4\n\n    # lattice\n    l::Lattice{2}\n    @assert l.unitcell.name == \"HBC Square\"\nend\n\nMonteCarlo.hopping_eltype(::Type{DQMC}, ::HBCModel) = ComplexF64\nMonteCarlo.hopping_matrix_type(::Type{DQMC}, ::HBCModel) = BlockDiagonal{ComplexF64, 2, CMat64}\nMonteCarlo.greens_eltype(::Type{DQMC}, ::HBCModel) = ComplexF64\nMonteCarlo.greens_matrix_type( ::Type{DQMC}, ::HBCModel) = BlockDiagonal{ComplexF64, 2, CMat64}","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"for our model. The definition of the hopping matrix then follows from the various weights in the Hamiltonian as","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"function MonteCarlo.hopping_matrix(m::HBCModel)\n    # number of sites\n    N = length(m.l)\n\n    # spin up and spin down blocks of T\n    tup = diagm(0 => fill(-ComplexF64(m.mu), N))\n    tdown = diagm(0 => fill(-ComplexF64(m.mu), N))\n\n    # positive and negative prefactors for t1, t2\n    t1p = m.t1 * cis(+pi/4) # ϕ_ij^↑ = + π/4\n    t1m = m.t1 * cis(-pi/4) # ϕ_ij^↓ = - π/4\n    t2p = + m.t2\n    t2m = - m.t2\n    \n    for b in bonds(m.l, Val(true))\n        # NN paper direction\n        if b.label == 1 \n            tup[b.from, b.to]   = - t1p\n            tdown[b.from, b.to] = - t1m\n        \n        # NN reverse direction\n        elseif b.label == 2\n            tup[b.from, b.to]   = - t1m\n            tdown[b.from, b.to] = - t1p\n            \n        # NNN solid bonds\n        elseif b.label == 3\n            tup[b.from, b.to]   = - t2p\n            tdown[b.from, b.to] = - t2p\n\n        # NNN dashed bonds\n        elseif b.label == 4\n            tup[b.from, b.to]   = - t2m\n            tdown[b.from, b.to] = - t2m\n\n        # Fifth nearest neighbors\n        else\n            tup[b.from, b.to]   = - m.t5\n            tdown[b.from, b.to] = - m.t5\n        end\n    end\n\n    return BlockDiagonal(StructArray(tup), StructArray(tdown))\nend","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"We note that the hermitian conjugates of a hopping c_j^dagger c_i can also be understood as reversing the bond direction. Since we include both directions in our lattice definitions, second and fifth nearest neighbor hermitian conjugates are taken care of. First nearest neighbors get a phase shift from complex conjugation, which is included by swapping t1p and t1m between group one and two.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To finish off the mandatory model interface we need to provide three more methods. The first is lattice(model) which simply return the lattice of the model. The other two are unique_flavors(model) and total_flavors(model). The latter returns the total number of flavors a model has without making use of any symmetries, i.e. 2 for a spin 1/2 model. The former returns the number of flavors that will result in unique entries in the hopping matrix. For this model we have a hopping directly depending on spin, thus also 2 flavors here.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"MonteCarlo.lattice(m::HBCModel) = m.l\nMonteCarlo.unique_flavors(::HBCModel) = 2\nMonteCarlo.total_flavors(::HBCModel) = 2","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"There are a few more methods we can implement for convenience. The most important of these is choose_field(model), which sets a default field for our model. The best choice here should be DensityHirschField or DensityGHQField as the model uses an attractive interaction. Beyond this we could implement parameters(model), save_model, _load_model and printing.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"HBCModel(l::MonteCarlo.AbstractLattice; kwargs...) = HBCModel(l = l; kwargs...)\nMonteCarlo.choose_field(::HBCModel) = DensityHirschField","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The full code including these convenience functions can be found here","category":"page"},{"location":"examples/HofmannBergChowdhury/#Simulation-Setup-1","page":"Topological Flat Band Model","title":"Simulation Setup","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To keep the runtime of this crosscheck reasonable we used the smallest linear system size the paper considers, L = 8. We also set U = 1 and the fifth nearest neighbor hopping t5 = 0. This corresponds to a flatness ratio F = 02. To be comparable to the paper we will need to tune the chemical potential mu to hit half filling. This can be done through trial and error on a smaller lattice. The optimal mu, after running the main simulation with a small set of different values, seems to be mu approx -2206. Thus the basic setup for our simulation becomes","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"l = HBCLattice(8)\nm = HBCModel(l, t5 = 0.0, mu = -2.206) # other defaults match F = 0.2 setup\nmc = DQMC(\n    m, beta = beta, thermalization = 1000, sweeps = 5000, \n    measure_rate = 5, print_rate = 100, recorder = Discarder()\n)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where beta needs to run over a reasonable set of inverse temperatures. We will use [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 10.0, 12.0, 14.0, 17.0, 20.0, 25.0, 30.0, 35.0, 40.0]. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"note: Note\nIn our actual simulation we used a BufferedConfigRecorder to record configurations. That way the simulation can be replayed with different measurements. This is very useful when you are still unsure about what you want to measure or how exactly those measurements are supposed to work.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Measurements-1","page":"Topological Flat Band Model","title":"Measurements","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"We will consider the following measurements for comparison:","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Z-spin susceptibility, solid red line in figure 1d)\nSuperfluid stiffness, figure 2b)\nReciprocal s-wave pairing susceptibility, solid red line in figure 4a)\nReciprocal charge susceptibility, solid blue line in figure 4a)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Z-Spin-Susceptibility-1","page":"Topological Flat Band Model","title":"Z-Spin Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The z-spin susceptibility int_0^beta dtau langle m_z(r^prime tau) m_z(r 0) rangle can be measure with","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:SDSz] = spin_density_susceptibility(mc, m, :z)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The integral will be evaluated by MonteCarlo.jl and the result, accessible with mean(mc[:SDCz]), will return the average result by direction. I.e. mean(mc[:SDCz])[i] will contain the average z-spin susceptibility in directions(mc)[i].","category":"page"},{"location":"examples/HofmannBergChowdhury/#Reciprocal-Charge-Susceptibility-1","page":"Topological Flat Band Model","title":"Reciprocal Charge Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The paper defines the charge susceptibility as int_0^beta dtau langle N(tau) N(0) rangle where N(tau) = sum_j (n_j(tau) - nu) and nu is the filling. The charge density susceptibility that MonteCarlo.jl defines, on the other hand, is langle n_j(tau) n_i(0)rangle. To connect these two we expand the papers' definition:","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"beginaligned\n\tlangle N(tau) N(0) rangle \n        = langle sum_j (n_j(tau) - nu) sum_i (n_i(0) - nu) rangle \n        = sum_ij langle n_j(tau) n_i(0) - n_j(tau) nu - nu n_i(0) + nu nu rangle \n        = sum_ij langle n_j(tau) n_i(0) rangle - langle sum_i n_i rangle^2\nendaligned","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"In the last step we associated nu = sum_i langle n_i rangle  N, i.e. the average occupation. We can use this representation to calculate the reciprocal charge susceptibility as 1  (O - nu^2) where O is MonteCarlo.jl's charge density susceptibility and nu is the average occupation. We measure","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:occ] = occupation(mc, m)\nmc[:CDS] = charge_density_susceptibility(mc, m)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Reciprocal-S-Wave-Pairing-Susceptibility-1","page":"Topological Flat Band Model","title":"Reciprocal S-Wave Pairing Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The paper defines the (s-wave) pairing susceptibilities as O(tau) = sum_j c_j uparrow c_j downarrow + hc. More generally you would consider a site offset between the pairs of operators and use weighted sums to get pairing susceptibilities of various symmetries like d-wave, p-wave, etc. For s-wave this offset is vec0. In MonteCarlo.jl these offsets are set via the lattice iterator. For example you may use EachLocalQuadByDistance([2, 4, 5]) to consider the directions(mc)[[2, 4, 5]] as offsets. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The pairing_suceptibility constructors from MonteCarlo.jl is written with these offsets in mind. By default it will include offsets for all nearest neighbors as well as offsets of vec0. To reduce computational complexity we may reduce these to just vec0 offsets by requesting just first offset:","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:PS] = pairing_susceptibility(mc, m, K=1)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Superfluid-Stiffness-1","page":"Topological Flat Band Model","title":"Superfluid Stiffness","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The superfluid stiffness is given by 025 - K_x - Lambda_xx(q = 0) in the paper. Both the diamagnetic contribution K_x and the Fourier transformed current-current correlation Lambda_xx(q) are things we need to measure individually.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The diamagnetic contribution K_x is the simpler one. For that we refer to equations 15a - 15j in the paper. The sum of all of these is the K_x we seek. Since all terms are quadratic in creation and annihilation operators we do not need to worry about expanding them with Wicks theorem. Instead we can simply measure the Greens matrix during the simulation. If we compare the equations with the Hamiltonian we will also notice that they are (almost) the same as the hopping terms. Thus we can get weights from the hopping matrix and apply them afterwards. We measure","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:G] = greens_measurement(mc, m)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"For current-current correlations we need to measure int_0^beta d tau langle J_x^alpha(r^prime tau) J_x^beta(r 0) rangle where J_x(r tau) is given in equation 14a - 14j. These terms are partially implemented in MonteCarlo.jl with rest implemented in MonteCarloAnalysis.jl.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Specifically MonteCarlo.jl implements cc_kernel as a generic version of the terms 14a - 14j with the directional prefactor langle hatx Delta r_alpha removed. These prefactors are instead introduced in cached_para_ccc from MonteCarloAnalysis.jl, which computes Lambda_xx(q). The hopping directions considered in cc_kernel are set by the lattice iterator. By default, it will consider half the bonds of the lattice, dropping reverse bonds. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The included bonds can be adjusted by passing a lattice_iterator = EachBondPairByBravaisDistance([1,6,9,11,13,15]) to the measurements. The indices apply to lattice(mc).unitcell.bonds and in this case pick the bonds fitting terms 14a - 14f. The remaing terms are 0 with the choice of t_5 = 0.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:CCS] = current_current_susceptibility(\n    mc, m, lattice_iterator = EachBondPairByBravaisDistance([1,6,9,11,13,15])\n)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Running-the-simulations-1","page":"Topological Flat Band Model","title":"Running the simulations","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To run the simulation we simply use run!(mc).","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"We should point out that these simulations are lot more complex than the other two examples. We are working with 128 sites as opposed to 16 and inverse temperatures as large as 40 instead of le 12. We are also using complex matrices which bring 2 - 4 times the complexity and we need to consider both a spin up and down sector in the greens matrix. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"It is therefore advised that you run this on a cluster, in parallel. To figure out how much time is needed you can check the sweep time for the smallest beta with measurements. The scaling should be roughly linear (w.r.t. beta). Note that you can pass a safe_before::TimeType to make sure the simulation saves and exits in time. If your cluster restricts you to full nodes it might be useful to create files for each simulation beforehand and distribute filenames to different cores on the same node. (src/mpi.jl might be helpful.)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Results-1","page":"Topological Flat Band Model","title":"Results","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"In this section we plot the results from our simulations on top of the results from the paper. There are 5 points per temperature coming from different chemical potentials mu. The filling varies from 0.22 to 0.265 between them. Note also that not every simulation did the full number of sweeps. The shortest simulation ran for about 3000 sweeps, which includes 1000 thermalization sweeps.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Z-Spin-Susceptibility-2","page":"Topological Flat Band Model","title":"Z-Spin Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To get the results from the paper we need to perform a q = 0 Fourier transform which is simply a sum. We calculate real(sum(mean(mc[:SDCz]))) and plot against 1 / mc.parameters.beta.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"examples/HofmannBergChowdhury/#Reciprocal-Charge-Susceptibility-2","page":"Topological Flat Band Model","title":"Reciprocal Charge Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"For the reciprocal charge susceptibility we plot","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"CDS = real(sum(mean(mc[:CDS])))\nocc = real(sum(mean(mc[:occ])))\nxs = 1 / mc.parameters.beta\nys = 1 / (CDS - mc.parameters.beta * occ^2 / length(lattice(mc)))","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where the factor mc.parameters.beta / length(lattice(mc)) comes from the imaginary time integral.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"examples/HofmannBergChowdhury/#Reciprocal-Pairing-Susceptibility-1","page":"Topological Flat Band Model","title":"Reciprocal Pairing Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The pairing susceptibility comes with three directional indices after taking mean(mc[:PS]). The first is associated with the distance r - r^prime between the two pairing operators Delta(r) in langle Delta^alpha(r) Delta^beta(r^prime) rangle. The second and third are displacements inside them. Since we only care about s-wave pairing the internal displacements are zero or index 1. Thus we plot 1 / real(sum(mean(mc[:PS])[:, 1, 1])) against 1 / mc.parameters.beta for the reciprocal pairing susceptibility. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"examples/HofmannBergChowdhury/#Superfluid-Stiffness-2","page":"Topological Flat Band Model","title":"Superfluid Stiffness","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To compute the superfluid stiffness we make use of the relevant functions from MonteCarloAnalysis.jl. It is given by:","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"using MonteCarloAnalysis\n\n# The diamagnetic contribution follows from the greens function. We set the \n# direction of the current response to x = [1, 0] like the reference paper.\nK_x = dia_K(mc, :G, [1, 0])\n\n# The paramagnetic contribution is calculated in full, i.e. Λxx(q) from the \n# CCS measurement.\nΛxx = cached_para_ccc(mc, :CCS, [1,0])\n\n# Following the paper the superfluid stiffness becomes\nSFS = 0.25 * (-K_x - Λxx[1, 1])","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"legacy/lattices/#Lattices-1","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"The package ships with a couple of standard lattices","category":"page"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"Type Description\nMonteCarlo.Chain 1-dimensional chain\nMonteCarlo.SquareLattice 2-dimensional square lattice\nMonteCarlo.CubicLattice D-dimensional cubic lattice","category":"page"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"It also provides routines to load the following common lattice formats","category":"page"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"Type Description\nMonteCarlo.ALPSLattice ALPS simple lattice graph (XML file)","category":"page"},{"location":"legacy/lattices/#Didn't-find-your-desired-lattice?-1","page":"Lattices","title":"Didn't find your desired lattice?","text":"","category":"section"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"Just implement your own lattice for later use in a model of choice. See Custom lattices.","category":"page"},{"location":"devdocs/linalg/#Linear-Algebra-1","page":"Linear Algebra","title":"Linear Algebra","text":"","category":"section"},{"location":"devdocs/linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"MonteCarlo.jl makes heavy use of LoopVectorization to speed up linear algebra. The respective functions are mostly in \"flavors/DQMC/linalg\", with a few more specific functions in places where they are needed. These functions are generally identified with a v prefix.","category":"page"},{"location":"devdocs/linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"Generally the methods mirror the respective methods from LinearAlgebra - vmul! is a matrix multiplication like mul!, rvmul! and lvmul! match rmul! and vmul!. Usually MonteCarlo.jl only implements the methods that are actually used, so there won't be a method for every possible type combination. On the other hand there are also some new methods which are used with specialized matrix types, such as vmul!(output, left, right, range).","category":"page"},{"location":"devdocs/linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"To summarize the existing functions:","category":"page"},{"location":"devdocs/linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"vmul!(target, left, right) calculates target = left * right in place\nrvmul!(left, right::Diagonal) calculates left = left * right in place\nlvmul!(left::Diagonal, right) calculates right = left * right in place\nrvadd!(left, right) calculates left += right in place\nvsub!(output, left, ::UniformScaling) calculates output = left - I in place\nvmin!(v::Vector, w::Vector) calculates v .= min.(1, w)\nvmininv!(v::Vector, w::Vector) calculates v .= 1 ./ min.(1, w)\nvmax!(v::Vector, w::Vector) calculates v .= max.(1, w)\nvmaxinv!(v::Vector, w::Vector) calculates v .= 1 ./ max.(1, w)\nvinv!(v::Vector) calculates v .= 1 ./ v\nvinv!(v::Vector, w::Vector) calculates v .= 1 ./ w\nrdivp!(left, T, temp, pivot) calculates left * T^-1 where T is a pivoted upper triangular matrix as returned by udt_AVX_pivot(U, D, T, pivot, temp, Val(false))","category":"page"},{"location":"devdocs/linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"And finally udt_AVX_pivot!(U, D::Diagonal, T[, pivot, temp, apply_pivot::Val]) which performs a pivoted UDT decomposition, which is a QR decomposition with the diagonal values pulled out of the R matrix. The T matrix doubles as the input, pivot is an integer pivoting vector and temp is a temporary vector with eltype matching the input matrix . apply_pivot sets whether the output T matrix has pivoting applied, making it a true upper triangular matrix or not.","category":"page"},{"location":"devdocs/linalg/#Special-Types-1","page":"Linear Algebra","title":"Special Types","text":"","category":"section"},{"location":"devdocs/linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"For optimization purposes we have a couple of custom matrix types.","category":"page"},{"location":"devdocs/linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"The simplest is CVec64 and CMat64 which is just a shortened name for the StructArray of a complex vector or matrix. As noted in LoopVectorization StructArray is needed to handle complex matrices efficiently.","category":"page"},{"location":"devdocs/linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"The next type is BlockDiagonal which is a matrix type consisting of square matrices on the diagonal. This type is used with, for example, two flavor problems which don't include terms mixing flavors. In that case the off-diagonal blocks are 0 matrices and don't need to be considered. Note that this type is only thoroughly tested for two equally sized blocks, and may need some extra work to extend to an arbitrary number of blocks.","category":"page"},{"location":"devdocs/linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"The most complicated one is CheckerboardDecomposed which encodes a checkerboard decomposition of a hopping matrix. This decomposition uses the bond structure of the lattice and that the hopping matrix must be Hermitian to decompose it into a chain of sparse matrices, which can be multiplied onto a regular matrix more quickly. Note that this decomposition may increase or decrease the error caused by the Trotter decomposition.","category":"page"},{"location":"devdocs/linalg/#","page":"Linear Algebra","title":"Linear Algebra","text":"Finally we have DiagonallyRepeatingMatrix which is a thin wrapper around a regular matrix type. It simply indicates that the contained matrix repeats along the diagonal. This is the case for models with multiple flavors, where the flavors mirror each other. This is only used in measurements.","category":"page"},{"location":"legacy/customize/#Customize-1","page":"Customize","title":"Customize","text":"","category":"section"},{"location":"legacy/customize/#Custom-models-1","page":"Customize","title":"Custom models","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Although MonteCarlo.jl already ships with famous models, foremost the Ising and Hubbard models, the central idea of the design of the package is to have a (rather) well defined interface between models and Monte Carlo flavors. This way it should be easy for you to extend the package and implement your own physical model (or variations of existing models). You can find the interfaces in the corresponding section of the documentation, for example: Interface: Monte Carlo (MC).","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Sometimes examples tell the most, so feel encouraged to have a look at the implementations of the above mentioned models to get a feeling of how to implement your own model.","category":"page"},{"location":"legacy/customize/#General-remarks-for-lattice-models-1","page":"Customize","title":"General remarks for lattice models","text":"","category":"section"},{"location":"legacy/customize/#Semantics-1","page":"Customize","title":"Semantics","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"For lattice models, we define a Model to be a Hamiltonian on a lattice. Therefore, the lattice is part of the model (and not the Monte Carlo flavor). The motivation for this modeling is that the physics of a system does not only depend on the Hamiltonian but also (sometime drastically) on the underlying lattice. This is for example very obvious for spin systems which due to the lattice might become (geometrically) frustrated and show spin liquids physics. Also, from a technical point of view, lattice information is almost exclusively processed in energy calculations which both relate to the Hamiltonian (and therefore the model).","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"note: Note\nWe will generally use the terminology Hamiltonian, energy and so on. However, this doesn't restrict you from defining your model as an Lagrangian with an action in any way as this just corresponds to a one-to-one mapping of interpretations.","category":"page"},{"location":"legacy/customize/#Lattice-requirements-1","page":"Customize","title":"Lattice requirements","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"The Hamiltonian of your model might impose some requirements on the AbstractLattice object that you use as it must provide you with enough lattice information.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"It might be educating to look at the structure of the simple SquareLattice struct.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"mutable struct SquareLattice <: AbstractCubicLattice\n   L::Int\n   sites::Int\n   neighs::Matrix{Int} # row = up, right, down, left; col = siteidx\n   neighs_cartesian::Array{Int, 3} # row (1) = up, right, down, left; cols (2,3) = cartesian siteidx\n   sql::Matrix{Int}\n   SquareLattice() = new()\nend","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"It only provides access to next nearest neighbors through the arrays neighs and neighs_cartesian. If your model's Hamiltonian requires higher order neighbor information, because of, let's say, a next next nearest neighbor hopping term, the SquareLattice doesn't suffice. You could either extend this lattice or implement a NNSquareLattice for example.","category":"page"},{"location":"legacy/customize/#Custom-lattices-1","page":"Customize","title":"Custom lattices","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"As described in Custom models a lattice is considered to be part of a model. Hence, most of the requirements for fields of a AbstractLattice subtype come from potential models (see Lattice requirements). Below you'll find information on which fields are mandatory from a Monte Carlo flavor point of view.","category":"page"},{"location":"legacy/customize/#Mandatory-fields-1","page":"Customize","title":"Mandatory fields","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Any concrete lattice type, let's call it MyLattice in the following, must be a subtype of the abstract type MonteCarlo.AbstractLattice. To work with a Monte Carlo flavor, it must internally have at least have the following field,","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"sites: number of lattice sites.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"However, as already mentioned above depending on the physical model of interest it will typically also have (at least) something like","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"neighs: next nearest neighbors,","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"as most Hamiltonian will need next nearest neighbor information.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"The only reason why such a field isn't generally mandatory is that the Monte Carlo routine doesn't care about the lattice much. Neighbor information is usually only used in the energy (difference) calculation of a particular configuration like done in energy or propose_local which both belong to a Model.","category":"page"},{"location":"legacy/customize/#Custom-Monte-Carlo-flavors-1","page":"Customize","title":"Custom Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Coming soon...","category":"page"},{"location":"legacy/interfaces/DQMC/#Interface:-Determinant-Quantum-Monte-Carlo-(DQMC)-1","page":"DQMC","title":"Interface: Determinant Quantum Monte Carlo (DQMC)","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Any model that wants to be simulated by means of DQMC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the determinant Monte Carlo flavor Determinant Quantum Monte Carlo (DQMC).","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Example models: Attractive Hubbard Model","category":"page"},{"location":"legacy/interfaces/DQMC/#Mandatory-fields-1","page":"DQMC","title":"Mandatory fields","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"l::AbstractLattice: any AbstractLattice\nflv::Int: number of distinct fermion flavors (e.g. spins, bands, etc.). The Green's function will have shape (flv*N, flv*N), where N is the number of sites. Note that different fermion flavors are often related by symmetry and it's advisable to use this symmetry to work with smaller Green's function matrices. Have a look at the Attractive Hubbard Model as an example where flv=1 although it has spinful fermions.","category":"page"},{"location":"legacy/interfaces/DQMC/#Index-of-all-methods-1","page":"DQMC","title":"Index of all methods","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Pages = [\"DQMC.md\"]","category":"page"},{"location":"legacy/interfaces/DQMC/#Mandatory-methods-1","page":"DQMC","title":"Mandatory methods","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"CurrentModule = MonteCarlo","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"conftype(::Type{DQMC}, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"rand(::DQMC, ::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"hopping_matrix(mc::DQMC, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"interaction_matrix_exp!(mc::DQMC, m::Model, result::Matrix, conf, slice::Int, power::Float64=1.)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.interaction_matrix_exp!","page":"DQMC","title":"MonteCarlo.interaction_matrix_exp!","text":"interaction_matrix_exp!(\n    mc::DQMC, m::Model, field::AbstractField, \n    result::AbstractArray, slice::Int, power::Float64 = 1.0\n)\n\nCalculate the, exponentiated interaction matrix  exp(- power * delta_tau * V(slice)) and store it in result::AbstractArray. \n\nThis only includes terms with 4 operators, i.e. not the chemical potential or  any hoppings. By default the calculation will be performed by the appropriate  field type (i.e. by interaction_matrix_exp!(field, result, slice, power))\n\nBy default this function will call  interaction_matrix_exp!(field, result, slice, power).\n\nThis is a performance critical method and one might consider efficient in-place  (in result) construction.\n\n\n\n\n\n","category":"function"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"propose_local(mc::DQMC, m::Model, i::Int, conf, E_boson::Float64)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.propose_local-Tuple{DQMC, Model, Int64, Any, Float64}","page":"DQMC","title":"MonteCarlo.propose_local","text":"propose_local(mc::DQMC, m::Model, field::AbstractField, i::Int, slice::Int)\n\nPropose a local move for lattice site i at time slice slice for a field  holding the current configuration. Returns the Green's function determinant  ratio, the boson energy difference ΔE_boson = E_boson_new - E_boson, and any extra information passthrough that might be useful in accept_local.\n\nBy default this function will call propose_local(mc, field, i, slice).\n\nSee also accept_local!.\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"accept_local(mc::DQMC, m::Model, i::Int, slice::Int, conf, delta, detratio, delta_E_boson)","category":"page"},{"location":"legacy/interfaces/DQMC/#Optional-methods-1","page":"DQMC","title":"Optional methods","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"greenseltype(::Type{DQMC}, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"energy_boson(mc::DQMC, m::Model, conf)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.energy_boson-Tuple{DQMC, Model, Any}","page":"DQMC","title":"MonteCarlo.energy_boson","text":"energy_boson(mc::DQMC, model::Model, conf)\n\nCalculate bosonic part (non-Green's function determinant part) of energy for  configuration conf for Model m.\n\nThis is required for global and parallel updates as well as boson energy  measurements, but not for local updates. By default calls  energy_boson(field(mc), conf)\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"prepare_observables(mc::DQMC, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"measure_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable}, conf)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"finish_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable})","category":"page"},{"location":"legacy/flavors/mc/#Monte-Carlo-(MC)-1","page":"MC","title":"Monte Carlo (MC)","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"This is plain simple Monte Carlo (MC). It can for example be used to simulate the Ising model (see 2D Ising model).","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"You can initialize a Monte Carlo simulation of a given model simply through","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"mc = MC(model)","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Allowed keywords are:","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"beta: inverse temperature\nsweeps: number of measurement sweeps\nthermalization: number of thermalization (warmup) sweeps\nglobal_moves: wether global moves should be proposed\nglobal_rate: frequency for proposing global moves\nseed: initialize MC with custom seed","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Afterwards, you can run the simulation by","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"run!(mc)","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Note that you can just do another run!(mc, sweeps=1000) to continue the simulation.","category":"page"},{"location":"legacy/flavors/mc/#Examples-1","page":"MC","title":"Examples","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model.","category":"page"},{"location":"legacy/flavors/mc/#Exports-1","page":"MC","title":"Exports","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"MC.jl\"]","category":"page"},{"location":"legacy/flavors/mc/#MonteCarlo.replay!","page":"MC","title":"MonteCarlo.replay!","text":"replay(mc::MC[, configurations::Iterable = mc.configs; kwargs...])\n\nReplays previously generated configurations and measures observables along the way.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, replay! will generate a\n\nresumable save file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nfilename: Name of the save file. The default is based on safe_before.\nmeasure_rate = 1: Rate at which measurements are taken. Note that this is \n\nbased on the recorded configurations, not actual sweeps.\n\n\n\n\n\n","category":"function"},{"location":"legacy/flavors/mc/#MonteCarlo.run!-Tuple{MC}","page":"MC","title":"MonteCarlo.run!","text":"run!(mc::MC[; kwargs...])\n\nRuns the given Monte Carlo simulation mc. Returns SUCCESS::ExitCode = 0 if  the simulation finished normally or various other codes if failed or cancelled.  See ExitCode.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nthermalization: Number of thermalization sweeps. Uses the value passed to\n\nDQMC by default.\n\nsweeps: Number of measurement sweeps. Uses the value passed to DQMC by\n\ndefault.\n\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, run! will generate a resumable\n\nsave file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nresumable_filename: Name of the resumable save file. The default is based on\n\nsafe_before.\n\noverwrite = false: If set to true a file with the same name as\n\nresumable_filename will be overwritten. (This will create a temporary backup)\n\nSee also: resume!\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/mc/#MonteCarlo.MC","page":"MC","title":"MonteCarlo.MC","text":"Monte Carlo simulation\n\n\n\n\n\n","category":"type"},{"location":"legacy/flavors/mc/#MonteCarlo.MC-Tuple{M} where M<:Model","page":"MC","title":"MonteCarlo.MC","text":"MC(m::M; kwargs...) where M<:Model\n\nCreate a Monte Carlo simulation for model m with keyword parameters kwargs.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/mc/#MonteCarlo.MC-Union{Tuple{T}, Tuple{Model, Dict{Symbol, T}}} where T","page":"MC","title":"MonteCarlo.MC","text":"MC(m::M, params::Dict)\nMC(m::M, params::NamedTuple)\n\nCreate a Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/mc/#Potential-extensions-1","page":"MC","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Heat bath (instead of Metropolis) option","category":"page"},{"location":"devdocs/model_field/#Models-and-Fields-1","page":"Models and Fields","title":"Models and Fields","text":"","category":"section"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"The model and field of a simulation are two rather tightly connected components. The model represents the raw Hamiltonian of a problem, including an interactive term with four operators. The field controls how this interactive term is represented in a DQMC simulation. As such you may think of it as the implementation of the Hubbard Stratonovich transformation.","category":"page"},{"location":"devdocs/model_field/#The-Model-1","page":"Models and Fields","title":"The Model","text":"","category":"section"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"The model contains the lattice (which perhaps should be moved out) and whatever parameters are relevant to the model, i.e. whatever factors appear in the Hamiltonian.","category":"page"},{"location":"devdocs/model_field/#DQMC-Model-Interface-1","page":"Models and Fields","title":"DQMC - Model Interface","text":"","category":"section"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"The model interfaces with the rest of the simulation through a set of functions. These may generally be categorized as mandatory, optional and somewhere in between.","category":"page"},{"location":"devdocs/model_field/#Mandatory-Methods-1","page":"Models and Fields","title":"Mandatory Methods","text":"","category":"section"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"Mandatory methods are those every model has to provide for a DQMC simualtion to work.","category":"page"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"lattice(model) needs to return a MonteCarlo compatible lattice.\ntotal_flavors(model) is the total number of fermion flavors present in the model. This will control the number of flavors considered in measurements.\nunique_flavors(model) is the number of unique fermion flavors present in the hopping matrix of the model. This should return 1 if the hopping matrix does not depend on the flavor index. \nhopping_matrix(model) needs to generate the hopping matrix, which includes all quadratic terms. (I.e. also the chemical potential.) The hopping matrix should only include as many flavors as necessary. If the hopping matrix contains two copies of the same matrix, one for spin up and one for spin down for example, then it should only return one of these. Expanding it to an appropriate size is handled internally.","category":"page"},{"location":"devdocs/model_field/#(Semi-)-Optional-Methods-1","page":"Models and Fields","title":"(Semi-) Optional Methods","text":"","category":"section"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"These methods aren't strictly necessary to implement, but are typically good to have.","category":"page"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"_save(file::FileLike, entryname, model) writes model information to the given file. It should also save the lattice via _save(file, entryname, lattice) and save a unique tag. If this is not implemented JLD2 will be asked to save the type as is, which makes it hard to load data when the model type is edited.\n_load(data, ::Val{Symbol(tag)}) loads a model from data, which typically is a JLDFile. Note that saved tag is used to dispatch to the correct method.\nintE_kernel(mc, model, idxs, G, ::Val{flv}) should be implemented to enable measurements of the energy from the interactive term as well as the total energy. \nchoose_field(model) returns the default field type for a given model. If this is not implemented a field must be passed to DQMC.","category":"page"},{"location":"devdocs/model_field/#Very-Optional-Methods-1","page":"Models and Fields","title":"Very Optional Methods","text":"","category":"section"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"These methods should work as is with their default implementation, or are unnecessary to the simulation. ","category":"page"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"hopping_eltype(model) = eltype(hopping_matrix(model)) returns the element type of the hopping matrix.\nhopping_matrix_type(field, model) = typeof(pad_to_nflavors(field, model, hopping_matrix(model))) return the matrix type of the hopping matrix.\ngreens_eltype(field, model) = generalized_eltype(interaction_eltype(field), hopping_eltype(model)) returns the element type of the greens function. This must be compatible with element types of the hopping matrix and the interaction matrix.\ngreens_matrix_type(field, model) = Matrix{greens_eltype(field, model)} returns the full type of the greens function. This must be compatible with both the type of the hopping matrix and the interaction matrix.\nparameters(m::Model) should collect the parameters from the model and lattice in a NamedTuple. This is a user facing function meant to collect relevant/summarized information on a simulation.","category":"page"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"Also note that you may need to update the measurement kernels. More information about that on the measurement page.","category":"page"},{"location":"devdocs/model_field/#The-Field-1","page":"Models and Fields","title":"The Field","text":"","category":"section"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"The field represents the interactive term post Hubbard-Stratonovich transform in DQMC. It generally consists of some constants necessary to calculate local updates propabilities, update the Greens function and calculate the interaction matrix, and the MonteCarlo configuration.","category":"page"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"In terms of functionality we can again split the implemented function into a mandatory and optional category","category":"page"},{"location":"devdocs/model_field/#Mandatory-1","page":"Models and Fields","title":"Mandatory","text":"","category":"section"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"The mandatory function are necessary for a simualtion to run. Technically propose_local! and accept_local! are not absolutely mandatory, as one could run a simulation with only global updates. Doing so is however not a reasonable thing to do.","category":"page"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"unique_flavors(field) is the minimum number of flavors the field requires. (Some Hubbard Stratonovich transformations may introduce an asymmetry between flavors which was not in the original Hamiltonian.)\ninteraction_matrix_exp!(field, result, time_slice, power) writes the interaction matrix corresponding to the current field configuration to the given result matrix. time_slice defines the relevant imaginary time and power = -1 is used to identify that the matrix needs to be inverted (otherwise power = 1).\npropose_local!(mc, field, site, time_slice) calculates the determinant ratio and the bosonic energy associated with an update to the field configuration at some site and time_slice. If the field configuration has multiple values it can update to, this function should randomly choose one of those values. The function may pass any number of extra arguments as a thrid return value, which will then be forwarded to accept_local!().\naccept_local!(mc, field, site, time_slice, args...) updates the configuration and the greens matrix under the assumption that a previously proposed updates has been accepted. site and time_slice identify the element of the configuration that needs to be updated and args... may contain any number of arguments passed on from propose_local!().","category":"page"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"The math and temporary variables used in the calculation of local updates are collected in the FieldCache. Between different combinations of types and flavors, you should find the optimized update formulas from Quantum Monte Carlo Methods here. ","category":"page"},{"location":"devdocs/model_field/#Optional-1","page":"Models and Fields","title":"Optional","text":"","category":"section"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"The optional functions presented here should be implemented for the field to be fully compatible and performant. ","category":"page"},{"location":"devdocs/model_field/#","page":"Models and Fields","title":"Models and Fields","text":"Base.rand(field) and Random.rand!(field) are overloaded to provide a new field configuration. Mandatory for global updates.\ncompress(field), compressed_conf_type(field), decompres(field, compressed) and decompress!(field, compressed) are implemented to fill out the compression interface for (configuration) recorders. Optional for file size optimization.\ninteraction_eltype(field) and interaction_matrix_type(field, model) give type information on the interaction matrix to the simulation. Since the interaction matrix is set in place, this does not have efficient defaults and thus not implementing this will usually result in bad performance. (Defaults to Float64 and Matrix{Float64}.)\nenergy_boson(field[, conf = field.conf]) computes the bosonic energy associated with a given configuration. This is mandatory for global updates.","category":"page"},{"location":"DQMC/lattice/#Lattices-1","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"A lattice as we implement it describes a collection of sites in space, connected by bonds.","category":"page"},{"location":"DQMC/lattice/#Interface-1","page":"Lattices","title":"Interface","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"There are a few functions defined for lattices which you may find useful. ","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"position(lattice) returns an iterator which produces all site position of the lattice. When collected, this will create a D+1 dimensional array for a D dimensional lattice, where the first index represents the basis and the following represent the extend along the different lattice vectors.\nbonds(lattice[, directed = Val(false)]) returns an iterator which produces all bonds of the lattice. If directed = Val(false) bonds will be assumed to be directionless, meaning that only one of 1 to 2 and 2 to 1 will be returned. If directed = Val(true) both bonds will be generated.\nbond_open(lattice[, directed = false) returns an iterator which filters out periodic bonds which might be useful for plotting.\nbonds(lattice, site::Int) returns an iterator which produces bonds starting from site.\nlattice_vectors(lattice) returns the lattice vectors of the lattice. (These are the vectors v_i in R = v_1 i_1 + v_2 i_2 + v_3 i_3, i.e.e the vectors that generate the periodic Bravais lattice.)\nreciprocal_vectors(lattice) returns the Fourier transformed lattice vectors.\nlength(lattice) returns the total number of sites in the lattice.\nsize(lattice) returns the size of the lattice starting with the number of basis sites. \neachindex(lattice) returns a 1:length(lattice)\nBravais(lattice) returns a wrapped lattice for which the above methods ignore the basis. For example positions(Bravais(lattice)) will return an iterator of all Bravais lattice positions.","category":"page"},{"location":"DQMC/lattice/#Implementing-your-own-lattice-1","page":"Lattices","title":"Implementing your own lattice","text":"","category":"section"},{"location":"DQMC/lattice/#LatticePhysics.jl-1","page":"Lattices","title":"LatticePhysics.jl","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"LatticePhysics.jl already has a lot of common lattices implemented, which can be converted to MonteCarlo.jl lattices. For this you simple need to call MonteCarlo.Lattice(lattice_physics_lattice). Note that the reverse is also implemented as LatPhysBase.Lattice(mc_lattice).","category":"page"},{"location":"DQMC/lattice/#MonteCarlo.jl-1","page":"Lattices","title":"MonteCarlo.jl","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"If neither MonteCarlo.jl nor LatticePhysics.jl implements the lattice you need, you can implement your own through a custom constructor. This process is very similar between both libraries. Let us take the implementation for the Honeycomb lattice as an example:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"function Honeycomb(Lx, Ly = Lx)\n    uc = UnitCell(\n        # Name\n        \"Honeycomb\",\n        # lattice vectors\n        (Float64[sqrt(3.0)/2, -0.5], Float64[sqrt(3.0)/2, +0.5]),\n        # basis\n        [Float64[0.0, 0.0], Float64[1/sqrt(3.0), 0.0]],\n        # bonds\n        [\n            Bond(1, 2, (0, 0)), Bond(1, 2, (-1, 0)), Bond(1, 2, (0, -1)),\n            Bond(2, 1, (0, 0)), Bond(2, 1, ( 1, 0)), Bond(2, 1, (0,  1)),\n        ]\n    )\n\n    return Lattice(uc, (Lx, Ly))\nend","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"As you can see the main task here is to create a fitting unit cell. In order, the unit cell constructors takes the following arguments.","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"The name of the lattice. This is used for printing and might be useful if you wish to restrict a model to a specific lattice.\nThe basis of the lattice. (The positions of sites within a unit cell.)\nThe lattice vectors, i.e. the vectors that generate the periodic Bravais lattice.\nThe bonds of the lattice. Each bond contains three values: The basis site the bond starts at, the basis site it ends at and the Bravais shift which allows a bond to connect to neighboring unit cell. ","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Note that bonds also have an integer label which can be used to differentiate them later. Note as well that the UnitCell constructor will generate missing bonds b to a if a to b exists.","category":"page"},{"location":"DQMC/lattice/#Lattice-Iterators-1","page":"Lattices","title":"Lattice Iterators","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Lattice Iterators are to some degree a backend component. They specify a way to iterate through the lattice, and are mainly used for DQMC measurements which frequently require specific pairings of sites. The iterators fall into three categories:","category":"page"},{"location":"DQMC/lattice/#DirectLatticeIterator-1","page":"Lattices","title":"DirectLatticeIterator","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"First we have DirectLatticeIterator. These iterators return just site indices, e.g. (source_index, target_index). The concrete implementations include:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"EachSiteAndFlavor iterates all indices from 1 to length(lattice) * nflavors(mc)\nEachSite iterates through eachindex(lattice)\nEachSitePair iterates through all possible pairs (i, j) where both i and j iterate eachindex(lattice).","category":"page"},{"location":"DQMC/lattice/#DeferredLatticeIterator-1","page":"Lattices","title":"DeferredLatticeIterator","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"The second category inherit from DeferredLatticeIterator. Iterators in this category produce two sets of indices, one which is used to access lattice sites and one which is used to access some output array. In this category we have:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"OnSite which also eachindex(lattice), but returns three indices (i, i, i) at each step.\nEachSitePairByDistance which iterates the same range as EachSitePair but returns (combined_idx, i, j) at each step. The combined_idx combines the index of source basis site, the target basis and an index corresponding to a Bravais lattice direction. The output array is generally assumed to be three dimensional, matching those indices.\nEachLocalQuadByDistance(directions) iterators through combinations of four sites s^prime leftarrow s rightarrow t rightarrow t^prime. The given directions are directional indices used to derive s^prime and t^prime from the current source and target site s and t. The full output of this iterator is (combined_idx, s, t, s', t'), where combined_idx includes the basis index of s, t, the direction s to t as well as the indices into directions for s to s^prime and t to t^prime.\nEachLocalQuadBySyncedDistance(directions) is the same as EachLocalQuadByDistance with the restriction that the directions s to s^prime and t to t^prime are the same. The combined_idx does contain an index t to t^prime as result.","category":"page"},{"location":"DQMC/lattice/#Wrappers-1","page":"Lattices","title":"Wrappers","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"The last category are wrappers around lattice iterators. They are used either to adjust the summation and further compress the output array, or to dispatch to different methods during measurement. The following are currently available:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Sum(iter) sets the output index to 1. This has the effect of summing all site combinations.","category":"page"},{"location":"devdocs/measurements/#Measurements-1","page":"Measurements","title":"Measurements","text":"","category":"section"},{"location":"devdocs/measurements/#Measurement-type-1","page":"Measurements","title":"Measurement type","text":"","category":"section"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"Measurements in DQMC are represented with","category":"page"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"struct DQMCMeasurement{F <: Function, GI, LI, FI, OT, T} <: AbstractMeasurement\n    greens_iterator::GI\n    lattice_iterator::LI\n    flavor_iterator::FI\n    kernel::F\n    observable::OT\n    temp::T\nend","category":"page"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"where observable is the permanent storage for measurement data and temp is used as temporary storage, i.e. for accumulating data in sums. The iterators specify which greens functions, sites and flavor indices go into a measurement. The kernel is a function that takes all the indices generated for one iteration and returns a measurement value for it. We'll go into more detail about the latter components when describing the call tree of a measurement, as they match up closely.","category":"page"},{"location":"devdocs/measurements/#Grouping-1","page":"Measurements","title":"Grouping","text":"","category":"section"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"In order to efficiently evaluate measurements, we want to avoid recalculating Greens function unnecessarily. Therefore we have a grouping step at the start of the simulation, which groups measurement by their greens iterator. This grouping is done by the generate_groups function in \"flavors/DQMC/measurements/generic.jl\". ","category":"page"},{"location":"devdocs/measurements/#Call-Tree-1","page":"Measurements","title":"Call Tree","text":"","category":"section"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"The call tree for measurements starts with a call to sweep_once! in \"flavors/DQMC/DQMC.jl\". From this point on, all functions down to kernel are implemented in \"DQMC/measurements/generic.jl\". Each stage handles one of the iterators of the call tree, with the final one calling the kernel.","category":"page"},{"location":"devdocs/measurements/#Greens-Iterator-Stage-1","page":"Measurements","title":"Greens Iterator Stage","text":"","category":"section"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"The first function in the call tree handles measurement.greens_iterators. A  greens iterators can be:","category":"page"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"nothing which implies that the Greens function is not necessary for the measurement and thus none is passed to the next stage.\nGreens() which produces the equal-time Greens function and passes it on to the next stage\nGreensAt(k, l) which generates a time displaced Greens function G(k l) = langle c(Deltatau k) c^dagger(Deltatau l) rangle to pass on\nTimeIntegral which implies integration over imaginary time, evaluated via a Riemann sum. For each element of the sum, the Greens functions G(0 0), G(0 l), G(l 0) and G(l l) are generated and passed on to the next stage.","category":"page"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"Since TimeIntegral also includes summation, we prepare measurement.temp at the start of this stage. This is done by the prepare! function. Similarly we end this stage with the finish! function, which applies normalization to the values accumulated in measurement.temp and then push!es them into measurement.observable.","category":"page"},{"location":"devdocs/measurements/#measure!-Stage-1","page":"Measurements","title":"measure! Stage","text":"","category":"section"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"This stage only exists to be compliant with the measurement interface.","category":"page"},{"location":"devdocs/measurements/#Lattice-and-Flavor-Iterator-Stage-1","page":"Measurements","title":"Lattice & Flavor Iterator Stage","text":"","category":"section"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"The lattice and flavor iterators both produce indices for indexing the greens function. You can find details about what each lattice iterator does in the  lattice docs. The iteration implementation is mostly in \"lattices/lattice_iterators.jl\", with some of it being in the measurement file. The flavor iterator is a simple value, range or vector, typically generated by FlavorIterator from \"flavors/DQMC/measurements/constructors/main.jl\".","category":"page"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"For each iteration, these iterators will produce a set of indices for the lattice and an index or set of indices for the flavor. These are then passed to the kernel, to evaluate the measurement for that configuration of sites and flavors. The result is then added to measurement.temp at another set of indices specified by the lattice iterator.","category":"page"},{"location":"devdocs/measurements/#Kernel-1","page":"Measurements","title":"Kernel","text":"","category":"section"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"The kernel is the final stage of a measurement. It essentially represents the Observable after Wicks theorem is applied, where expectation values of pairs of operators have been replaced by elements of the Greens function. On top of that there is some code to efficiently access the different matrix types present in MonteCarlo.jl","category":"page"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"","category":"page"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"The point of having all of these different stages is to make measurements more adjustable. For example, one can adjust the lattice iterator to switch between getting a Matrix containing every langle c_i c_j^dagger rangle or getting a vector, where matching r_i - r_j are summed.","category":"page"},{"location":"devdocs/measurements/#Restructure-1","page":"Measurements","title":"Restructure","text":"","category":"section"},{"location":"devdocs/measurements/#","page":"Measurements","title":"Measurements","text":"For some of the more verbose lattice iterators it is helpful to reorder the elements of the Greens function for fasting indexing. This is indicated by Restructure and done by restructure!. After this, the Greens function is indexed by with a site index and a directional index, rather than two site indices. Flavor indices remain unchanged through this process.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"(Image: logo)","category":"page"},{"location":"legacy/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is a Julia software library for the simulation of physical models by means of the Markov Chain Monte Carlo technique. The package implements classical and quantum Monte Carlo flavors which can be used to study spin systems, interacting fermions, and boson-fermion mixtures.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe documentation is out-of-date!","category":"page"},{"location":"legacy/#Included-models:-1","page":"Introduction","title":"Included models:","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Ising model\nAttractive Hubbard model","category":"page"},{"location":"legacy/#Included-Monte-Carlo-flavors-1","page":"Introduction","title":"Included Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Classical Monte Carlo\nDeterminant Quantum Monte Carlo (also known as auxiliary field Monte Carlo)","category":"page"},{"location":"legacy/#Included-lattices-1","page":"Introduction","title":"Included lattices","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Cubic lattices (chain, square, cube, ...)\nAny ALPS lattice","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Have a look at the Showcase section to get some inspiration.","category":"page"},{"location":"legacy/#Study-your-own-model-1","page":"Introduction","title":"Study your own model","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"A major idea behind the design of the package is convenient customization. Users should be able to define their own custom physical models (or extend existing ones) and explore their physics through Monte Carlo simulations. We hope that MonteCarlo.jl allows the user to put his focus on his physical model rather than tedious implementations of Monte Carlo schemes.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"To that end, each (quantum) Monte Carlo flavor has a well-defined model interfaces, i.e. a precise specification of mandatory and optional fields and methods. An example can be found here: Interface: Monte Carlo (MC). Practically, it makes sense to start by taking a look at the implementation of one of the predefined models.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"If you implement a custom model that might be worth being added to the collection of supplied models, please consider creating a pull request!","category":"page"},{"location":"legacy/#GitHub-1","page":"Introduction","title":"GitHub","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is open-source. The source code can be found on github. Criticism and contributions are very much welcome - just open an issue. For more details see the Contribution Guide.","category":"page"},{"location":"legacy/models/ising/#Ising-Model-1","page":"Ising model","title":"Ising Model","text":"","category":"section"},{"location":"legacy/models/ising/#Hamiltonian-1","page":"Ising model","title":"Hamiltonian","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"The famous Hamiltonian of the Ising model is given by","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"\\begin{align} \\mathcal{H} = -\\sum{\\langle i,j \\rangle} \\sigmai \\sigma_j , \\end{align}","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"where langle i j rangle indicates that the sum has to be taken over nearest neighbors.","category":"page"},{"location":"legacy/models/ising/#Creating-an-Ising-model-1","page":"Ising model","title":"Creating an Ising model","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"You can create an Ising model as follows,","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"model = IsingModel(; dims::Int=2, L::Int=8)","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"The following parameters can be set via keyword arguments:","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"dims: dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)\nL: linear system size","category":"page"},{"location":"legacy/models/ising/#Supported-Monte-Carlo-flavors-1","page":"Ising model","title":"Supported Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Monte Carlo (MC) (Have a look at the examples section below)","category":"page"},{"location":"legacy/models/ising/#Examples-1","page":"Ising model","title":"Examples","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model.","category":"page"},{"location":"legacy/models/ising/#Exports-1","page":"Ising model","title":"Exports","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"IsingModel.jl\"]","category":"page"},{"location":"legacy/models/ising/#MonteCarlo.IsingModel","page":"Ising model","title":"MonteCarlo.IsingModel","text":"Famous Ising model on a cubic lattice.\n\nIsingModel(; dims, L)\n\nCreate Ising model on dims-dimensional cubic lattice with linear system size L.\n\n\n\n\n\n","category":"type"},{"location":"legacy/models/ising/#MonteCarlo.IsingModel-Union{Tuple{Dict{Symbol, T}}, Tuple{T}} where T","page":"Ising model","title":"MonteCarlo.IsingModel","text":"IsingModel(params::Dict)\nIsingModel(params::NamedTuple)\n\nCreate an Ising model with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"legacy/models/ising/#Analytic-results-1","page":"Ising model","title":"Analytic results","text":"","category":"section"},{"location":"legacy/models/ising/#Square-lattice-(2D)-1","page":"Ising model","title":"Square lattice (2D)","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"The model can be solved exactly by transfer matrix method (Onsager solution). This gives the following results.","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Critical temperature: T_c = frac2ln1+sqrt2","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Magnetization (per site): m = left(1-leftsinh 2beta right^-4right)^frac 18","category":"page"},{"location":"legacy/models/ising/#Potential-extensions-1","page":"Ising model","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Arbitrary dimensions\nMagnetic field\nMaybe explicit J instead of implicit J=1\nNon-cubic lattices (just add lattice::AbstractLattice keyword)","category":"page"},{"location":"examples/ALF1/#Crosscheck-with-ALF-1","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The ALF project (Algorithms for lattice fermions) is a long running project implementing DQMC in Fortran. They have implemented various different models, lattices, stabilization methods and measurements. A relatively simple comparison for us will be the \"plain vanilla Hubbard model\" on a square lattice, which is close to but not exactly the same as our repulsive Hubbard model.","category":"page"},{"location":"examples/ALF1/#The-ALF-Simulation-1","page":"Crosscheck with ALF","title":"The ALF Simulation","text":"","category":"section"},{"location":"examples/ALF1/#Installation-1","page":"Crosscheck with ALF","title":"Installation","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The ALF project provides a python interface which we used for simplicity. For installation instructions see the link. At the time of writing pyALF is linked to ALF 2.0. (Specifically commit 82949f66065eff8214c0149c8be2d10d6d0a6822.)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"note: Note\nYou can also add a load path for pyALF temporarily in an active python session. Try import sys and sys.path.append('path/to/pyALF-ALF-2.0/').","category":"page"},{"location":"examples/ALF1/#Usage-1","page":"Crosscheck with ALF","title":"Usage","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"With python, pyALF and the necessary packages installed we can now setup and run simulations. In python, we run:","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"import os\nfrom py_alf import Simulation        # Interface with ALF\n\nsims = []                            # Vector of Simulation instances\nfor beta in [1.0, 6.0, 12.0]:        # Values of inverse temperature beta\n    sim = Simulation(\n        'Hubbard',                   # Hamiltonian\n        {                            # Model and simulation parameters for each Simulation instance\n        'Model': 'Hubbard',          #    Base model\n        'Lattice_type': 'Square',    #    Lattice type\n        'L1': 4,                     #    Lattice length in the first unit vector direction\n        'L2': 4,                     #    Lattice length in the second unit vector direction\n        'Checkerboard': False,       #    Whether checkerboard decomposition is used or not\n        'Symm': True,                #    Whether symmetrization takes place\n        'ham_T': 1.0,                #    Hopping parameter\n        'ham_U': 4.0,                #    Hubbard interaction\n        'ham_Tperp': 0.0,            #    For bilayer systems\n        'beta': beta,                #    Inverse temperature\n        'Ltau': 1,                   #    '1' for time-displaced Green functions; '0' otherwise \n        'NSweep': 100,                #    Number of sweeps per bin\n        'N_skip': 10,                #    skip 50 bins meaning 50x NSweep\n        'NBin': 60,                 #    Number of bins\n        'Dtau': 0.1,                 #    Only dtau varies between simulations, Ltrot=beta/Dtau\n        'Mz': True,                  #    If true, sets the M_z-Hubbard model: Nf=2, N_sum=1,\n        },                           #             HS field couples to z-component of magnetization\n        alf_dir=os.getenv('ALF_DIR', './ALF'), # Directory with ALF source code. Gets it from \n                                               # environment variable ALF_DIR, if present\n    )\n    sims.append(sim)\n\nsims[0].compile()                        # Compilation needs to be performed only once\n\nimport time\n\nprint(\"\\nRunning sims\\n\")\nfor i, sim in enumerate(sims):\n    t0 = time.time()\n    sim.run()                            # Perform the actual simulation in ALF\n    print(time.time() - t0)\n    \nprint(\"\\nAnalysis:\\n\")\nfor i, sim in enumerate(sims):\n    print(sim.sim_dir)                   # Directory containing the simulation output\n    sim.analysis()","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Let's briefly go over some of the options picked here. One noteworthy option is Symm. With it you can switch between a symmetric (True) and antisymmetric (False) Trotter decomposition. In MonteCarlo.jl we use the symmetric version so we should do so here too. Next we have Ltau. As mentioned in the comment this controls whether time displaced greens function are calculated, and by extension whether time displaced observables (susceptibilties) are calculated. We want to compare as much as possible so we set Ltau = 1. ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"And finally we have the combination of NSweep, N_skip and NBin. NSweep is the number of sweeps in a block, which is usually followed by a measurement. NBin sets how many of those blocks are executed and N_skip disables measurements for some number of blocks at the start. Thus we have the relations thermalization = NSweep * N_skip, sweeps = NSweep * (NBin - N_skip) and measure_rate = NSweep. ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Regarding the choices for NSweep, N_skip and NBin it is also important to discuss the model ALF implements and how it is implemented. As mentioned before it is not quite the same as the repulsive Hubbard model from DQMC. ALF implements","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"mathcalH=\n- t sumlimits_langle i j rangle  sigma=uparrowdownarrow \nleft(  hatc^dagger_i sigma hatc^phantomdagger_jsigma  + textHc right) \n- fracU2sumlimits_ileft\nhatc^dagger_i uparrow hatc^phantomdagger_i uparrow  -   hatc^dagger_i downarrow hatc^phantomdagger_i downarrow  right^2   \n-  mu sum_isigma  hatc^dagger_i sigma  hatc^phantomdagger_isigma ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"which features a quadratic interaction rather than the sim (n_uparrow - 05)(n_downarrow - 05) term used in MonteCarlo.jl. If we apply a Hirsch transformation (like in MonteCarlo.jl) to both of these interactions, we end up with the same expression. Thus they would be the same from the simulations point of view. However ALF uses a different, (potentially) more precise transformation based on Gauß-Hermite quadrature. Thus some small differences are to be expected.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"For more information on the Hamiltonian and transformation used by ALF see the ALF documentation","category":"page"},{"location":"examples/ALF1/#The-MonteCarlo.jl-Simulation-1","page":"Crosscheck with ALF","title":"The MonteCarlo.jl Simulation","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The MonteCarlo.jl simulation should more or less mirror the options picked for ALF. We run ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"using Revise, MonteCarlo, Printf, LinearAlgebra\n\nmcs = []\n@time for beta in [1.0, 6.0, 12.0]\n    m = HubbardModel(4, 2, U = -4.0)\n    # There are propagation errors on the scale of 10^-7 - 10^-6 which produce\n    # frequent warnings without silent = true\n    mc = DQMC(\n        m, beta=beta, thermalization=5_000, sweeps=15_000, \n        print_rate=5_000, delta_tau = 0.1, measure_rate=1,\n        field = MagneticGHQField, safe_mult = 10, silent = true\n    )\n    \n    # our default versions\n    mc[:G] = greens_measurement(mc, m)\n    mc[:SDCz] = spin_density_correlation(mc, m, :z)\n    mc[:SDSz] = spin_density_susceptibility(mc, m, :z)\n    mc[:T] = kinetic_energy(mc, m)\n    # charge density correlations in ALF only consider the correlated part\n    mc[:DenDen] = charge_density_correlation(mc, m, kernel = MonteCarlo.reduced_cdc_kernel)\n    mc[:DenDenTau] = charge_density_susceptibility(mc, m, kernel = MonteCarlo.reduced_cdc_kernel)\n\n    # ALF defines our I - G as the measured Greens function\n    function mygreens(mc, m, ij, G, flv)\n        i, j = ij\n        return I[i, j] - G.val.blocks[flv][j, i]\n    end\n    mc[:Gr] = MonteCarlo.Measurement(\n        mc, m, Greens(), EachSitePairByDistance(), 1:2, mygreens\n    )\n    \n    # The interaction energy needs to be adjusted to ALF's Hamiltonian\n    function my_intE(mc, m, idxs, G, flv)\n        E = 0.0; N = length(lattice(mc))\n        Gup, Gdown = G.val.blocks\n        for i in 1:N\n            E += (1 - Gup[i, i]) * (1 - Gdown[i, i])\n        end\n        m.U * E\n    end\n    mc[:V] = MonteCarlo.Measurement(mc, m, Greens(), nothing, nothing, my_intE)\n    \n    function myGk(mc, m, ij, Gs, flv)\n        G00, G0l, Gl0, Gll = Gs; \n        i, j = ij\n        0.5 * Gl0.val.blocks[flv][i, j]\n    end\n    mc[:IGk] = MonteCarlo.Measurement(\n        mc, m, TimeIntegral(mc), EachSitePairByDistance(), 1:2, myGk\n    )\n    \n    run!(mc)\n    push!(mcs, mc)\nend","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"With the given parameters the simulations will take about 6min. This can be reduced further by cutting down on the number of sweeps or the measure_rate at the cost of accuracy.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"A few observables we measure have been adjusted to match ALF. First we have the real space equal time Greens function :Gr which measures delta(Delta r) - G(Delta r) = sum_r c_r^dagger c_r + Delta r. The MonteCarlo.jl Greens function is given as c c^dagger, so we need to swap the operator order. This can be done with swapop(G)[i + (flv-1)*N, j + (flv-1)*N] or more efficiently with I[i, j] - G.val.blocks[flv][j, i]. The former works for any matrix type, but calls slow custom indexing. The latter is specialized for BlockDiagonal matrices, which we have in this case. flv represents the spin index which results in a shift by N (number of sites) in the first case and access to the second block in the latter.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Next we have the interaction energy :V which needs adjustments to the different pre-transformation term ALF uses. We calculate langle V rangle = fracU2 sum_i langle V_i rangle where ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"langle V_i rangle = langle\nhatc^dagger_i uparrow hatc^phantomdagger_i uparrow hatc^dagger_i uparrow hatc^phantomdagger_i uparrow\n- hatc^dagger_i uparrow hatc^phantomdagger_i uparrow hatc^dagger_i downarrow hatc^phantomdagger_i downarrow\n- hatc^dagger_i downarrow hatc^phantomdagger_i downarrow hatc^dagger_i uparrow hatc^phantomdagger_i uparrow\n+ hatc^dagger_i downarrow hatc^phantomdagger_i downarrow hatc^dagger_i downarrow hatc^phantomdagger_i downarrow\nrangle","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Each term needs to be Wicks-expanded","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nlangle V_i rangle = phantom- \nlangle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle langle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle\n+ langle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle langle hatc^phantomdagger_i uparrow hatc^dagger_i uparrow rangle\n- langle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle\n- langle hatc^dagger_i uparrow hatc^phantomdagger_i downarrow rangle langle hatc^phantomdagger_i uparrow hatc^dagger_i downarrow rangle \n- langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle langle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle\n- langle hatc^dagger_i downarrow hatc^phantomdagger_i uparrow rangle langle hatc^phantomdagger_i downarrow hatc^dagger_i uparrow rangle\n+ langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle\n+ langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle langle hatc^phantomdagger_i downarrow hatc^dagger_i downarrow  rangle\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"so it can be exchanged by Greens function elements","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nlangle V_i rangle = phantom-\n  (I - G_ii^uparrow uparrow) (I - G_ii^uparrow uparrow)\n+ (I - G_ii^uparrow uparrow) G_ii^uparrow uparrow\n- (I - G_ii^uparrow uparrow) (I - G_ii^downarrow downarrow)\n- (I - G_ii^downarrow uparrow) G_ii^uparrow downarrow \n- (I - G_ii^downarrow downarrow) (I - G_ii^uparrow uparrow)\n- (I - G_ii^uparrow downarrow) G_ii^downarrow uparrow\n+ (I - G_ii^downarrow downarrow) (I - G_ii^downarrow downarrow)\n+ (I - G_ii^downarrow downarrow) G_ii^downarrow downarrow\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Next we make use of the symmetries of the model. Specifically that we do not have mixed spin terms, i.e. G_ij^sigma sigma^prime = 0 if sigma ne sigma^prime. We can also replace I by 1 in the remaining cases as both spin and site index are equal. We get","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nlangle V_i rangle = phantom-\n  (1 - G_ii^uparrow uparrow) (1 - G_ii^uparrow uparrow)\n+ (1 - G_ii^uparrow uparrow) G_ii^uparrow uparrow\n- (1 - G_ii^uparrow uparrow) (1 - G_ii^downarrow downarrow) \n- (1 - G_ii^downarrow downarrow) (1 - G_ii^uparrow uparrow)\n+ (1 - G_ii^downarrow downarrow) (1 - G_ii^downarrow downarrow)\n+ (1 - G_ii^downarrow downarrow) G_ii^downarrow downarrow\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"which we simplify further by using x = 1 - (1 - x).","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nlangle V_i rangle = \n(1 - G_ii^uparrow uparrow) + (1 - G_ii^downarrow downarrow) \n- 2 (1 - G_ii^uparrow uparrow) (1 - G_ii^downarrow downarrow) \n= G_ii^uparrow uparrow + G_ii^downarrow downarrow\n- 2 G_ii^uparrow uparrow G_ii^downarrow downarrow\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"This is however not what ALF implements as the potential energy. Instead of the above, ALF uses","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nfrac12 langle V_i rangle = (1 - G_ii^uparrow uparrow) (1 - G_ii^downarrow downarrow) \n= 1 - G_ii^uparrow uparrow - G_ii^downarrow downarrow\n+ G_ii^uparrow uparrow G_ii^downarrow downarrow\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"which is implemented above. Finally that we have the Fourier transformed time displaced Greens function :IGk which calculates the Fourier transform of G^prime(Delta r) = int_0^beta sum_r c_r(tau) c_r + Delta r^dagger(0) dtau. ","category":"page"},{"location":"examples/ALF1/#Loading-ALF-Data-1","page":"Crosscheck with ALF","title":"Loading ALF Data","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"ALF will generate a folder with multiple files for each measurement. You should find these in your pyALF directory under ALF_data. To load everything you need to compare results we run","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"using Statistics\np = \"path/to/ALF_data\"\nfolders = [\n    \"Hubbard_Square_L1=4_L2=4_Checkerboard=False_Symm=True_T=1.0_U=4.0_Tperp=0.0_beta=1.0_Dtau=0.1_Mz=True\",\n    \"Hubbard_Square_L1=4_L2=4_Checkerboard=False_Symm=True_T=1.0_U=4.0_Tperp=0.0_beta=6.0_Dtau=0.1_Mz=True\",\n    \"Hubbard_Square_L1=4_L2=4_Checkerboard=False_Symm=True_T=1.0_U=4.0_Tperp=0.0_beta=12.0_Dtau=0.1_Mz=True\",\n]\n\n# equal time Greens\ndirs = []\nGs = []\ndGs = []\n\n# other equal time observables\nTs = []      # SpinT ~ 4 * (sx + sy + sz) / 3\ndTs = []\nSDCxys = []  # SpinXY ~ 2 * (sx + sy)\ndSDCxys = []\nSDCzs = []   # SpinZ ~ 4 * sz\ndSDCzs = []\nCDCs = []    # Den\ndCDCs = []\nCDCks = []    # Den\ndCDCks = []\n\n# Energies\nKs = []\ndKs = []\nVs = []\ndVs = []\nEs = []\ndEs = []\n\n# unequal time\nks = []\nGks = []\ndGks = []\nCDCts = []    # Den\ndCDCts = []\nSDSzs = []   # SpinZ ~ 4 * sz\ndSDSzs = []\n\nfunction read_scal(filename)\n    open(filename, \"r\") do f\n        data = map(eachline(f)) do line\n            parts = filter(x -> !isempty(x), split(line, r\" +\"))\n            parse(Float64, split(parts[2], ',')[1][2:end])\n        end\n        mean(data), std(data) / sqrt(length(data))\n    end\nend\n\nfunction readJR(filename)\n    open(filename, \"r\") do f\n        data = map(eachline(f)) do line\n            parse.(Float64, filter(x -> !isempty(x), split(line, r\" +\")))\n        end\n        drs = data[1:2:end]\n        ys = getindex.(data[2:2:end], 3)\n        dys = getindex.(data[2:2:end], 4)\n        drs, ys, dys\n    end\nend\n\nfunction read_tauJK(filename)\n    open(filename, \"r\") do f\n        data = map(eachline(f)) do line\n            parse.(Float64, filter(x -> !isempty(x), split(line, r\" +\")))\n        end\n        dks = [d[1:2] for d in data]\n        gs = [ComplexF64(d[3], d[5]) for d in data]\n        dgs = [ComplexF64(d[4], d[6]) for d in data]\n        dks, gs, dgs\n    end\nend\n\n\nfor folder in folders\n    drs, gs, dgs = readJR(joinpath(p, folder, \"Green_eqJR\"))\n    if isempty(dirs)\n        push!(dirs, drs)\n    else\n        @assert dirs[end] == drs\n    end\n    push!(Gs, gs)\n    push!(dGs, dgs)\n    \n    drs, cdcs, dcdcs = readJR(joinpath(p, folder, \"Den_eqJR\"))\n    @assert dirs[end] == drs\n    push!(CDCs, cdcs)\n    push!(dCDCs, dcdcs)\n     \n    drs, ts, dts = readJR(joinpath(p, folder, \"SpinT_eqJR\"))\n    @assert dirs[end] == drs\n    push!(Ts, ts)\n    push!(dTs, dts)\n    \n    drs, sdcxys, dsdcxys = readJR(joinpath(p, folder, \"SpinXY_eqJR\"))\n    @assert dirs[end] == drs\n    push!(SDCxys, sdcxys)\n    push!(dSDCxys, dsdcxys)\n    \n    drs, sdczs, dsdczs = readJR(joinpath(p, folder, \"SpinZ_eqJR\"))\n    @assert dirs[end] == drs\n    push!(SDCzs, sdczs)\n    push!(dSDCzs, dsdczs)\n    \n    dks, gks, dgks = readJR(joinpath(p, folder, \"Den_eqJK\"))\n    if isempty(ks)\n        push!(ks, dks)\n    else\n        @assert ks[end] == dks\n    end\n    push!(CDCks, gks)\n    push!(dCDCks, dgks)\n    \n    dks, gks, dgks = read_tauJK(joinpath(p, folder, \"Green_tauJK\"))\n    @assert ks[end] == dks\n    push!(Gks, gks)\n    push!(dGks, dgks)\n    \n    dks, gks, dgks = read_tauJK(joinpath(p, folder, \"Den_tauJK\"))\n    @assert ks[end] == dks\n    push!(CDCts, gks)\n    push!(dCDCts, dgks)\n        \n    dks, gks, dgks = read_tauJK(joinpath(p, folder, \"SpinZ_tauJK\"))\n    @assert ks[end] == dks\n    push!(SDSzs, gks)\n    push!(dSDSzs, dgks)\n    \n    \n    e, de = read_scal(joinpath(p, folder, \"Kin_scal\"))\n    push!(Ks, e)\n    push!(dKs, de)\n    \n    e, de = read_scal(joinpath(p, folder, \"Pot_scal\"))\n    push!(Vs, e)\n    push!(dVs, de)\n    \n    e, de = read_scal(joinpath(p, folder, \"Ener_scal\"))\n    push!(Es, e)\n    push!(dEs, de)\nend\n\nmc_drs = MonteCarlo.directions(mcs[1] |> lattice)\nidxs = map(v -> findfirst(isequal(v), dirs[1]), mc_drs)\nidxs[end-1] = 13","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The only thing worth mentioning here is the order of offset vectors Delta r. The order of observable values is linked to these vectors, whose order differs between MonteCarlo.jl and ALF. To adjust the order we compute idxs here. Note that because we work with periodic lattices there are multiple valid options for some of these vectors. Because of this we set one index explicitly. ","category":"page"},{"location":"examples/ALF1/#Comparing-the-results-1","page":"Crosscheck with ALF","title":"Comparing the results","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"To compare the results we will plot points over each other. Most observables have the same layout, i.e. values vs either spatial or reciprocal distance vectors. We will plot these with the following functions.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"using CairoMakie, LaTeXStrings, LinearAlgebra\nimport MonteCarloAnalysis # fourier transform\n\nfunction plot_by_distance(\n        ys, dys, key; \n        idxs = idxs, xs = 1:16, xticks = map(v -> \"[$(v[1]), $(v[2])]\", mc_drs), \n        ylabel, legend_pos = :rt\n    )\n\n    fig = Figure(figure_padding = (10, 20, 10, 10))\n    ax = Axis(fig[1, 1], xlabel = L\"Distance $\\Delta r$\", ylabel = ylabel)\n\n    cs = (:blue, :purple, :red)\n    for l in 1:3 # temperature index\n        band!(ax, xs, ys[l][idxs] .- dys[l][idxs], ys[l][idxs] .+ dys[l][idxs], color = (cs[l], 0.1))\n        scatter!(ax, xs, ys[l][idxs], color = cs[l], marker='+', markersize=12)\n\n        low  = real(mean(mcs[l][key]) .- try std_error(mcs[l][key]) catch e; 0.0 end)\n        high = real(mean(mcs[l][key]) .+ try std_error(mcs[l][key]) catch e; 0.0 end)\n        band!(ax, xs[:], low[:], high[:], color = (cs[l], 0.1))\n        scatter!(ax, xs, mean(mcs[l][key])[:], color = cs[l], marker='x', markersize=12)\n    end\n\n    lbls = [\n        \"β = 1\", \"β = 1\",\n        \"β = 6\", \"β = 6\",\n        \"β = 12\", \"β = 12\"\n    ]\n    axislegend(ax, ax.scene.plots[3:2:end], lbls, \"  ALF    MonteCarlo.jl\", nbanks=2, position = legend_pos)\n\n    ax.xticks[] = (xs, xticks)\n    ax.xticklabelrotation[] = -0.7\n\n    # to fix bad spacing, likely unnecessary in the near future\n    ax.xlabelpadding[] = 10\n    \n    fig, ax\nend\n\nfunction plot_reciprocal(\n        ys, dys, key; \n        xs = 1:16, ylabel, legend_pos = :rt,\n        xticks = labels = map(ks[1]) do k\n            pieces = map(k) do x\n                if x ≈ 0.5f0 * pi;       \"π/2\"\n                elseif x ≈ 1f0 * pi;     \"π\"\n                elseif x ≈ -0.5f0 * pi;  \"-π/2\"\n                elseif x ≈ 0.0;          \"0\"\n                else;                    \"$x\"\n                end\n            end\n            \"[\" * join(pieces, \", \") * \"]\"\n        end\n    )\n\n    fig = Figure(figure_padding = (10, 20, 10, 10))\n    ax = Axis(fig[1, 1], xlabel = L\"Reciprocal Vector $\\Delta k$\", ylabel = ylabel)\n\n    cs = (:blue, :purple, :red)\n    for l in 1:3 # temperature index\n        low  = real(real(ys[l]) .- real(dys[l]))\n        high = real(real(ys[l]) .+ real(dys[l]))\n        band!(ax, xs, low, high, color = (cs[l], 0.1))\n        scatter!(ax, xs, real(ys[l]), color = cs[l], marker='+', markersize=12)\n\n        _ys = let\n            m = mcs[l][key]\n            fourier(ks[1], directions(lattice(mcs[l]), m.lattice_iterator), mean(m))\n        end\n        _dys = map(1:16) do j\n            vals = std_error(mcs[l][key])[:]\n            dirs = directions(lattice(mcs[l]))\n            q = ks[1][j]\n            sum((cis(dot(q, v)) * o)^2 for (v, o) in zip(dirs, vals)) |> mean |> sqrt\n        end\n\n        low  = real(_ys .- _dys)\n        high = real(_ys .+ _dys)\n        band!(ax, xs, low, high, color = (cs[l], 0.1))\n        scatter!(ax, xs, real(_ys), color = cs[l], marker='x', markersize=12)\n    end\n\n    lbls = [\n        \"β = 1\", \"β = 1\",\n        \"β = 6\", \"β = 6\",\n        \"β = 12\", \"β = 12\"\n    ]\n    axislegend(ax, ax.scene.plots[3:2:end], lbls, \"  ALF    MonteCarlo.jl\", nbanks=2, position = legend_pos)\n\n    ax.xticks[] = (xs, xticks)\n    ax.xticklabelrotation[] = -0.7\n\n    # to fix bad spacing, likely unnecessary in the near future\n    ax.xlabelpadding[] = 10\n    \n    fig, ax\nend","category":"page"},{"location":"examples/ALF1/#Equal-time-Greens-function-1","page":"Crosscheck with ALF","title":"Equal time Greens function","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The equal time Greens function shows a clean overlap between the two libraries.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_by_distance(\n    Gs, dGs, :Gr, factor = 2.0, \n    ylabel = \"δ(Δr) - G(Δr) = ∑ᵣ ⟨c^†(r) c(r + Δr)⟩\"\n)\nMakie.save(\"equal_time_greens.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Time-displaced-Greens-function-1","page":"Crosscheck with ALF","title":"Time displaced Greens function","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"For the time-displaced Greens function the overlap becomes visibly less precise. This is likely a result of the different transformations used. Reducing Delta tau in MonteCarlo.jl decreases the error.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_reciprocal(\n    Gks, dGks, :IGk,\n    ylabel = \"Integrated Greens function ∑ₖ ∫ ⟨c(τ, k) c^†(0, k + Δk)⟩ dτ\"\n)\nMakie.save(\"time_displaced_greens.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Energies-1","page":"Crosscheck with ALF","title":"Energies","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"For the kinetic energy and interaction we only get one value per simulation so we just compare them numerically. In this case all values match with errors. The first group shows kinetic energy and the second interaction.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Inv. Temp. ALF MonteCarlo.jl  ALF MonteCarlo.jl\n1 -16.855 ± 0.005 -16.83 ± 0.07  8.775 ± 0.003 8.75 ± 0.03\n6 -21.107 ± 0.002 -21.00 ± 0.08  7.72  ± 0.02 7.64 ± 0.09\n12 -21.109 ± 0.002 -21.12 ± 0.09  7.538 ± 0.006 7.54 ± 0.05","category":"page"},{"location":"examples/ALF1/#Charge-Density-Correlations-1","page":"Crosscheck with ALF","title":"Charge Density Correlations","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Like the equal time Greens function the charge density matches close to exactly.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_by_distance(CDCs, dCDCs, :DenDen, ylabel = \"Charge Density Correlation ∑ᵣ ⟨n(r) n(r + Δr)⟩\")\nMakie.save(\"charge_density_correlation.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Charge-Density-Susceptibility-1","page":"Crosscheck with ALF","title":"Charge Density Susceptibility","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The charge susceptibility shows some larger errors but still matches fairly well. The errors we see here are generally smaller than what we saw in the integrated Greens function.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_reciprocal(\n    CDCts, dCDCts, :DenDenTau,\n    ylabel = \"Charge Density Susceptibility ∑ᵣ ∫ ⟨n(τ, r) n(0, r + Δr)⟩ dτ\"\n)\nMakie.save(\"charge_density_susceptibility.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Spin-Density-Correlation-1","page":"Crosscheck with ALF","title":"Spin Density Correlation","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Like the other equal time correlations spin density also fits almost exactly.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_by_distance(SDCzs, dSDCzs, :SDCz, ylabel = \"Spin Density Correlation ∑ᵣ ⟨s_z(r) s_z(r + Δr)⟩\")\nMakie.save(\"spin_density_correlation.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Spin-Density-Susceptibility-1","page":"Crosscheck with ALF","title":"Spin Density Susceptibility","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Like the other susceptibilities, this shows some larger deviations than its equal time variant but no qualitative difference from ALF.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"lbl = L\"Spin Density Susceptibility $\\sum_{r, r^\\prime} \\int_0^\\beta s_z(\\tau, r) s_z(0, r^\\prime) e^{i \\Delta k (r^\\prime - r)} d\\tau$\"\nfig, ax = plot_reciprocal(\n    SDSzs, dSDSzs, :SDSz, legend_pos = :lt,\n    ylabel = lbl\n)\nMakie.save(\"spin_density_susceptibility.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"DQMC/scheduler/#Update-Scheduler-1","page":"Update Scheduler","title":"Update Scheduler","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The update scheduler keeps track of and iterates through various Monte Carlo updates. Currently there are two schedulers, SimpleScheduler and AdaptiveScheduler, and five (full) updates.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"note: Note\nThis is a DQMC only feature at the moment.","category":"page"},{"location":"DQMC/scheduler/#Schedulers-1","page":"Update Scheduler","title":"Schedulers","text":"","category":"section"},{"location":"DQMC/scheduler/#SimpleScheduler-1","page":"Update Scheduler","title":"SimpleScheduler","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The SimpleScheduler keeps track of a sequence of updates and cycles through them as update(scheduler, mc, model) is called. It is constructed by simply passing a sequence of updates, i.e. SimpleScheduler(update1, update2, ...).","category":"page"},{"location":"DQMC/scheduler/#AdaptiveScheduler-1","page":"Update Scheduler","title":"AdaptiveScheduler","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The AdaptiveScheduler also has a static sequence of updates, but allows some of these updates to be Adaptive(). Any Adaptive() update in the sequence is replaced with an update from a pool based on their relative weights. These weights are derived from their acceptance rates with some lag.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"An adaptive scheduler is created with a sequence of updates and a pool of updates, i.e.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"sequence = (update1, Adaptive())\npool = (update2, update3)\nscheduler = AdaptiveScheduler(sequence, pool)","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Additionally there are a couple of keywords to configure how weights are adjusted.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"minimum_sampling_rate = 0.01: This defines the threshold under which the ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"sampling rate is set to 0.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"grace_period = 99: This sets a minimum number of times an update needs to ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"be called before its sampling rate is adjusted. ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"adaptive_rate = 9.0: Controls how fast the sampling rate is adjusted to the ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"acceptance rate. More means slower.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The adjustments of the sampling rate follow the formula \\begin{equation} \\frac{(adaptiverate * samplingrate + \\frac{accepted}{total} }{ adaptive_rate + 1 } \\end{equation}","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"note: Note\nAll schedulers wrap their updates in AcceptanceStatistics. This wrapper keeps track of the total number of update attempts and the number of accepted updates.","category":"page"},{"location":"DQMC/scheduler/#Updates-1","page":"Update Scheduler","title":"Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Updates are small or even empty structs used to dispatch to different update functions. They are assumed to implement name(::MyUpdate) = \"MyUpdate\" and a method update(::MyUpdate, mc, model). ","category":"page"},{"location":"DQMC/scheduler/#Local-Updates-1","page":"Update Scheduler","title":"Local Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Local updates affect one site at one time slice. In order for this to be on a similar scale as global and parallel updates, local updates should come in full sweeps. ","category":"page"},{"location":"DQMC/scheduler/#LocalSweep-1","page":"Update Scheduler","title":"LocalSweep","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Currently there is only one local update - LocalSweep([N=1]). It performs N standard sweeps of local updates, which means two updates per site and time slice each in DQMC. (Two because we go from tau = 0 to tau = beta back to tau = 0.) This update returns a float corresponding to its internal acceptance rate accepted  (2 N_sites cdot M_slices)","category":"page"},{"location":"DQMC/scheduler/#Global-Updates-1","page":"Update Scheduler","title":"Global Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Global updates affect not just one site at one time slice, but most if not all sites at all time slices. In other words they attempt to adjust the full configuration. We currently have the following global updates.","category":"page"},{"location":"DQMC/scheduler/#GlobalFlip-1","page":"Update Scheduler","title":"GlobalFlip","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The GlobalFlip() proposes a flip of the full configuration, i.e. pm 1 to mp 1.","category":"page"},{"location":"DQMC/scheduler/#GlobalShuffle-1","page":"Update Scheduler","title":"GlobalShuffle","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"GlobalShuffle() performs a shuffle(current_configuration) to generate a new configuration.","category":"page"},{"location":"DQMC/scheduler/#SpatialShuffle-1","page":"Update Scheduler","title":"SpatialShuffle","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"SpatialShuffle shuffles only the spatial part of a configuration. This means that if two sites are swapped, they are swapped the same way for all time slice indices.","category":"page"},{"location":"DQMC/scheduler/#TemporalShuffle-1","page":"Update Scheduler","title":"TemporalShuffle","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"TemporalShuffle shuffles only the imaginary time part of the configuration, meaning that the swap occurs for all lattice indices the same way.","category":"page"},{"location":"DQMC/scheduler/#Denoise-1","page":"Update Scheduler","title":"Denoise","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Denoise attempts to align the configuration in lattice space. Specifically, it sets each site to the majority value of its neighbors (including itself with a lower weight). Note that this update assumes configuration values pm 1. Also note that the new configuration is solely based on the old, i.e. it does not take changes of nearby sites into account. Because of this the update may not always push the configuration to a more uniform distribution.","category":"page"},{"location":"DQMC/scheduler/#DenoiseFlip-1","page":"Update Scheduler","title":"DenoiseFlip","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"DenoiseFlip follows the logic of Denoise, but flips the resulting configuration.","category":"page"},{"location":"DQMC/scheduler/#StaggeredDenoise-1","page":"Update Scheduler","title":"StaggeredDenoise","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"StaggeredDenoise follows the same logic as Denoise, but multiplies a factor pm 1 based on the lattice site index. ","category":"page"},{"location":"DQMC/scheduler/#Parallel-Updates-1","page":"Update Scheduler","title":"Parallel Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Parallel updates communicate between different simulations running on different workers. Note that these simulations must produce configurations of the same size, i.e. have same number of time slices and sites.","category":"page"},{"location":"DQMC/scheduler/#ReplicaExchange-1","page":"Update Scheduler","title":"ReplicaExchange","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The ReplicaExchange(target) update requires a target worker, and it requires that worker to be in sync. Specifically that means if worker 1 has a ReplicaExchange(2) followed by ReplicaExchange(3), worker 2 must have ReplicaExchange(1) as its first replica exchange update and worker 3 must have ReplicaExchange(1) as its second replica exchange update.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The idea of a replica exchange update is to propose swapping configurations between two simulations. The exchange is based on the product of both of their acceptance probabilities. With C_i the configuration of simulation i and w_i(C) the weight of simulation i with the given configuration the acceptance probability is given by","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"p = fracw_1(C_2)w_1(C_1) cdot fracw_2(C_1)w_2(C_2)","category":"page"},{"location":"DQMC/scheduler/#ReplicaPull-1","page":"Update Scheduler","title":"ReplicaPull","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"ReplicaPull() is an experimental parallel update. Instead of synchronizing with another simulations it pulls a configuration asynchronously and uses that for a global update. This means that there is little waiting on other simulations, but configurations will be duplicated.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"This update cycles through a pool of connected workers. This pool can be of any size. Each simulation must make itself available for pulling via connect(target_workers). The target_workers should generally be the workers the simulation wants to receive configurations from. When a simulation reaches the end it will automatically disconnect(target_workers).","category":"page"},{"location":"DQMC/scheduler/#MPI-Updates-1","page":"Update Scheduler","title":"MPI Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#MPIReplicaExchange-1","page":"Update Scheduler","title":"MPIReplicaExchange","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"This is a MPI version of the replica exchange update. In this case target is an MPI rank. Much like the normal replica exchange update simulations need to be paired such that they request updates from each other.","category":"page"},{"location":"DQMC/fields/#Fields-1","page":"Fields","title":"Fields","text":"","category":"section"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"In MonteCarlo.jl fields describe how to handle the interactive term(s) in a model/Hamiltonian. Currently we implement two transformations, the Hirsch transformation and a Gauß-Hermite Quadrature based approximation of the Hubbard Stratonovich transformation, each with a density- and spin-channel variant. ","category":"page"},{"location":"DQMC/fields/#Hirsch-Transformation-1","page":"Fields","title":"Hirsch Transformation","text":"","category":"section"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"The Hirsch transformation applies specifically to a Hubbard interaction U (n_iuparrow - 05) (n_idownarrow - 05). Each number operator can take the values 0 or 1, which allows us to rewrite the term as either 05 U (n_iuparrow + n_idownarrow - 1)^2 - 025 or 05 U (n_iuparrow - n_idownarrow)^2 + 025. These two cases are the density- and spin-channel respectively. The next step is to is to introduce a bosonic field x such that","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"e^UDelta tau left( n_iuparrow - frac12 right) left(n_idownarrow - frac12 right) \n= frac12 e^-frac14 Delta tau U sum_x=pm 1 e^alpha x (n_iuparrow + n_idownarrow - frac12)","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"or","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"e^UDelta tau left( n_iuparrow - frac12 right) left(n_idownarrow - frac12 right) \n= frac12 e^-frac14 Delta tau U sum_x=pm 1 e^alpha x (n_iuparrow - n_idownarrow)","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"For both of these cases we define a positive U as the attractive case. The constant alpha = acosh(exp(05 Deltatau U)) in the attractive case and alpha = acosh(exp(-05 Deltatau U)) in the repulsive case. Both of these can be verified by expanding the sum over x and going through the different possible values of the number operator n.","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"In MonteCarlo.jl the first case is implemented as DensityHirschField and the second as MagneticHirschField. Both can be used with positive and negative U, though alpha may become complex. This will of course influence performance. Furthermore the density channel is symmetric between spin up and down, which is used to reduced the size of matrices involved.","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"See Quantum Monte Carlo Methods","category":"page"},{"location":"DQMC/fields/#Gauß-Hermite-Quadrature-1","page":"Fields","title":"Gauß-Hermite Quadrature","text":"","category":"section"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"In this case we use Gaussian quadrature to approximate the integral generated by the Hubbard Stratonovich transformation. This is a more general approach than the Hirsch transformation, though we currently only have an implementation for Hubbard interactions.","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"We start of the same way as with the Hirsch transformation - by rewriting the our interaction as a squared term. Generally speaking we need to arrive at exp(-05Deltatau (c_i^dagger V_ij c_j + C)^2 + C^prime). Using the Hubbard Stratonovich transformation this becomes","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"e^-frac12Deltatau (c_i^dagger V_ij c_j + C)^2 + C^prime = e^-Deltatau C^prime frac1sqrt2pi int_-infty^infty e^-frac12x^2 pm x sqrtDeltatau (c_i^dagger V_ij c_j + C) dx","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"One method of solving this integral is Gauß-Hermite quadrature. With four weights and notes we get","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"frac1sqrt2pi int_-infty^infty e^-frac12x^2 pm x sqrtDeltatau (c_i^dagger V_ij c_j + C) dx = frac14 sum_x = pm 1 pm 2 gamma(x) e^sqrtDeltatau eta(x) (c_i^dagger V_ij c_j^dagger + C)","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"where gamma and eta give the weights and nodes for a given x. For the density-channel version V_uparrow = V_downarrow = sqrtU and C = 05 sqrtU, for the spin channel V_uparrow = - Vdownarrow = sqrtU and C = 0. These two cases are implemented as DensityGHQField and MagneticGHQField. Just like with the Hirsch field these two methods can create real or complex interaction matrices depending on the sign U and the Density case makes use of symmetry.","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"See ALF Documentation (Auxiliary Field Quantum Monte Carlo section) and the related paper.","category":"page"},{"location":"DQMC/fields/#Performance-and-Accuracy-1","page":"Fields","title":"Performance & Accuracy","text":"","category":"section"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"As a rough estimate of relative performance we can look at the runtime of a small Hubbard model (6x6 square lattice, beta = 1, 10 000 sweeps total):","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"Field Type U = +1 U = -1\nDensityHirschField 6.8s 23s\nMagneticHirschField 51s 17s\nDensityGHQField 6.2s 22s\nMagneticGHQField 46s 15s","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"As you can see the runtimes are relatively stable for the repulsive Hubbard model (negative U). This is because we either have to include spin up and down channels or work with complex matrices. In the attractive case both of these fall together. With a density-channel field we make use of spin symmetry and work with real matrices, but with a magnetic-channel field both of these slow us down dramatically.","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"In terms of accuracy none of these should technically have a big advantage over the other other in a Hubbard model. However this doesn't generally seem to be true in practice. In one model we had issues resolving occupations accurately with DensityHirschField and found that spin-channel fields do a better job of resolving most observables. The exception here are spin densities, which are resolved more cleanly by density-channel fields. Overall the MagneticGHQField gave the best results. ","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"In general it is probably a good idea to simulate a smaller system with all the different field options to see which yields the best combination of performance and accuracy.","category":"page"},{"location":"DQMC/model/#Models-1","page":"Model","title":"Models","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"In MonteCarlo.jl a Model describes a Hamiltonian. It's primary purpose is to collect paramaters from different terms in the Hamiltonian as well as the lattice and generate a hopping matrix for the simulation. We currently provide one model - the Hubbard model.","category":"page"},{"location":"DQMC/model/#Hubbard-Model-1","page":"Model","title":"Hubbard Model","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"The  Hubbard model is given by","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"mathcalH = -t sum_langle ij rangle sigma left( c^dagger_isigma c_jsigma + texthc right) - U sum_j left( n_juparrow - frac12 right) left( n_jdownarrow - frac12 right) - musum_j n_j","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"where sigma denotes spin, t is the hopping amplitude, U the on-site Hubbard interaction strength, mu the chemical potential and langle i j rangle indicates that the sum has to be taken over nearest neighbors. Note that the Hamiltonian is written in particle-hole symmetric form such that mu = 0 corresponds to half-filling.","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"Our implementation allows for both attractive (positive) and repulsive (negative) U. Note that for the repulsive case there is a sign problem for mu ne 0. The model also works with any lattice, assuming that lattice provides the required functionality. ","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"You can create a Hubbard model with HubbardModel(). Optional keyword arguments include:","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"l::AbstractLattice = choose_lattice(HubbardModel, dims, L) is the lattice used by the model. \ndims::Integer = 2 is the dimensionality of the default lattice (Chain/Square/Cubic)\nL::Integer = 2 is the linear system size of the default lattice (Chain/Square/Cubic)\nt::Float64 = 1.0 is the hopping strength.\nmu::Float64 = 0.0 is the chemical potential. (Must be 0 if U is negative.)\nU::Float64 = 1.0 is the interaction strength.","category":"page"},{"location":"DQMC/Introduction/#Determinant-Quantum-Monte-Carlo-1","page":"Introduction","title":"Determinant Quantum Monte Carlo","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"Determinant Quantum Monte Carlo is a Quantum Monte Carlo algorithm for fermionic Hamiltonians. The general idea is to use the Hubbard-Stranovich transformation to simplify any term with four fermionic operators to two. This comes at the cost of introducing a bosonic field which is sampled by a Monte Carlo procedure.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"The minimal working example for a DQMC simulation is the following.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"using MonteCarlo\n\ndqmc = DQMC(HubbardModel(), beta = 1.0)\nrun!(dqmc)","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"This will set up and run a DQMC simulation at inverse temperature beta = 10 using an attractive Hubbard model with a two by two square lattice. Of course this example is not very useful. In practice you will want to modify lots of parameters and components of the simulation. We give a brief overview of the different components here. You can also check the examples section for some more involved and realistic examples.","category":"page"},{"location":"DQMC/Introduction/#Model-1","page":"Introduction","title":"Model","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"The model is a description of the Hamiltonian. Currently MonteCarlo.jl only implements the HubbardModel which includes nearest neighbor hoppings, a chemical potential and the Hubbard interaction. One aim of this package is to make it simple to implement different models, though currently only Hubbard interactions are supported.","category":"page"},{"location":"DQMC/Introduction/#Lattice-1","page":"Introduction","title":"Lattice","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl provides its own lattice structure inspired by LatticePhysics.jl. The structure is generic, meaning that it should be possible to implement any lattice with it. Lattices are currently part of the model and the HubbardModel should work with any lattice. ","category":"page"},{"location":"DQMC/Introduction/#Field-1","page":"Introduction","title":"Field","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"The field defines how the interaction is handled, i.e. what Monte Carlo configurations look like, how the interactive term is interpreted and how updates work. We currently implement Hirsch fields and Gauß-Hermite Quadrature fields, both with a density- and magnetic-channel version. Any of these choices works with any choice of the Hubbard model, though performance and accuracy can vary.","category":"page"},{"location":"DQMC/Introduction/#Updates-1","page":"Introduction","title":"Updates","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"Beyond local updates we provide a selection of global and experimental parallel updates. Like models, this part is designed to be relatively easy to extend. Most global updates just generate a new configuration and call another function to accept or reject it.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"The updates themselves are collected in a scheduler. We currently provide two types of them - one which simply iterates through updates and one which adaptively favors updates with high acceptance rates.","category":"page"},{"location":"DQMC/Introduction/#Configuration-Recorder-1","page":"Introduction","title":"Configuration Recorder","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"We provide an interface to record configurations during a MonteCarlo run so that they can later be replayed. This interface also implements functionality for compressing configurations.","category":"page"},{"location":"DQMC/Introduction/#Measurements-1","page":"Introduction","title":"Measurements","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"We currently include measurements of the following observables:","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"Equal time Greens function (and to a less direct extend time displaced Greens functions)\noccupations\ncharge density correlations and susceptibilities\nmagnetization in x, y and z direction\nspin density correlations and susceptibilities in x, y and z direction\npairing correlation and susceptibility for generic symmetries\ncurrent current susceptibilities which are required for the superfluid stiffness (this can also be calculated more directly)\ntotal and partial energies (quadratic terms and quartic terms separated)","category":"page"},{"location":"DQMC/Introduction/#DQMC-1","page":"Introduction","title":"DQMC","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"The DQMC struct represents the full simulation. All the components above are collected here. It also contains a bunch paramters, such as the inverse temperature beta, the time step discretization delta_tau, the number of thermazition and measurements sweeps and more.","category":"page"},{"location":"DQMC/Introduction/#Derivation-1","page":"Introduction","title":"Derivation","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"If you are interested in the derivation of DQMC you may check Introduction to Quantum Monte Carlo Simulations for fermionic Systems, the book Quantum Monte Carlo Methods or World-line and Determinantal Quantum Monte Carlo Methods for Spins, Phonons and Electrons. The first reference is most in-line with the implementation of this package.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"If you want to go through the source code, compare it and verify for yourself that it is correct there a couple of things that should be pointed out. Most educational sources use the asymmetric two term Suzuki-Trotter decomposition. We use the symmetric three term version for increased accuracy.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"B(l) = e^-Deltatau sum_l T+V(l) = prod_j e^-Deltatau T2 e^-Deltatau V e^-Deltatau T2 + mathcalO(Deltatau^2)","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"This change is however no trivial as the first or last element of the B matrix/operator needs to be an exponentiated interaction. To get this we use an effective greens function, which cyclically permutes one exponentiation hopping term to the other end of the chain. This adjustment needs to be undone for the actual greens function, which happens in greens().","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"Another thing worth mentioning is that depending on the choices made at the start of the derivation, matrix products may have different order and indices may vary. The first source should have the same definitions.","category":"page"},{"location":"examples/triangular_Hubbard/#Triangular-Attractive-Hubbard-1","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"This example implements the model from the paper Attractive Hubbard model on a triangular lattice. This also serves as a cross-check for the DQMC and a few measurements, such as pairing correlations and occupations. ","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The summarized code for this example can be found under \"MonteCarlo/docs/src/examples\".","category":"page"},{"location":"examples/triangular_Hubbard/#Simulation-1","page":"Triangular Attractive Hubbard","title":"Simulation","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"In the paper simulations were done with a rather low 500-1000 sweeps and Deltatau = 0125. Occupations are measured the same way as in MonteCarlo.jl. Pairing correlations seem to use Delta Delta^dagger rather than the Delta^dagger Delta + Delta Delta^dagger given in the paper. The latter is the default in MonteCarlo.jl. To get the former we need to explicitly pass kernel = MonteCarlo.pc_kernel to the relevant measurement constructor.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The first figure is done with interaction strength U = -4, linear system size L = 4 at beta = 2 5 7 for varying mu. The following simulations should take about 2 minutes. Note that at this number of sweeps you may still see some spikes in the data.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"using MonteCarlo\n\nbetas = (2.0, 5.0, 7.0)\nmus = vcat(-2.0, -1.5, -1.25:0.05:-1.0, -0.8:0.2:0.8, 0.9:0.05:1.25, 1.5, 2.0)\nl = TriangularLattice(4)\n\ndqmcs = []\ncounter = 0\nN = length(mus) * length(betas)\n@time for beta in betas, mu in mus\n    counter += 1\n    print(\"\\r[\", lpad(\"$counter\", 2), \"/$N] \")\n\n    # Setup Simulation\n    # Note that the pairing correlation formula used the paper is not the \n    # one MonteCarlo.jl uses by default, so we switch to the correct \n    # version via `kernel = MonteCarlo.pc_kernel`\n    m = HubbardModel(l = l, t = 1.0, U = 4.0, mu = mu)\n    dqmc = DQMC(\n        m, beta = beta, delta_tau = 0.125, safe_mult = 8, \n        thermalization = 1000, sweeps = 1000, measure_rate = 1,\n        recorder = Discarder()\n    )\n    dqmc[:occ] = occupation(dqmc, m)\n    dqmc[:PC] = pairing_correlation(dqmc, m, kernel = MonteCarlo.pc_kernel)\n\n    # Thermalize & measure\n    run!(dqmc, verbose = false)\n\n    # for simplicity we just keep the whole simulation around\n    push!(dqmcs, dqmc)\nend","category":"page"},{"location":"examples/triangular_Hubbard/#Processing-Data-1","page":"Triangular Attractive Hubbard","title":"Processing Data","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"After running all the simulations we need to do a bit of post-processing on the measured data. ","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"# Extract points for plots\nN = length(mus)\noccs = []\nΔoccs = []\npcs = []\nΔpcs = []\n\nfor i in 0:length(betas)-1\n    # MonteCarlo.jl records occupations for each site in a LogBinner from \n    # BinningAnalysis.jl. The paper plots the average per site occupation.\n    # This iterates through the simulations, picks the occupation \n    # measurement, calculates first the Monte Carlo average or standard \n    # error and second the site average. The factor then maps 0..1 \n    # occupations to 0..2 occupations. (spin up + spin down)\n    _occs = [2 * mean(mean(dqmcs[N*i + j][:occ])) for j in 1:N]\n    doccs = [2 * mean(std_error(dqmcs[N*i + j][:occ])) for j in 1:N]\n    push!(occs, _occs)\n    push!(Δoccs, doccs)\n\n    # For Pairing correlations the MonteCarlo representation is more \n    # complicated. For pairing correlations we consider 4 sites:\n    #    (trg1, b1) ---- (src1, b1) ----- (src2, b2) ---- (trg2, b2)\n    #               dir1            dir12            dir2\n    # where b is a basis index, src and trg are Bravais site indices and\n    # dir is a Bravauis direction between them. This is represented in \n    # MonteCarlo.jl by EachLocalQuadByDistance. The output of the \n    # measurement takes the form of a 5D tensor:\n    #    PC[dir12, dir1, dir2, b1, b2]\n    # To get the local s-wave pairing correlation used in the paper, we \n    # want dir1 = dir2 = 1. Since the triangular lattice has only one site \n    # per unit cell b1 = b2 = 1. And finally the paper considers the q = 0\n    # pairing correlation, which is given by summing over dir12.\n    _pcs = [sum(mean(dqmcs[N*i + j][:PC])[:, 1, 1, 1, 1]) for j in 1:N]\n    dpcs = [sum(std_error(dqmcs[N*i + j][:PC])[:, 1, 1, 1, 1]) for j in 1:N]\n    push!(pcs, _pcs)\n    push!(Δpcs, dpcs)\nend","category":"page"},{"location":"examples/triangular_Hubbard/#Plotting-1","page":"Triangular Attractive Hubbard","title":"Plotting","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"With the data in a processed form we can now plot it. To make comparison easier, we plot our data directly over figure 1 from our reference.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"using CairoMakie, FileIO, Colors, LaTeXStrings\n\n# Create layout\nfig = Figure(resolution = (800, 800))\ntop = Axis(fig[1, 1], ylabel = L\"\\rho\", ylabelsize = 30)\nbot = Axis(fig[2, 1], xlabel = L\"\\mu\", ylabel = L\"P_s\", xlabelsize = 30, ylabelsize = 30)\n\n# Load and plot reference image from paper as the background\np = pkgdir(MonteCarlo)\ntop_ref = FileIO.load(joinpath(p, \"docs/src/examples/assets/triangular/tri_Hub_ref1_1.png\"))\nbot_ref = FileIO.load(joinpath(p, \"docs/src/examples/assets/triangular/tri_Hub_ref1_2.png\"))\nip = image!(top, -2..2, 0..2, top_ref'[:, end:-1:1])\ntranslate!(ip, 0, 0, -1)\nip = image!(bot, -2..2, 0..2.5, bot_ref'[:, end:-1:1], transparency=true)\ntranslate!(ip, 0, 0, -1)\n\n# Plot our occupations\nc = HSV(250, 0.6, 1)\nmarkers = ('■', '□', 'o')\nscatter_plots = []\nfor (i, (ys, dys)) in enumerate(zip(occs, Δoccs))\n    band!(top, mus, ys .- dys, ys .+ dys, color = (:red, 0.3))\n    lines!(top, mus, ys, color = (c, 0.5), linewidth=2)\n    s = scatter!(top, mus, ys, color = c, marker = markers[i])\n    push!(scatter_plots, s)\nend\n\n# Add legend for scatter plots\nlabels = map(beta -> \"β = $beta\", collect(betas))\naxislegend(top, scatter_plots, labels, position = :rb)\n\n# Plot pairing correlations\nfor (i, (ys, dys)) in enumerate(zip(pcs, Δpcs))\n    band!(bot, mus, ys .- dys, ys .+ dys, color = (:red, 0.3), transparency=true)\n    lines!(bot, mus, ys, color = (c, 0.5), linewidth=2)\n    scatter!(bot, mus, ys, color = c, marker = ('■', '□', 'o')[i])\nend\n\n# match limits to paper\nxlims!(top, -2 , 2)\nylims!(top, 0 , 2)\nxlims!(bot, -2 , 2)\nylims!(bot, 0 , 2.5)\n\n# show the plot\nfig","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#Other-runs-1","page":"Triangular Attractive Hubbard","title":"Other runs","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The paper has two more versions of the above plot for system sizes L = 6 and L = 8. These show significantly different results.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"For L = 6 we use mus = vcat(-2.0:0.25:-0.25, -0.1:0.1:1.1, 1.25, 1.5, 2.0) with the same parameters other than that. The simulation should take about 5 minutes.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"For L=8 we use mus = vcat(-2.0:0.5:-0.5, -0.1:0.1:1.1, 1.25, 1.5, 2.0) and betas = (2.0, 5.0, 6.0, 7.0). The resulting simulation takes about 30min.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#Charge-Density-Structure-Factor-1","page":"Triangular Attractive Hubbard","title":"Charge Density Structure Factor","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The paper also investigates the charge density structure factor as a function of reciprocal lattice vectors q. In general structure factors can be computed from correlations via Fourier transform. For charge density correlations one typically comes across one of two formulas: langle n_i n_j rangle and langle n_i n_j rangle - langle n_i rangle langle n_j rangle. MonteCarlo.jl defaults to the former, but the paper uses the latter. To switch we again need to change the measurement kernel to MonteCarlo.reduced_cdc_kernel.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"With that we can now compare to the paper. As stated in the paper/figure, we set L = 6 8, beta = 8 and U = 4. The chemical potential should be set to produce a filling of rho = 1, which based on the occupation plots above is at about µ = 06.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"Ls = (6, 8)\nmus = (0.6, 0.6) # estimations for ρ = 1\ndqmcs = []\n\ncounter = 0\n@time for (mu, L) in zip(mus, Ls)\n    counter += 1\n    print(\"\\r[\", lpad(\"$counter\", 2), \"/$(length(betas) * length(Ls))]\")\n    lattice = TriangularLattice(L)\n\n    m = HubbardModelAttractive(l = lattice, t = 1.0, U = 4.0, mu = mu)\n    dqmc = DQMC(\n        m, beta = 8.0, delta_tau = 0.125, safe_mult = 8, \n        thermalization = 1000, sweeps = 1000, measure_rate = 1,\n        recorder = Discarder()\n    )\n    # MonteCarlo.jl uses <n_i n_j> as the default pairing correlation, the\n    # paper instead uses <n_i n_j> - <n_i><n_j>. The latter is given by\n    # MonteCarlo.reduced_cdc_kernel\n    dqmc[:CDC] = charge_density_correlation(dqmc, m, kernel = MonteCarlo.reduced_cdc_kernel)\n    run!(dqmc, verbose = false)\n\n    # for simplicity we just keep the whole simulation around\n    push!(dqmcs, dqmc)\nend","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"After the simulation we compute the fourier transform at various q with","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"# Fourier transform\nys = map(dqmcs) do dqmc\n    # reciprocal path traced in paper\n    L = size(lattice(dqmc))[1]\n    N = div(L, 2)\n    qs = vcat(\n        range(Float64[0, 0],   Float64[pi, 0],  length = N+1),\n        range(Float64[pi, 0],  Float64[pi, pi], length = N+1)[2:end],\n        range(Float64[pi, pi], Float64[0, 0],   length = N+1)[2:end]\n    )\n    values = mean(dqmc[:CDC])\n    dirs = directions(lattice(dqmc), dqmc[:CDC].lattice_iterator)\n    map(qs) do q\n        2 * real(sum(cis(dot(q, v)) * o for (v, o) in zip(dirs, values)))\n    end\nend","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#Magnetic-Susceptibility-1","page":"Triangular Attractive Hubbard","title":"Magnetic Susceptibility","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The uniform susceptibility featured in figure 7 of the paper can be reproduced more easily. For it we need to run our simulation with a spin_density_susceptibility(dqmc, model, :z) measurement. The result will again be in a partially summed per-distance-vector form. The q=0 Fourier transform follows from simple summation. With L = 6 and betas = [1.0, 2.0, 4.0, 5.0, 6.0, 7.0, 8.0] this simulation should take about a minute.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"legacy/methods/general/#Methods:-General-1","page":"General","title":"Methods: General","text":"","category":"section"},{"location":"legacy/methods/general/#","page":"General","title":"General","text":"Below you find all general exports.","category":"page"},{"location":"legacy/methods/general/#Index-1","page":"General","title":"Index","text":"","category":"section"},{"location":"legacy/methods/general/#","page":"General","title":"General","text":"Pages = [\"general.md\"]","category":"page"},{"location":"legacy/methods/general/#Documentation-1","page":"General","title":"Documentation","text":"","category":"section"},{"location":"legacy/methods/general/#","page":"General","title":"General","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"abstract.jl\"]","category":"page"},{"location":"legacy/methods/general/#MonteCarlo.lattice-Tuple{T} where T<:Model","page":"General","title":"MonteCarlo.lattice","text":"lattice(model)\n\nReturns the lattice of a given model.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.parameters-Tuple{Model}","page":"General","title":"MonteCarlo.parameters","text":"parameters(model)\n\nCollects relevant parametrs of a model into a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.reset!-Tuple{MonteCarloFlavor}","page":"General","title":"MonteCarlo.reset!","text":"reset!(mc::MonteCarloFlavor)\n\nResets the Monte Carlo simulation mc. Previously set parameters will be retained.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.run!-Tuple{MonteCarloFlavor}","page":"General","title":"MonteCarlo.run!","text":"run!(mc)\n\nRun the Monte Carlo Simulation.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.Model","page":"General","title":"MonteCarlo.Model","text":"Abstract model.\n\n\n\n\n\n","category":"type"},{"location":"legacy/methods/general/#MonteCarlo.MonteCarloFlavor","page":"General","title":"MonteCarlo.MonteCarloFlavor","text":"Abstract definition of a Monte Carlo flavor.\n\n\n\n\n\n","category":"type"},{"location":"legacy/manual/showcase/#Showcase-1","page":"Showcase","title":"Showcase","text":"","category":"section"},{"location":"legacy/manual/showcase/#D-Ising-model-1","page":"Showcase","title":"2D Ising model","text":"","category":"section"},{"location":"legacy/manual/showcase/#","page":"Showcase","title":"Showcase","text":"Results: (Image: )","category":"page"},{"location":"legacy/manual/showcase/#","page":"Showcase","title":"Showcase","text":"Code:","category":"page"},{"location":"legacy/manual/showcase/#","page":"Showcase","title":"Showcase","text":"using MonteCarlo, Distributions, PyPlot, DataFrames, JLD\n\nTdist = Normal(MonteCarlo.IsingTc, .64)\nn_Ts = 2^8\nTs = sort!(rand(Tdist, n_Ts))\nTs = Ts[Ts.>=1.2]\nTs = Ts[Ts.<=3.8]\ntherm = 10^4\nsweeps = 10^3\n\ndf = DataFrame(L=Int[], T=Float64[], M=Float64[], χ=Float64[], E=Float64[], C_V=Float64[])\n\nfor L in 2 .^ [3, 4, 5, 6]\n\tprintln(\"L = \", L)\n\tfor (i, T) in enumerate(Ts)\n\t\tprintln(\"\\t T = \", T)\n\t\tbeta = 1/T\n\t\tmodel = IsingModel(dims=2, L=L)\n\t\tmc = MC(model, beta=beta)\n\t\trun!(mc, sweeps=sweeps, thermalization=therm, verbose=false)\n\t\tpush!(df, [L, T, mean(mc.obs[\"m\"]), mean(mc.obs[\"χ\"]), mean(mc.obs[\"e\"]), mean(mc.obs[\"C\"])])\n\tend\n\tflush(stdout)\nend\n\nsort!(df, [:L, :T])\n@save \"ising2d.jld\" df\n\n# plot results together\ngrps = groupby(df, :L)\nfig, ax = subplots(2,2, figsize=(12,8))\nfor g in grps\n\tL = g[:L][1]\n\tax[1].plot(g[:T], g[:E], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[2].plot(g[:T], g[:C_V], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[3].plot(g[:T], g[:M], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[4].plot(g[:T], g[:χ], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\nend\nax[1].legend(loc=\"best\")\nax[1].set_ylabel(\"Energy\")\nax[1].set_xlabel(\"Temperature\")\n\nax[2].set_ylabel(\"Specific heat\")\nax[2].set_xlabel(\"Temperature\")\nax[2].axvline(x=MonteCarlo.IsingTc, color=\"black\", linestyle=\"dashed\", label=\"\\$ T_c \\$\")\nax[2].legend(loc=\"best\")\n\nax[3].set_ylabel(\"Magnetization\")\nax[3].set_xlabel(\"Temperature\")\nx = range(1.2, stop=MonteCarlo.IsingTc, length=100)\ny = (1 .- sinh.(2.0 ./ (x)).^(-4)).^(1/8)\nax[3].plot(x,y, \"k--\", label=\"exact\")\nax[3].plot(range(MonteCarlo.IsingTc, stop=3.8, length=100), zeros(100), \"k--\")\nax[3].legend(loc=\"best\")\n\nax[4].set_ylabel(\"Susceptibility χ\")\nax[4].set_xlabel(\"Temperature\")\nax[4].axvline(x=MonteCarlo.IsingTc, color=\"black\", linestyle=\"dashed\", label=\"\\$ T_c \\$\")\nax[4].legend(loc=\"best\")\ntight_layout()\nsavefig(\"ising2d.pdf\")","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is a package implementing classical and quantum Monte Carlo simulations primarily for solid state physics. Currently the focus is on finding a overall design for the package and verifying that determinant Quantum Monte Carlo (DQMC) is working correctly. As such the package may still go through significant changes and the documentation may be outdated and incomplete.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Note that classical Monte Carlo is also not a focus at this point. It is probably usable, but a lot of the adjustments made to DQMC have not been added to classical Monte Carlo, or have been added without thorough testing.","category":"page"},{"location":"DQMC/recorder/#Configuration-Recorder-1","page":"Configuration Recorder","title":"Configuration Recorder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"Sometimes it's useful to keep configurations around, for example to perform new measurements after the original simulation has finished. This is especially true in the case of DQMC where simulations can take weeks to run, but measurement on their own are relatively fast. We currently offer two objects for this purpose - Discarder and ConfigRecorder.","category":"page"},{"location":"DQMC/recorder/#General-Interface-1","page":"Configuration Recorder","title":"General Interface","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"Any AbstractRecorder follows an array-like interface. Configurations are added via push!(recorder, mc, model, sweep) and can be retrieved via getindex. The recorder has a length and implements isempty. Furthermore it can be iterated, saved and loaded.","category":"page"},{"location":"DQMC/recorder/#Discarder-1","page":"Configuration Recorder","title":"Discarder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"As the name suggests this recorder simply discards all configurations. It is used by default for classical Monte-Carlo simulations.","category":"page"},{"location":"DQMC/recorder/#ConfigRecorder-1","page":"Configuration Recorder","title":"ConfigRecorder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"This recorder keeps track of compressed configurations in memory. On creation a rate can be specified as the last argument in the constructor to reduce the amount of configurations saved. Compression relies on overloads of compress(mc, model, conf) and decompress(mc, model, conf). For the available Hubbard models these simply transform from and to BitArray.","category":"page"},{"location":"DQMC/recorder/#BufferedConfigRecorder-1","page":"Configuration Recorder","title":"BufferedConfigRecorder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"This recorder works similar to ConfigRecorder but only keeps a certain number of configurations in memory before writing them to disc or reading a new batch when replaying. For this the recorder need to be created with a filepath which can be given as an AbsolutePath or RelativePath. Optionally the buffer size can be set with chunk_size.","category":"page"}]
}
