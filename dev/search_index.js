var documenterSearchIndex = {"docs":
[{"location":"legacy/interfaces/MC/#Interface:-Monte-Carlo-(MC)-1","page":"MC","title":"Interface: Monte Carlo (MC)","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"Any model that wants to be simulated by means of MC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the Monte Carlo flavor Monte Carlo (MC).","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"Example models: Ising Model","category":"page"},{"location":"legacy/interfaces/MC/#Mandatory-fields-1","page":"MC","title":"Mandatory fields","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"l::Lattice: any Lattice","category":"page"},{"location":"legacy/interfaces/MC/#Index-of-all-methods-1","page":"MC","title":"Index of all methods","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"Pages = [\"MC.md\"]","category":"page"},{"location":"legacy/interfaces/MC/#Mandatory-methods-1","page":"MC","title":"Mandatory methods","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"CurrentModule = MonteCarlo","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"conftype(::Type{MC}, m::Model)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"energy(mc::MC, m::Model, conf)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"rand(::MC, ::Model)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"propose_local(mc::MC, m::Model, i::Int, conf, E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#MonteCarlo.propose_local-Tuple{MC, Model, Int64, Any, Float64}","page":"MC","title":"MonteCarlo.propose_local","text":"propose_local(mc::DQMC, m::Model, field::AbstractField, i::Int, slice::Int)\n\nPropose a local move for lattice site i at time slice slice for a field  holding the current configuration. Returns the Green's function determinant  ratio, the boson energy difference ΔE_boson = E_boson_new - E_boson, and any extra information passthrough that might be useful in accept_local.\n\nBy default this function will call propose_local(mc, field, i, slice).\n\nSee also accept_local!.\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"accept_local!(mc::MC, m::Model, i::Int, conf, E::Float64, delta_i, delta_E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#Optional-methods-1","page":"MC","title":"Optional methods","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"global_move(mc::MC, m::Model, conf, E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"prepare_observables(mc::MC, m::Model)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"measure_observables!(mc::MC, m::Model, obs::Dict{String,Observable}, conf, E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"finish_observables!(mc::MC, m::Model, obs::Dict{String,Observable})","category":"page"},{"location":"legacy/models/hubbardattractive/#Attractive-Hubbard-Model-1","page":"Attractive Hubbard model","title":"Attractive Hubbard Model","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#Hamiltonian-1","page":"Attractive Hubbard model","title":"Hamiltonian","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The Hamiltonian of the attractive (negative U) Hubbard model reads","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} \\mathcal{H} = -t \\sum{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger{i\\sigma} c{j\\sigma} + \\text{h.c.} \\right) - |U| \\sumj \\left( n{j\\uparrow} - \\frac{1}{2} \\right) \\left( n{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sumj n{j}, \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"where sigma denotes spin, t is the hopping amplitude, U the on-site repulsive interaction strength, mu the chemical potential and langle i j rangle indicates that the sum has to be taken over nearest neighbors. Note that (1) is written in particle-hole symmetric form such that mu = 0 corresponds to half-filling.","category":"page"},{"location":"legacy/models/hubbardattractive/#Constructor-1","page":"Attractive Hubbard model","title":"Constructor","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"You can create an attractive Hubbard model instance as follows,","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"model = HubbardModelAttractive(dims=1, L=8)","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The following parameters can be set via keyword arguments:","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"dims::Int: dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)\nL::Int: linear system size\nt::Float64 = 1.0: hopping energy\nU::Float64 = 1.0: onsite interaction strength, \"Hubbard U\"\nmu::Float64 = 0.0: chemical potential","category":"page"},{"location":"legacy/models/hubbardattractive/#Supported-Monte-Carlo-flavors-1","page":"Attractive Hubbard model","title":"Supported Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Determinant Quantum Monte Carlo (DQMC), see details below","category":"page"},{"location":"legacy/models/hubbardattractive/#DQMC-formulation-1","page":"Attractive Hubbard model","title":"DQMC formulation","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"We decouple the onsite electron-electron interaction by performing a Hirsch transformation, i.e. a discrete Hubbard-Stratonovich transformation in the density/charge channel,","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} e^{|U|\\Delta \\tau \\left( n{i\\uparrow} - \\frac{1}{2} \\right) \\left(n{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum{s=\\pm 1} \\prod{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The interaction matrix of the model then reads","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} V{ij}(l) &= \\delta{ij} Vi(l), \\\\\nVi(l) &= - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"For completeness, the hopping matrix is \\begin{align} T_{ij} &= \\begin{cases} -t & \\text{if i and j are nearest neighbors,} \\\\\n-\\mu & \\text{if i == j,} \\\\\n0 & \\text{otherwise.} \\end{cases} \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"As neither T nor V depend on spin, neither does the equal-times Green's function. We can therefore restrict our computations to one spin flavor (flv=1) and benefit from operating with smaller matrices.","category":"page"},{"location":"legacy/models/hubbardattractive/#Potential-extensions-1","page":"Attractive Hubbard model","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Arbitrary lattices (so far only cubic lattices supported)","category":"page"},{"location":"DQMC/dqmc/#DQMC-1","page":"DQMC","title":"DQMC","text":"","category":"section"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"The DQMC struct represents both the determinant quantum monte carlo algorithm and the simulation as a whole. Because of that it includes a bunch of options that aren't directly relevant to the algorithm. The minimal default is given by dqmc = DQMC(model, beta=beta) and the simulation can then be started with run!(dqmc). Additional keyword arguments include:","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"beta: The inverse temperature of the simulation.\ndelta_tau = 0.1: The imaginary time discretization.\nslices = beta / delta_tau: The number of imaginary time slices.\nsafe_mult = 10: The number of save matrix multiplications.\nthermalization = 100: The number of thermalization sweeps.\nsweeps = 100: The number of measurement sweeps.\ncheck_sign_problem = true: Enables or disables checks for sign problems. (negative or imaginary probabilities)\ncheck_propagation_error = true: Enables or disables checks for time slices propagation errors. (Which may happen if safemult or deltatau is too large.)\nsilent = false: Enable or disable prints for the checks above.\nmeasure_rate = 10: Sets the frequency of measurements. Every measure_rate sweeps a new measurement is taken.\nprint_rate = 10: Sets the frequency of general information prints (not checks).\nseed = -1: Sets a random seed for the simulation. If set to -1 the seed will be chosen randomly.\nlast_sweep = 0: Sets the last finished sweep. Used internally for continued simulations.","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"Beyond this there are a couple of keyword arguments which are more involved and will be discussed in other chapters. These include","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"scheduler = SimpleScheduler(LocalSweep()): This sets up the sequence of updates performed by the simulation.\nmeasurements = Dict{Symbol, AbstractMeasurement}(): A collection of named measurements that run during the simulation. These are usually added after creating the simulation.\nthermalization_measurements = Dict{Symbol, AbstractMeasurement}(): Same as the above, but the measurements run during the thermalization stage. Might be useful to judge convergence or the number of necessary sweeps.\nrecorder = ConfigRecorder: A recorder for the configurations generated during the simulation.\nrecording_rate = measure_rate: The rate at which configurations are recorded.","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"Running a simulation also comes with a bunch of options via keyword arguments - most dealing with saving the simulation. The options for run(dqmc) include:","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"verbose = true: Enables or disables information printing during the runtime.\nignore = tuple(): Measurement keys to ignore during this run (none by default).\nsafe_before::TimeType = now() + Year(100): Sets a time stamp before which the simulation will cancel itself and save.\nsafe_every::TimePeriod = Hour(10000): Sets a time period interval for regular saves.\ngrace_period::TimePeriod = Minute(5): Sets a buffer time period for saving. By default saves at least 5 minutes before the requested time.\nresumable_filename = \"resumable_$(datestring).jld2: Sets the name the savefile generated from safebefore and safeevery.\noverwrite = true: Enables or disables overwriting of existing files. ","category":"page"},{"location":"legacy/manual/gettingstarted/#Getting-Started-1","page":"Getting started","title":"Getting Started","text":"","category":"section"},{"location":"legacy/manual/gettingstarted/#Installation-1","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"MonteCarlo.jl hasn't yet been released. To clone the package execute the following command in the Julia REPL:","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"Pkg.clone(\"https://github.com/crstnbr/MonteCarloObservable.jl\")\nPkg.clone(\"https://github.com/crstnbr/MonteCarlo.jl\")","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"To update to the latest version of the package just do Pkg.update() or specifically Pkg.update(\"MonteCarlo\").","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"warning: Warning\nThe package is still in pre-alpha phase and shouldn't yet be used for production runs.","category":"page"},{"location":"legacy/manual/gettingstarted/#Usage-1","page":"Getting started","title":"Usage","text":"","category":"section"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"This is a simple demontration of how to perform a Monte Carlo simulation of the 2D Ising model:","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"# load packages\nusing MonteCarlo\n\n# load your model\nm = IsingModel(dims=2, L=8);\n\n# choose a Monte Carlo flavor and run the simulation\nmc = MC(m, beta=0.35);\nrun!(mc, sweeps=1000, thermalization=1000, verbose=false);\n\n# analyze results\nobservables(mc) # what observables do exist for that simulation?\nm = mc.obs[\"m\"] # magnetization\nmean(m)\nstd(m) # one-sigma error\n\n# create standard plots\nhist(m)\nplot(m)","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"legacy/flavors/dqmc/#Determinant-Quantum-Monte-Carlo-(DQMC)-1","page":"DQMC","title":"Determinant Quantum Monte Carlo (DQMC)","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"This is determinant quantum Monte Carlo (MC) also known auxiliary field quantum Monte Carlo. It can be used to simulate interacting fermion systems, here the auxiliary boson arises from a Hubbard Stratonovich transformation, or fermions which are naturally coupled to bosons. An example is the Attractive Hubbard Model.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"You can initialize a determinant quantum Monte Carlo simulation of a given model simply through","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"dqmc = DQMC(model, beta=5.0)","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Mandatory keywords are:","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"beta: inverse temperature","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Allowed keywords are:","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"delta_tau::Float64 = 0.1: imaginary time step size\nsafe_mult::Int = 10: stabilize Green's function calculations every safe_mult step (How many slice matrices can be multiplied until singular value information is lost due to numerical unaccuracy?)\ncheckerboard::Float64 = false: use Checkerboard decomposition (faster)\nsweeps: number of measurement sweeps\nthermalization: number of thermalization (warmup) sweeps\nseed: initialize DQMC with custom seed\nall_checks::Bool = true: turn off to suppress some numerical checks","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Afterwards, you can run the simulation by","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"run!(dqmc)","category":"page"},{"location":"legacy/flavors/dqmc/#Technical-details-1","page":"DQMC","title":"Technical details","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#Symmetric-Suzuki-Trotter-decomposition-1","page":"DQMC","title":"Symmetric Suzuki-Trotter decomposition","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"We use the symmetric version of the Suzuki-Trotter decomposition, i.e.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"\\begin{align} e^{-\\Delta\\tau \\suml T+V(l)} = \\prodj e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"where T is the hopping matrix and V(l) is the interaction matrix with l an imaginary time slice index indicating an auxiliary field dependence.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"With the imaginary time slice matrices B_l = e^-Deltatau T2 e^-Deltatau V(l) e^-Deltatau T2 the equal-time Green's function is G = left( 1 + B_M cdots B_1 right)^-1.","category":"page"},{"location":"legacy/flavors/dqmc/#Checkerboard-decomposition-1","page":"DQMC","title":"Checkerboard decomposition","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"We provide a general algorithm to construct the \"checkerboard\" split up of a generic AbstractLattice. The only requirement is that the AbstractLattice has the following two fields,","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"n_bonds::Int: total number of bonds (lattice graph edges)\nbonds::Matrix{Int}: bond matrix of shape (n_bonds, 3). Rows correspond to bonds and columns indicate source site, target site, and bond type in this order.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Of course, one can also manually construct a (more efficient) checkerboard split up by overloading the following function for the specific AbstractLattice subtype.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"MonteCarlo.build_checkerboard(l::MonteCarlo.AbstractLattice)","category":"page"},{"location":"legacy/flavors/dqmc/#MonteCarlo.build_checkerboard-Tuple{AbstractLattice}","page":"DQMC","title":"MonteCarlo.build_checkerboard","text":"build_checkerboard(l::Lattice) -> checkerboard, groups, n_groups\n\nGeneric checkerboard construction.\n\nThe methods returns     * checkerboard::Matrix{Int}: size (3, n_bonds) where                 rows = source site, target site, bondid and cols                     correspond to bonds. Sorted (along columns) in such a way                     that checkerboard[3, groups[i]] are all the bond indices                     corresponding to the i-th group.     * groups::Vector{UnitRange}: ranges indicating which columns of checkerboard                     belong to which checkerboard group.     * n_groups::Int: number of checkerboard groups.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#Effective-slice-matrices-and-Green's-function-1","page":"DQMC","title":"Effective slice matrices and Green's function","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Combining the symmetric Suzuki-Trotter and checkerboard decomposition we can write (assuming two checkerboard groups a and b)","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"\\begin{align} e^{-\\Delta\\tau \\suml T+V(l)} &= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} \\\\\n&\\times \\left( \\prodj e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"For performance resons we internally work with effective imaginary time slice matrices","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"B_l^texteff = e^-Deltatau T_b2 e^-Deltatau T_a e^-Deltatau T_b2 e^-Deltatau V","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"instead of the original B_ls above.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"warning: Warning\nNote that one consequence is that the field dqmc.s.greens isn't the actual Green's function but an effective one defined by \\begin{align} G &= \\left( 1 + BM \\cdots B1 \\right)^{-1} \\\\\n&= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} \\left( 1 + B^{\\text{eff}}M \\cdots B^{\\text{eff}}1 \\right)^{-1} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta/2} \\\\\n&= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} G^{\\text{eff}} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta/2} \\end{align}To obtain the actual equal-times Green's function, for example for measuring, use greens(dqmc::DQMC). Note that although Goverset=G^texteff} one can readily show that det G = det G^texteff holds and the Metropolis acceptance is not affected by switching to the effective matrices.","category":"page"},{"location":"legacy/flavors/dqmc/#Exports-1","page":"DQMC","title":"Exports","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"DQMC.jl\"]","category":"page"},{"location":"legacy/flavors/dqmc/#MonteCarlo.replay!","page":"DQMC","title":"MonteCarlo.replay!","text":"replay(mc::DQMC[; configurations::Iterable = mc.recorder; kwargs...])\n\nReplays previously generated configurations and measures observables along the way.\n\nKeyword Arguments (both):\n\nverbose = true: If true, print progress messaged to stdout.\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, replay! will generate a\n\nresumable save file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nfilename: Name of the save file. The default is based on safe_before.\nstart=1: The first sweep in the simulation. This will be changed when using\n\nresume!(save_file).\n\nignore: A collection of measurement keys to ignore. Defaults to the key of\n\nthe configuration measurement.\n\nmeasure_rate = 1: Rate at which measurements are taken. Note that this is \n\nbased on the recorded configurations, not actual sweeps.\n\n\n\n\n\n","category":"function"},{"location":"legacy/flavors/dqmc/#MonteCarlo.run!-Tuple{DQMC}","page":"DQMC","title":"MonteCarlo.run!","text":"run!(mc::DQMC[; kwargs...])\n\nRuns the given Monte Carlo simulation mc. Returns true if the run finished and false if it cancelled early to generate a resumable save-file.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nthermalization: Number of thermalization sweeps. Uses the value passed to\n\nDQMC by default.\n\nsweeps: Number of measurement sweeps. Uses the value passed to DQMC by\n\ndefault.\n\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, run! will generate a resumable\n\nsave file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nresumable_filename: Name of the resumable save file. The default is based on\n\nsafe_before.\n\noverwrite = false: If set to true a file with the same name as\n\nresumable_filename will be overwritten. (This will create a temporary backup)\n\nSee also: resume!\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#MonteCarlo.DQMC-Tuple{Model, Dict{Symbol, V} where V}","page":"DQMC","title":"MonteCarlo.DQMC","text":"DQMC(m::M, params::Dict)\nDQMC(m::M, params::NamedTuple)\n\nCreate a determinant quantum Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#MonteCarlo.DQMC-Tuple{M} where M<:Model","page":"DQMC","title":"MonteCarlo.DQMC","text":"DQMC(m::M; kwargs...) where M<:Model\n\nCreate a determinant quantum Monte Carlo simulation for model m with keyword parameters kwargs.\n\nKeyword Arguments:\n\nseed: The random seed used by the simulation.\ncheckerboard=false: If true, the simulation uses a generic checkerboard\n\ndecomposition.\n\nthermalization_measurements::Dict{Symbol, AbstractMeasurement}: A collection\n\nof measurements run during the thermalization stage. By default, none are used.\n\nmeasurements::Dict{Symbol, AbstractMeasurement}: A collection of measurements\n\nrun during the measurement stage. Calls default_measurements if not specified.\n\nrecorder = ConfigRecorder: Type of recorder used for saving configurations\n\ngenerated during the simulation. Used (by default) when replay!ing simulations.  (Discarder or ConfigRecorder)\n\nrecording_rate = measure_rate: Rate at which configurations are recorded.\nthermalization = 100: Number of thermalization sweeps\nsweeps: Number of measurement sweeps\nall_checks = true: Check for Propagation instabilities and sign problems.\nsafe_mult = 10: Number of \"safe\" matrix multiplications. Every safe_mult\n\nmultiplications, a UDT decomposition is used to stabilize the product.\n\ndelta_tau = 0.1: Time discretization of the path integral\nbeta::Float64: Inverse temperature used in the simulation\nslices::Int = beta / delta_tau: Number of imaginary time slice in the\n\nsimulation\n\nmeasure_rate = 10: Number of sweeps discarded between every measurement.\nlast_sweep = 0: Sets the index of the last finished sweep. The simulation\n\nwill start with sweep last_sweep + 1.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#Potential-extensions-1","page":"DQMC","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"todo","category":"page"},{"location":"DQMC/measurements/#Measurements-1","page":"Measurements","title":"Measurements","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Measurements in DQMC primarily rely on (Wick's theorem)[https://en.wikipedia.org/wiki/Wick%27stheorem] to express observables in terms of Greens function elements. The greens function in DQMC is a matrix G{ij}(k, l) = \\langle ci(k \\Delta\\tau) cj^\\dagger(l \\Delta\\tau)\\ranglef$, where \\langle\\cdot\\ranglef$ represents the fermion average. ","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Measurement are created and added via dqmc[:name] = measurement(dqmc, model). The currently implemented measurements are the following","category":"page"},{"location":"DQMC/measurements/#Greens-1","page":"Measurements","title":"Greens","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The equal time greens function can be measured via greens_measurement(dqmc, model). The measurement will take the Monte Carlo or bosonic average of greens(dqmc, model).","category":"page"},{"location":"DQMC/measurements/#Occupation-1","page":"Measurements","title":"Occupation","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The per-site occupation langle n_i rangle can be measured via occupation(dqmc, model). This will average 1 - G_ii.","category":"page"},{"location":"DQMC/measurements/#Charge-Density-1","page":"Measurements","title":"Charge Density","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The charge density correlation langle sum_r n(r) n(r+Delta r) rangle can be measured with charge_density_correlation(dqmc, model). The time integral of that, the charge density susceptibility can be measure with charge_density_susceptibility(mc, model).  Note that either way the result will be averaged over origin sites and saved by distance vectors. These vectors can be generated with directions(lattice)","category":"page"},{"location":"DQMC/measurements/#Magnetization-1","page":"Measurements","title":"Magnetization","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"magnetization(dqmc, model, dir::Symbol) measures the per-site x-, y- or z-magnetizations.","category":"page"},{"location":"DQMC/measurements/#Spin-Density-1","page":"Measurements","title":"Spin Density","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The spin density correlation langle S_gamma S_gamma rangle in x-, y- or z-direction can be measured with spin_density_correlation(dqmc, model, dir::Symbol). The respective susceptibilities follow from spin_density_susceptibility(dqmc, model, dir).","category":"page"},{"location":"DQMC/measurements/#Pairing-1","page":"Measurements","title":"Pairing","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The pairing susceptibility Delta_v(s_1 t_1)(tau) Delta_v^dagger(s_2 t_2)(0) can be calculated with pairing_susceptibility(dqmc, model). The tau = 0 pairing correlation follows from pairing_correlation(dqmc, model).","category":"page"},{"location":"DQMC/measurements/#Current-Current-Susceptibility-1","page":"Measurements","title":"Current-Current Susceptibility","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"current_current_susceptibility(dqmc, model) measures langle j_t_2 - s_2(s_2 l) j_t_1 - s_1(s_1 0)rangle with j_t - s(s tau) = langle i sum_sigma T_ts c_t^dagger(tau) c_s(tau) - T_st c_s^dagger(tau) c_t(tau) rangle where i^2 = -1 and T is the hopping matrix.","category":"page"},{"location":"DQMC/measurements/#Superfluid-Density-1","page":"Measurements","title":"Superfluid Density","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"superfluid_density(dqmc, model, L) computes the superfluid density using the current current susceptibility for a lattice of linear system size L.","category":"page"},{"location":"DQMC/measurements/#Energies-1","page":"Measurements","title":"Energies","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The energy can be measured with total_energy(dqmc, model). The interacting and noninteracting parts can be measured independently with interacting_energy(dqmc, model) and noninteracting_energy(dqmc, model)","category":"page"},{"location":"DQMC/measurements/#General-Notes-1","page":"Measurements","title":"General Notes","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"All measurements are implemented via","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"struct DQMCMeasurement{GI, LI, F <: Function, OT, T} <: AbstractMeasurement\n    greens_iterator::GI\n    lattice_iterator::LI\n    kernel::F\n    observable::OT\n    temp::T\nend","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The greens_iterator is a type that will be constructed when the simulation starts running. This allows measurements using the same set of greens matrices to be bundled, improving performance especially for unequal time measurements (susceptibilities). There are currently three greens iterators:","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Greens which forwards the equal time greens function\nGreensAt{k, l} which forwards the result of greens(dqmc, k, l)\nCombinedGreensIterator which goes through all time slices l = 1 .. M and forwards G(0 0), G(0 Deltatau l), G(Deltatau l 0) and G(Deltatau l Deltatau l). This implicitly sums results over different time slices and multiplies the result by Deltatau, i.e. it implicitly calculates O_idxs = int_0^beta O_idxs(tau) dtau.","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The lattice_iterator is also (usually) a type with deferred construction. This iterator generates site indices which are ultimately passed on to the kernel with the Greens matrices generated by greens_iterator. The iterators are given on the lattice page. Depending on the iterator in use, there may be some implicit summation:","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"DirectLatticeIterators do not perform summation, i.e. the indices idxs... are used as temp[idxs...] = kernel(..., idxs..., ...)\nDeferredLatticeIterators return directional indices which are used to index the output and site indices which are passed to kernel. This means there is an implicit summation here, which reduces a all site indices to directional indices. The result is then normalized by dividing by the number of summed results, which is the number of sites.\nSum{<: LatticeIterator} explicitly sums all kernel results. This will also apply normalizations of the wrapped iterator if it has any.\nApplySymmetries{<: DeferredLatticeIterator} performs the summation and normalization of the wrapped iterator, and then applies the symmetry weights to the second or second and third directional indices and sums up the result. This leaves the an array with one directional index.","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The kernel is a function that basically just applies the results from Wicks theorem. For example, the kernel for charge density susceptibilities is given by","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"function cdc_kernel(mc, model, ij::NTuple{2}, packed_greens::NTuple{4})\n    i, j = ij\n\tG00, G0l, Gl0, Gll = packed_greens\n    N = length(lattice(mc))\n\n    # ⟨n↑(l)n↑⟩\n    (1 - Gll[i, i]) * (1 - G00[j, j]) -\n    G0l[j, i] * Gl0[i, j] +\n    # ⟨n↑(l)n↓⟩\n    (1 - Gll[i, i]) * (1 - G00[j+N, j+N]) -\n    G0l[j+N, i] * Gl0[i, j+N] +\n    # ⟨n↓(l)n↑⟩\n    (1 - Gll[i+N, i+N]) * (1 - G00[j, j]) -\n    G0l[j, i+N] * Gl0[i+N, j] +\n    # ⟨n↓(l)n↓⟩\n    (1 - Gll[i+N, i+N]) * (1 - G00[j+N, j+N]) -\n    G0l[j+N, i+N] * Gl0[i+N, j+N]\nend","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The passed indices and greens matrices vary depending on the chosen iterators. The indices could be a single integer, a tuple of two or a tuple of four integers. packed_greens could be a greens matrix (which could be a special matrix type like BlockDiagonal) or a tuple of four greens matrices.","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The observable is the final storage of the measured values. By default this is a LogBinner from BinningAnalysis.jl but that can be changed. The only hard requirement is that the data structure implements push!. The shape and type of the values pushed to the container can be derived from the greens element type returned by geltype(dqmc) and the shape tuple returned by _get_final_shape(dqmc, model, lattice_iterator).","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The temp field is a temporary storage Array used as a target for summation before pushing the final result of the measurement. It should be initialized to ","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"temp = let\n    shape = _get_temp_shape(dqmc, _model, lattice_iterator)\n    shape === nothing ? nothing : Array{geltype(dqmc)}(undef, shape)\nend","category":"page"},{"location":"examples/HofmannBergChowdhury/#Topological-Flat-Band-Model-1","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"This will be a rather extensive example and crosscheck with the 2020 paper \"Superconductivity, pseudogap, and phase separation in topological flat bands:'a quantum Monte Carlo study\" (arxiv) by Hofmann, Berg and Chowdhury. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#Introduction-1","page":"Topological Flat Band Model","title":"Introduction","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The paper investigates an attractive square lattice Hubbard model with complex hoppings up to the 5th order. It generates a flat and a dispersive band, where the flatness of the former can increased with the right ratio of hoppings. At partial filling of the flat band superconductivity is observed. The model reads","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"beginaligned\n\tH_kin = left\n        -t_1 sum_langle i j rangle_1 sigma e^iphi_ij^sigma c_i sigma^dagger c_j sigma\n        -t_2 sum_langle i j rangle_2 sigma s_langle i j rangle_2 c_i sigma^dagger c_j sigma\n        -t_5 sum_langle i j rangle_5 sigma c_i sigma^dagger c_j sigma\n        + hc\n    right - mu sum_i n_i \n    H_int = - fracU2 sum_i (n_i - 1)^2\nendaligned","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where t_n refers to n-th nearest neighbor hopping and langle i j rangle_n refers to the involved site pairs. We will discuss the prefactors more closely when implementing the lattice model. The interactive term is a variation of what we use in our standard attractive Hubbard model and can be dealt with using the same Hirsch transformation.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Implementation-1","page":"Topological Flat Band Model","title":"Implementation","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#The-Lattice-1","page":"Topological Flat Band Model","title":"The Lattice","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The model is defined for a square lattice, however the paper suggests defining it via two site basis A = (0 0), B = (0 1) with lattice vector a_1 = (1 1) and a_2 = (1 -1). We will follow this suggestion. The model uses first, second and fifth neighbor hoppings.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The nearest neighbors are directed, catching different values for phi_ij^sigma as a result. We need to create two groups, one with directions as indicated in figure 1a) in the paper, and one with the reverse. For second nearest neighbors the prefactor s_langle i j rangle_2 depends on the combination of sublattice and direction. In a_1 direction the value is positive (negative) on the A (B) sublattice, and in a_2 it is negative (positive) on the A (B) sublattice. The fifth nearest neighbors always have the same weight and thus do not require special grouping.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"We implement the lattice with LatticePhysics.jl. The package requires us to define a unitcell with all bonds we want to see in the full lattice. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"using LatticePhysics, LatPhysUnitcellLibrary\n\nfunction LatPhysUnitcellLibrary.getUnitcellSquare(\n            unitcell_type  :: Type{U},\n            implementation :: Val{17}\n        ) :: U where {LS,LB,S<:AbstractSite{LS,2},B<:AbstractBond{LB,2}, U<:AbstractUnitcell{S,B}}\n\n    # return a new Unitcell\n    return newUnitcell(\n        # Type of the unitcell\n        U,\n\n        # Bravais lattice vectors\n        [[1.0, +1.0], [1.0, -1.0]],\n        \n        # Basis sites\n        S[\n            newSite(S, [0.0, 0.0], getDefaultLabelN(LS, 1)),\n            newSite(S, [0.0, 1.0], getDefaultLabelN(LS, 2))\n        ],\n\n        # Bonds\n        B[\n            # NN, directed\n            # bonds from ref plot, π/4 weight for spin up\n            newBond(B, 1, 2, getDefaultLabelN(LB, 1), (0, 1)),\n            newBond(B, 1, 2, getDefaultLabelN(LB, 1), (-1, 0)),\n            newBond(B, 2, 1, getDefaultLabelN(LB, 1), (+1, -1)),\n            newBond(B, 2, 1, getDefaultLabelN(LB, 1), (0, 0)),\n\n            # NN reversal\n            newBond(B, 2, 1, getDefaultLabelN(LB, 2), (0, -1)),\n            newBond(B, 2, 1, getDefaultLabelN(LB, 2), (+1, 0)),\n            newBond(B, 1, 2, getDefaultLabelN(LB, 2), (-1, +1)),\n            newBond(B, 1, 2, getDefaultLabelN(LB, 2), (0, 0)),\n            \n            # NNN\n            # positive weight (forward and backward facing)\n            newBond(B, 1, 1, getDefaultLabelN(LB, 3), (+1, 0)),\n            newBond(B, 1, 1, getDefaultLabelN(LB, 3), (-1, 0)),\n            newBond(B, 2, 2, getDefaultLabelN(LB, 3), (0, +1)),\n            newBond(B, 2, 2, getDefaultLabelN(LB, 3), (0, -1)),\n            # negative weight\n            newBond(B, 1, 1, getDefaultLabelN(LB, 4), (0, +1)),\n            newBond(B, 1, 1, getDefaultLabelN(LB, 4), (0, -1)),\n            newBond(B, 2, 2, getDefaultLabelN(LB, 4), (+1, 0)),\n            newBond(B, 2, 2, getDefaultLabelN(LB, 4), (-1, 0)),\n            \n            # Fifth nearest neighbors (forward)\n            newBond(B, 1, 1, getDefaultLabelN(LB, 5), (2, 0)),\n            newBond(B, 2, 2, getDefaultLabelN(LB, 5), (2, 0)),\n            newBond(B, 1, 1, getDefaultLabelN(LB, 5), (0, 2)),\n            newBond(B, 2, 2, getDefaultLabelN(LB, 5), (0, 2)),  \n            # backwards facing bonds (backwards)\n            newBond(B, 1, 1, getDefaultLabelN(LB, 5), (-2, 0)),\n            newBond(B, 2, 2, getDefaultLabelN(LB, 5), (-2, 0)),\n            newBond(B, 1, 1, getDefaultLabelN(LB, 5), (0, -2)),\n            newBond(B, 2, 2, getDefaultLabelN(LB, 5), (0, -2)), \n        ]\n    )\nend","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"With this implementation we can then generate a lattice of arbitrary size with","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"L = 8\nuc = LatticePhysics.getUnitcellSquare(17)\nlpl = getLatticePeriodic(uc, L)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where L is the linear system size. Note that due to the two basis sites the total number of sites is 2L^2. To verify our lattice implementation it is useful to create a comparable plot. In Makie, for example, we may run","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"using GLMakie\n\n# get small lattice without periodic bonds\nuc = LatticePhysics.getUnitcellSquare(17)\nlpl = getLatticeOpen(uc, 3)\n\n# create figure and axis without background grid and stretching\nfig = Figure()\nax = Axis(fig[1, 1], aspect=DataAspect(), xgridvisible = false, ygridvisible = false)\n\n# collect list of bonds grouped by label\nps = Point2f.(point.(sites(lpl)))\nls = [Point2f[] for _ in 1:5]\nfor b in bonds(lpl)\n    push!(ls[b.label], ps[b.from], ps[b.to])\nend\n\n# Draw arrows for NN groups\nds = ls[1][2:2:end] .- ls[1][1:2:end]\narrows!(ax, ls[1][1:2:end] .+ 0.35 .* ds, 0.55 .* ds, color = :black)\nds = ls[2][2:2:end] .- ls[2][1:2:end]\narrows!(ax, ls[2][1:2:end] .+ 0.65 .* ds, 0.25 .* ds, color = :lightgray)\n\n# NNN\nlinesegments!(ax, ls[3], color = :black, linewidth=1)\nlinesegments!(ax, ls[4], color = :black, linewidth=1, linestyle = :dash)\n\n# 5th nearest neighbors\nlinesegments!(ax, ls[5] .+ Point2f(0, 0.05), color = :red)\n\n# draw A and B sites\nAs = [Point2f(point(s)) for s in sites(lpl) if s.label == 1]\nBs = [Point2f(point(s)) for s in sites(lpl) if s.label == 2]\nscatter!(ax, As, color = :black, markersize = 10)\nscatter!(ax, Bs, color = :black, marker='■', markersize = 8)\n\n# Label A and B sites\ntext!(ax, \"A\", position = Point2f(-0.2, 0), align = (:right, :center))\ntext!(ax, \"B\", position = Point2f(-0.2, 1), align = (:right, :center))\n\nMakie.save(\"HBC_lattice.png\", fig)\nfig","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"In the plot we indicate the first group of nearest neighbors with black arrows and the second, i.e. the reversals with light gray ones. Next nearest neighbors are indicated with full (group 3) or dashed lines (group 4) like in the paper. The fifth nearest neighbors (group 5) are drawn in red like in the reference.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Hopping-and-Interaction-Matrix-1","page":"Topological Flat Band Model","title":"Hopping and Interaction Matrix","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Now that we have the lattice we can generate a fitting hopping matrix. But before we do this, let us briefly discuss some optimizations. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"LoopVectorization.jl is a great tool when pushing for peak single threaded/single core linear algebra performance. The linear algebra needed for DQMC is reimplemented in MonteCarlo.jl using it for both Float64 and ComplexF64. The latter uses MonteCarlo.CMat64 and MonteCarlo.CVec64 as concrete array types which are based on StructArrays.jl under the hood. They should be used in this model. Furthermore we can make use of MonteCarlo.BlockDiagonal as we have no terms with differing spin indices. Thus we set","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"MonteCarlo.@with_kw_noshow struct HBCModel{LT<:AbstractLattice} <: HubbardModel\n    # parameters with defaults based on paper\n    mu::Float64 = 0.0\n    U::Float64 = 1.0\n    @assert U >= 0. \"U must be positive.\"\n    t1::Float64 = 1.0\n    t2::Float64 = 1.0 / sqrt(2.0)\n    t5::Float64 = (1 - sqrt(2)) / 4\n\n    # lattice\n    l::LT\n\n    # two fermion flavors (up, down)\n    flv::Int = 2\n    \n    # temp storage to avoid allocations in propose_local and accept_local\n    IG::CMat64  = StructArray(Matrix{ComplexF64}(undef, length(l), 2))\n    IGR::CMat64 = StructArray(Matrix{ComplexF64}(undef, length(l), 2))\n    R::Diagonal{ComplexF64, CVec64} = Diagonal(StructArray(Vector{ComplexF64}(undef, 2)))\nend\n\nMonteCarlo.hoppingeltype(::Type{DQMC}, ::HBCModel) = ComplexF64\nMonteCarlo.hopping_matrix_type(::Type{DQMC}, ::HBCModel) = BlockDiagonal{ComplexF64, 2, CMat64}\nMonteCarlo.greenseltype(::Type{DQMC}, ::HBCModel) = ComplexF64\nMonteCarlo.greens_matrix_type( ::Type{DQMC}, ::HBCModel) = BlockDiagonal{ComplexF64, 2, CMat64}","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"for our model. The definition of the hopping matrix then follows from the various weights in the Hamiltonian as","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"function MonteCarlo.hopping_matrix(mc::DQMC, m::HBCModel{<: LatPhysLattice})\n    # number of sites\n    N = length(m.l)\n\n    # spin up and spin down blocks of T\n    tup = diagm(0 => fill(-ComplexF64(m.mu), N))\n    tdown = diagm(0 => fill(-ComplexF64(m.mu), N))\n\n    # positive and negative prefactors for t1, t2\n    t1p = m.t1 * cis(+pi/4) # ϕ_ij^↑ = + π/4\n    t1m = m.t1 * cis(-pi/4) # ϕ_ij^↓ = - π/4\n    t2p = + m.t2\n    t2m = - m.t2\n    \n    for b in bonds(m.l.lattice)\n        # NN paper direction\n        if b.label == 1 \n            tup[b.from, b.to]   = - t1p\n            tdown[b.from, b.to] = - t1m\n        \n        # NN reverse direction\n        elseif b.label == 2\n            tup[b.from, b.to]   = - t1m\n            tdown[b.from, b.to] = - t1p\n            \n        # NNN solid bonds\n        elseif b.label == 3\n            tup[b.from, b.to]   = - t2p\n            tdown[b.from, b.to] = - t2p\n\n        # NNN dashed bonds\n        elseif b.label == 4\n            tup[b.from, b.to]   = - t2m\n            tdown[b.from, b.to] = - t2m\n\n        # Fifth nearest neighbors\n        else\n            tup[b.from, b.to]   = - m.t5\n            tdown[b.from, b.to] = - m.t5\n        end\n    end\n\n    return BlockDiagonal(StructArray(tup), StructArray(tdown))\nend","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"We note that the hermitian conjugates of a hopping c_j^dagger c_i can also be understood as reversing the bond direction. Since we include both directions in our lattice definitions, second and fifth nearest neighbor hermitian conjugates are taken care of. First nearest neighbors get a phase shift from complex conjugation, which is included by swapping t1p and t1m between group one and two.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The interaction matrix can almost be copied from the repulsive Hubbard model. The only difference is that the spin up and spin down blocks get the same sign. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"@inline @bm function MonteCarlo.interaction_matrix_exp!(mc::DQMC, m::HBCModel,\n            result::Diagonal, conf::HubbardConf, slice::Int, power::Float64=1.)\n    dtau = mc.parameters.delta_tau\n    lambda = acosh(exp(0.5 * m.U * dtau))\n    N = length(lattice(m))\n    \n    # spin up block\n    @inbounds for i in 1:N\n        result.diag[i] = exp(sign(power) * lambda * conf[i, slice])\n    end\n\n    # spin down block\n    @inbounds for i in 1:N\n        result.diag[N+i] = exp(sign(power) * lambda * conf[i, slice])\n    end\n    nothing\nend","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"In this case we do not need to set the type for the interaction matrix explicitly like we did for the hopping and greens matrices, because the (abstract) HubbardModel already uses Diagonal interaction matrices.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Local-Updates-1","page":"Topological Flat Band Model","title":"Local Updates","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Our next task is to implement propose_local! and accept_local!. Since those only rely on specific indices, columns or rows for a large part of their calculation we have to dig into the optimized matrix types a bit. propose_local aims to calculate the determinant ratio R and bosonic energy difference Delta E_Boson = V(C_new) - V(c_old) where C is the auxiliary field configuration. The determinant ratio is defined as","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"R = prod_sigma left\n        1 + left( exp(Delta E_Boson) - 1 right) \n        left( 1 - G_ii^sigma sigma(tau tau) right)\n    right","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where i and tau are the lattice index and time slice index of the proposed change in the auxiliary field. This formula already assumes that the greens matrix G is zero for all differing spin indices (i.e. spin up-down or down-up). Therefore it is just a product of two terms. With this propose_local is implemented as","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"@inline @bm function MonteCarlo.propose_local(\n        mc::DQMC, model::HBModel, i::Int, slice::Int, conf::HubbardConf\n    )\n    N = length(model.l)\n    G = mc.stack.greens\n    Δτ = mc.parameters.delta_tau\n    R = model.R\n\n    α = acosh(exp(0.5Δτ * model.U))\n    ΔE_boson = -2.0α * conf[i, slice]\n    Δ = exp(ΔE_boson) - 1.0\n\n    # Unrolled R = I + Δ * (I - G)\n    # up-up term\n    R.diag.re[1] = 1.0 + Δ * (1.0 - G.blocks[1].re[i, i])\n    R.diag.im[1] = - Δ * G.blocks[1].im[i, i]\n    # down-down term\n    R.diag.re[2] = 1.0 + Δ * (1.0 - G.blocks[2].re[i, i])\n    R.diag.im[2] = - Δ * G.blocks[2].im[i, i]\n\n    # Calculate \"determinant\"\n    detratio = ComplexF64(\n        R.diag.re[1] * R.diag.re[2] - R.diag.im[1] * R.diag.im[2],\n        R.diag.re[1] * R.diag.im[2] + R.diag.im[1] * R.diag.re[2]\n    )\n    \n    return detratio, ΔE_boson, Δ\nend","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Note that the fields of our special matrix types are directly indexed here. A BlockDiagonal matrix contains all of its data in B.blocks. We define the first (upper left) block as spin up and the second (lower right) as spin down. Sitting at each block is a complex matrix represented by CMat64. It contains two real valued matrices at x.re and x.im representing the real and imaginary parts respectively.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"For accept_local  we need to update the auxiliary field and the currently active greens function. To avoid recalculating Delta it is returned in propose_local and will be passed to accept_local. The updated greens function is given by","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"G_jk^sigma sigma^prime = \n    G_jk^sigma sigma^prime -\n    left(I - G^sigma sigma^prime(tau tau) right)_ji\n    R_sigma sigma^prime^-1 \n    Delta_ii^sigma sigma^prime(tau)\n    G_ik^sigma sigma^prime(tau tau)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where i is again the site index of the proposed flip. Let's go through some observations/simplifications. First we note that for sigma ne sigma^prime the greens function is and remains zero. The inversion of R is an inversion of a diagonal matrix and thus simplifies to calculating the inverse of each element. Finally, Delta has the same value for spin up and spin down so it is simply a number.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Using these observations and applying optimizations relevant to our matrix types accept_local can be implemented as","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"@inline @bm function MonteCarlo.accept_local!(\n        mc::DQMC, model::HBModel, i::Int, slice::Int, conf::HubbardConf, \n        detratio, ΔE_boson, Δ)\n\n    @bm \"accept_local (init)\" begin\n        N = length(model.l)\n        G = mc.stack.greens\n        IG = model.IG\n        IGR = model.IGR\n        R = model.R\n    end\n    \n    # compute R⁻¹ Δ, using that R is Diagonal, Δ is Number\n    # using Δ / (a + ib) = Δ / (a^2 + b^2) * (a - ib)\n    @bm \"accept_local (inversion)\" begin\n        f = Δ / (R.diag.re[1]^2 + R.diag.im[1]^2)\n        R.diag.re[1] = +f * R.diag.re[1]\n        R.diag.im[1] = -f * R.diag.im[1]\n        f = Δ / (R.diag.re[2]^2 + R.diag.im[2]^2)\n        R.diag.re[2] = +f * R.diag.re[2]\n        R.diag.im[2] = -f * R.diag.im[2]\n    end\n\n    # Compute (I - G) R^-1 Δ\n    # Note IG is reduced to non-zero entries. Full IG would be\n    # (I-G)[:, i]        0\n    #     0         (I-G)[:, i+N]\n    # our IG is [(I-G)[:, i]  (I-G)[:, i+N]]\n    @bm \"accept_local (IG, R)\" begin\n        # Calculate IG = I - G (relevant entries only)\n        @turbo for m in axes(IG, 1)\n            IG.re[m, 1] = -G.blocks[1].re[m, i]\n        end\n        @turbo for m in axes(IG, 1)\n            IG.re[m, 2] = -G.blocks[2].re[m, i]\n        end\n        @turbo for m in axes(IG, 1)\n            IG.im[m, 1] = -G.blocks[1].im[m, i]\n        end\n        @turbo for m in axes(IG, 1)\n            IG.im[m, 2] = -G.blocks[2].im[m, i]\n        end\n        IG.re[i, 1] += 1.0\n        IG.re[i, 2] += 1.0\n        \n        # Calculate IGR = IG * R where R = R⁻¹ Δ from the \n        # previous calculation (relevant entries only)\n        # spin up-up block \n        @turbo for m in axes(IG, 1)\n            IGR.re[m, 1] = IG.re[m, 1] * R.diag.re[1]\n        end\n        @turbo for m in axes(IG, 1)\n            IGR.re[m, 1] -= IG.im[m, 1] * R.diag.im[1]\n        end\n        @turbo for m in axes(IG, 1)\n            IGR.im[m, 1] = IG.re[m, 1] * R.diag.im[1]\n        end\n        @turbo for m in axes(IG, 1)\n            IGR.im[m, 1] += IG.im[m, 1] * R.diag.re[1]\n        end\n        \n        # spin down-down block\n        @turbo for m in axes(IG, 1)\n            IGR.re[m, 2] = IG.re[m, 2] * R.diag.re[2]\n        end\n        @turbo for m in axes(IG, 1)\n            IGR.re[m, 2] -= IG.im[m, 2] * R.diag.im[2]\n        end\n        @turbo for m in axes(IG, 1)\n            IGR.im[m, 2] = IG.re[m, 2] * R.diag.im[2]\n        end\n        @turbo for m in axes(IG, 1)\n            IGR.im[m, 2] += IG.im[m, 2] * R.diag.re[2]\n        end\n    end\n\n    # Update G according to G = G - (I - G)[:, i:N:end] * R⁻¹ * Δ * G[i:N:end, :]\n    # We already have IG = (I - G)[:, i:N:end] * R⁻¹ * Δ\n    @bm \"accept_local (finalize computation)\" begin\n        # get blocks to write less\n        G1 = G.blocks[1]\n        G2 = G.blocks[2]\n        temp1 = mc.stack.greens_temp.blocks[1]\n        temp2 = mc.stack.greens_temp.blocks[2]\n\n        # compute temp = IG[:, i:N:end] * G[i:N:end, :]\n        # spin up-up block\n        @turbo for m in axes(G1, 1), n in axes(G1, 2)\n            temp1.re[m, n] = IGR.re[m, 1] * G1.re[i, n]\n        end\n        @turbo for m in axes(G1, 1), n in axes(G1, 2)\n            temp1.re[m, n] -= IGR.im[m, 1] * G1.im[i, n]\n        end\n        @turbo for m in axes(G1, 1), n in axes(G1, 2)\n            temp1.im[m, n] = IGR.im[m, 1] * G1.re[i, n]\n        end\n        @turbo for m in axes(G1, 1), n in axes(G1, 2)\n            temp1.im[m, n] += IGR.re[m, 1] * G1.im[i, n]\n        end\n        \n        # spin down-down block\n        @turbo for m in axes(G2, 1), n in axes(G2, 2)\n            temp2.re[m, n] = IGR.re[m, 2] * G2.re[i, n]\n        end\n        @turbo for m in axes(G2, 1), n in axes(G2, 2)\n            temp2.re[m, n] -= IGR.im[m, 2] * G2.im[i, n]\n        end\n        @turbo for m in axes(G2, 1), n in axes(G2, 2)\n            temp2.im[m, n] = IGR.im[m, 2] * G2.re[i, n]\n        end\n        @turbo for m in axes(G2, 1), n in axes(G2, 2)\n            temp2.im[m, n] += IGR.re[m, 2] * G2.im[i, n]\n        end\n\n        # Calculate G = G - temp\n        # spin up-up block\n        @turbo for m in axes(G1, 1), n in axes(G1, 2)\n            G1.re[m, n] = G1.re[m, n] - temp1.re[m, n]\n        end\n        @turbo for m in axes(G1, 1), n in axes(G1, 2)\n            G1.im[m, n] = G1.im[m, n] - temp1.im[m, n]\n        end\n        \n        # spin down-down block\n        @turbo for m in axes(G2, 1), n in axes(G2, 2)\n            G2.re[m, n] = G2.re[m, n] - temp2.re[m, n]\n        end\n        @turbo for m in axes(G2, 1), n in axes(G2, 2)\n            G2.im[m, n] = G2.im[m, n] - temp2.im[m, n]\n        end\n\n        # Update configuration\n        conf[i, slice] *= -1\n    end\n\n    nothing\nend","category":"page"},{"location":"examples/HofmannBergChowdhury/#Utilities-and-other-functionality-1","page":"Topological Flat Band Model","title":"Utilities and other functionality","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Now that we have the lattice, the hopping and interaction matrix as well as propose_local and accept_local! we're done implementing the model. There are a couple of things one might want to add. For example, adding energy_boson() would enable global updates and boson energy measurements. Adding save_model and _load should help with reducing file size and help future proof things, but isn't strictly necessary. And adding intE_kernel would allow the interactive and total energy to be measured. Beyond that one might add some constructors and convenience function like parameters. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The full code including these convenience functions can be found here","category":"page"},{"location":"examples/HofmannBergChowdhury/#Simulation-Setup-1","page":"Topological Flat Band Model","title":"Simulation Setup","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To keep the runtime of this crosscheck reasonable we used the smallest linear system size the paper considers, L = 8. We also set U = 1 and the fifth nearest neighbor hopping t5 = 0. This corresponds to a flatness ratio F = 02. To be comparable to the paper we will need to tune the chemical potential mu to hit half filling. This can be done through trial and error on a smaller lattice. The optimal mu, after running the main simulation with a small set of different values, seems to be mu approx -2206. Thus the basic setup for our simulation becomes","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"uc = LatticePhysics.getUnitcellSquare(17)\nlpl = getLatticePeriodic(uc, 8)\nl = LatPhysLattice(lpl)\nm = HBModel(l, t5 = 0.0, mu = -2.206) # other defaults match F = 0.2 setup\nmc = DQMC(\n    m, beta = beta, thermalization = 1000, sweeps = 5000, \n    measure_rate = 5, print_rate = 100, recorder = Discarder()\n)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where beta needs to run over a reasonable set of inverse temperatures. We will use [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 10.0, 12.0, 14.0, 17.0, 20.0, 25.0, 30.0, 35.0, 40.0]. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"note: Note\nIn our actual simulation we used a BufferedConfigRecorder to record configurations. That way the simulation can be replayed with different measurements. This is very useful when you are still unsure about what you want to measure or how exactly those measurements are supposed to work.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Measurements-1","page":"Topological Flat Band Model","title":"Measurements","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"We will consider the following measurements for comparison:","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Z-spin susceptibility, solid red line in figure 1d)\nSuperfluid stiffness, figure 2b)\nReciprocal s-wave pairing susceptibility, solid red line in figure 4a)\nReciprocal charge susceptibility, solid blue line in figure 4a)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Z-Spin-Susceptibility-1","page":"Topological Flat Band Model","title":"Z-Spin Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The z-spin susceptibility int_0^beta dtau langle m_z(r^prime tau) m_z(r 0) rangle can be measure with","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:SDSz] = spin_density_susceptibility(mc, m, :z)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The integral will be evaluated by MonteCarlo.jl and the result, accessible with mean(mc[:SDCz]), will return the average result by direction. I.e. mean(mc[:SDCz])[i] will contain the average z-spin susceptibility in directions(mc)[i].","category":"page"},{"location":"examples/HofmannBergChowdhury/#Reciprocal-Charge-Susceptibility-1","page":"Topological Flat Band Model","title":"Reciprocal Charge Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The paper defines the charge susceptibility as int_0^beta dtau langle N(tau) N(0) rangle where N(tau) = sum_j (n_j(tau) - nu) and nu is the filling. The charge density susceptibility that MonteCarlo.jl defines, on the other hand, is langle n_j(tau) n_i(0)rangle. To connect these two we expand the papers' definition:","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"beginaligned\n\tlangle N(tau) N(0) rangle \n        = langle sum_j (n_j(tau) - nu) sum_i (n_i(0) - nu) rangle \n        = sum_ij langle n_j(tau) n_i(0) - n_j(tau) nu - nu n_i(0) + nu nu rangle \n        = sum_ij langle n_j(tau) n_i(0) rangle - langle sum_i n_i rangle^2\nendaligned","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"In the last step we associated nu = sum_i langle n_i rangle  N, i.e. the average occupation. We can use this representation to calculate the reciprocal charge susceptibility as 1  (O - nu^2) where O is MonteCarlo.jl's charge density susceptibility and nu is the average occupation. We measure","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:occ] = occupation(mc, m)\nmc[:CDS] = charge_density_susceptibility(mc, m)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Reciprocal-S-Wave-Pairing-Susceptibility-1","page":"Topological Flat Band Model","title":"Reciprocal S-Wave Pairing Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The paper defines the (s-wave) pairing susceptibilities as O(tau) = sum_j c_j uparrow c_j downarrow + hc. More generally you would consider a site offset between the pairs of operators and use weighted sums to get pairing susceptibilities of various symmetries like d-wave, p-wave, etc. For s-wave this offset is vec0. In MonteCarlo.jl these offsets are set via the lattice iterator. For example you may use EachLocalQuadByDistance([2, 4, 5]) to consider the directions(mc)[[2, 4, 5]] as offsets. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The pairing_suceptibility constructors from MonteCarlo.jl is written with these offsets in mind. By default it will include offsets for all nearest neighbors as well as offsets of vec0. To reduce computational complexity we may reduce these to just vec0 offsets by requesting just first offset:","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:PS] = pairing_susceptibility(mc, m, 1)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Superfluid-Stiffness-1","page":"Topological Flat Band Model","title":"Superfluid Stiffness","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The superfluid stiffness is given by 025 - K_x - Lambda_xx(q = 0) in the paper. Both the diamagnetic contribution K_x and the Fourier transformed current-current correlation Lambda_xx(q) are things we need to measure individually.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The diamagnetic contribution K_x is the simpler one. For that we refer to equations 15a - 15j in the paper. The sum of all of these is the K_x we seek. Since all terms are quadratic in creation and annihilation operators we do not need to worry about expanding them with Wicks theorem. Instead we can simply measure the Greens matrix during the simulation. If we compare the equations with the Hamiltonian we will also notice that they are (almost) the same as the hopping terms. Thus we can get weights from the hopping matrix and apply them afterwards. We measure","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:G] = greens_measurement(mc, model)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"For the current-current correlations we need to measure int_0^beta d tau langle J_x^alpha(r^prime tau) J_x^beta(r 0) rangle where J_x(r tau) is given in equation 14a - 14j. These terms are already implemented by MonteCarlo.jl, but we should briefly discuss them regardless. (We will leave the Fourier transform for later.) ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Much like K_x these terms are closely related to the hopping terms of the Hamiltonian. The index alpha (beta) refers to the direction of the hopping. Each term contains a hopping in +x direction weighted by i and a hopping in the opposite direction weighted by -i via the Hermitian conjugate. The fifth nearest neighbor terms also catch a factor 2. For the measurement we need to apply Wicks theorem to every combination of any two currents J^alpha_x and also take care of an implied spin index. The result can be found in the cc_kernel in MonteCarlo.jl.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Let's get back to what we need to measure in our simulation. MonteCarlo.jl's current_current_susceptibility measures int_0^beta d tau langle J_x^alpha(r^prime tau) J_x^beta(r 0) rangle where alpha and beta are directions that get passedto the function. Since we set t5 = 0 we can ignore equations 14g - 14j leaving 6 equations with 3 directions on 2 sublattices. MonteCarlo.jl does not care about sublattices, so we're left with three +x directions [2, 6, 9] which need to be passed. You can check these with directions(mc)[[2, 6, 9]] against the paper. Our measurement is given by","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:CCS] = current_current_susceptibility(mc, model, [2, 6, 9])","category":"page"},{"location":"examples/HofmannBergChowdhury/#Running-the-simulations-1","page":"Topological Flat Band Model","title":"Running the simulations","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To run the simulation we simply use run!(mc).","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"We should point out that these simulations are lot more complex than the other two examples. We are working with 128 sites as opposed to 16 and inverse temperatures as large as 40 instead of le 12. We are also using complex matrices which bring 2 - 4 times the complexity and we need to consider both a spin up and down sector in the greens matrix. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"It is therefore advised that you run this on a cluster, in parallel. To figure out how much time is needed you can check the sweep time for the smallest beta with measurements. The scaling should be roughly linear (w.r.t. beta). Note that you can pass a safe_before::TimeType to make sure the simulation saves and exits in time. If your cluster restricts you to full nodes it might be useful to create files for each simulation beforehand and distribute filenames to different cores on the same node. (src/mpi.jl might be helpful.)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Results-1","page":"Topological Flat Band Model","title":"Results","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"In this section we plot the results from our simulations on top of the results from the paper. There are 5 points per temperature coming from different chemical potentials mu. The filling varies from 0.22 to 0.265 between them. Note also that not every simulation did the full number of sweeps. The shortest simulation ran for about 3000 sweeps, which includes 1000 thermalization sweeps.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Z-Spin-Susceptibility-2","page":"Topological Flat Band Model","title":"Z-Spin Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To get the results from the paper we need to perform a q = 0 Fourier transform which is simply a sum. We calculate real(sum(mean(mc[:SDCz]))) and plot against 1 / mc.parameters.beta.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"examples/HofmannBergChowdhury/#Reciprocal-Charge-Susceptibility-2","page":"Topological Flat Band Model","title":"Reciprocal Charge Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"For the reciprocal charge susceptibility we plot","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"CDS = real(sum(mean(mc[:CDS])))\nocc = real(sum(mean(mc[:occ])))\nxs = 1 / mc.parameters.beta\nys = 1 / (CDS - mc.parameters.beta * occ^2 / length(lattice(mc)))","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where the factor mc.parameters.beta / length(lattice(mc)) comes from the imaginary time integral.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"examples/HofmannBergChowdhury/#Reciprocal-Pairing-Susceptibility-1","page":"Topological Flat Band Model","title":"Reciprocal Pairing Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The pairing susceptibility comes with three directional indices after taking mean(mc[:PS]). The first is associated with the distance r - r^prime between the two pairing operators Delta(r) in langle Delta^alpha(r) Delta^beta(r^prime) rangle. The second and third are displacements inside them. Since we only care about s-wave pairing the internal displacements are zero or index 1. Thus we plot 1 / real(sum(mean(mc[:PS])[:, 1, 1])) against 1 / mc.parameters.beta for the reciprocal pairing susceptibility. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"examples/HofmannBergChowdhury/#Superfluid-Stiffness-2","page":"Topological Flat Band Model","title":"Superfluid Stiffness","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The superfluid stiffness still requires a good amount of work. Let's start with the diamagnetic contribution K_x. As mentioned before the prefactors of K_x match those of the hoppings in the Hamiltonian (except for 5th nearest neighbors which catch a factor of 4). The expectation values for langle c_j^dagger c_i rangle follow from the measured Greens function G_ij = c_i c_j^dagger as delta_ij - G_ji (permutation of operators).","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To pick the correct sites we can poke at the backend of the lattice iterator interface. There are a few maps that get cached, one of which returns a list of (source, target) site index pairs given a directional index. It can be fetched (and potentially generated) via dir2srctrg = mc[Dir2SrcTrg()]. The relevant directional indices can be determined from directions(mc). Using that we calculate the total diamagnetic contribution K_x as","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"function dia_K_x(mc)\n    # directional indices for K_x (see directions(mc)[idxs]\n    # These correspond to \n    # K1 & K4, K1 & K4 h.c., K2 & K5, K3 & K6 h.c., K2 & K5 h.c., K3 & K5\n    idxs = [2, 4, 6, 7, 8, 9]\n    \n    # T contains the prefactors used in K_x, G contains ⟨c_i c_j^†⟩\n    T = Matrix(MonteCarlo.hopping_matrix(mc, mc.model))\n    G = mean(mc[:G])\n\n    # We use the dir2srctrg map to get all (src, trg) pairs relevant to the \n    # directions we specified with `idxs` above\n    dir2srctrg = mc[MonteCarlo.Dir2SrcTrg()]\n    N = length(lattice(mc))\n    \n    Kx = ComplexF64(0)\n    for dir_idx in idxs\n        for (src, trg) in dir2srctrg[dir_idx]\n            # c_j^† c_i = δ_ij - G[i, j], but δ always 0 (no onsite)\n            Kx -= T[trg, src] * G[src, trg]         # up-up\n            Kx -= T[trg+N, src+N] * G[src+N, trg+N] # down-down\n        end\n    end\n\n    # normalize\n    Kx /= N\nend","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"For the Fourier transformed current-current correlation Lambda_xx(q) the paper uses two summations. The first (eq. 16) runs over positions without offsets from the basis. The second (eq. 17) then resolves those offsets with a shift by hate_y and also translates positions to the centers of the two sites involved with each hopping term. Combining both equations in a MonteCarlo.jl compatible style yields","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Lambda_xx(q) = sum_Delta r_12 sum_Delta r_1 Delta r_2 e^- i q (Delta r_12 + 05 (Delta r_1 - Delta r_2))\n                  int_0^beta sum_r_0 langle J_x^Delta r_1(r_0 + Delta r_12 tau) J_x^Delta r_2(r_0 0) rangle dtau\n","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Here Delta r_12 is the distance between any two sites including basis offsets and Delta r_1 and Delta r_2 are the hopping distances. The integral over imaginary time and the sum over r_0 are already performed during measuring. This leaves the following to be calculated after measuring:","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"function para_ccc(mc, q)\n    # direction indices for J1 & J4, J2 & J5, J3 & J6 (h.c. included in measurement)\n    idxs = [2, 6, 9]\n\n    CCS = mean(mc[:CCS])\n    dirs = directions(lattice(mc))\n    Λxx = ComplexF64(0)\n\n    for (i, dir) in enumerate(dirs)\n        for j in idxs, k in idxs\n            Λxx += CCS[i, j, k] * cis(-dot(dir + 0.5(dirs[j] .- dirs[k]), q))\n        end\n    end\n    \n    Λxx\nend","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To compute the superfluid stiffness we now just calculate D_S = frac14  -K_x - Lambda_xx(q = 0) (eq. 4).","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"legacy/lattices/#Lattices-1","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"The package ships with a couple of standard lattices","category":"page"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"Type Description\nMonteCarlo.Chain 1-dimensional chain\nMonteCarlo.SquareLattice 2-dimensional square lattice\nMonteCarlo.CubicLattice D-dimensional cubic lattice","category":"page"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"It also provides routines to load the following common lattice formats","category":"page"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"Type Description\nMonteCarlo.ALPSLattice ALPS simple lattice graph (XML file)","category":"page"},{"location":"legacy/lattices/#Didn't-find-your-desired-lattice?-1","page":"Lattices","title":"Didn't find your desired lattice?","text":"","category":"section"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"Just implement your own lattice for later use in a model of choice. See Custom lattices.","category":"page"},{"location":"legacy/customize/#Customize-1","page":"Customize","title":"Customize","text":"","category":"section"},{"location":"legacy/customize/#Custom-models-1","page":"Customize","title":"Custom models","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Although MonteCarlo.jl already ships with famous models, foremost the Ising and Hubbard models, the central idea of the design of the package is to have a (rather) well defined interface between models and Monte Carlo flavors. This way it should be easy for you to extend the package and implement your own physical model (or variations of existing models). You can find the interfaces in the corresponding section of the documentation, for example: Interface: Monte Carlo (MC).","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Sometimes examples tell the most, so feel encouraged to have a look at the implementations of the above mentioned models to get a feeling of how to implement your own model.","category":"page"},{"location":"legacy/customize/#General-remarks-for-lattice-models-1","page":"Customize","title":"General remarks for lattice models","text":"","category":"section"},{"location":"legacy/customize/#Semantics-1","page":"Customize","title":"Semantics","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"For lattice models, we define a Model to be a Hamiltonian on a lattice. Therefore, the lattice is part of the model (and not the Monte Carlo flavor). The motivation for this modeling is that the physics of a system does not only depend on the Hamiltonian but also (sometime drastically) on the underlying lattice. This is for example very obvious for spin systems which due to the lattice might become (geometrically) frustrated and show spin liquids physics. Also, from a technical point of view, lattice information is almost exclusively processed in energy calculations which both relate to the Hamiltonian (and therefore the model).","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"note: Note\nWe will generally use the terminology Hamiltonian, energy and so on. However, this doesn't restrict you from defining your model as an Lagrangian with an action in any way as this just corresponds to a one-to-one mapping of interpretations.","category":"page"},{"location":"legacy/customize/#Lattice-requirements-1","page":"Customize","title":"Lattice requirements","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"The Hamiltonian of your model might impose some requirements on the AbstractLattice object that you use as it must provide you with enough lattice information.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"It might be educating to look at the structure of the simple SquareLattice struct.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"mutable struct SquareLattice <: AbstractCubicLattice\n   L::Int\n   sites::Int\n   neighs::Matrix{Int} # row = up, right, down, left; col = siteidx\n   neighs_cartesian::Array{Int, 3} # row (1) = up, right, down, left; cols (2,3) = cartesian siteidx\n   sql::Matrix{Int}\n   SquareLattice() = new()\nend","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"It only provides access to next nearest neighbors through the arrays neighs and neighs_cartesian. If your model's Hamiltonian requires higher order neighbor information, because of, let's say, a next next nearest neighbor hopping term, the SquareLattice doesn't suffice. You could either extend this lattice or implement a NNSquareLattice for example.","category":"page"},{"location":"legacy/customize/#Custom-lattices-1","page":"Customize","title":"Custom lattices","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"As described in Custom models a lattice is considered to be part of a model. Hence, most of the requirements for fields of a AbstractLattice subtype come from potential models (see Lattice requirements). Below you'll find information on which fields are mandatory from a Monte Carlo flavor point of view.","category":"page"},{"location":"legacy/customize/#Mandatory-fields-1","page":"Customize","title":"Mandatory fields","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Any concrete lattice type, let's call it MyLattice in the following, must be a subtype of the abstract type MonteCarlo.AbstractLattice. To work with a Monte Carlo flavor, it must internally have at least have the following field,","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"sites: number of lattice sites.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"However, as already mentioned above depending on the physical model of interest it will typically also have (at least) something like","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"neighs: next nearest neighbors,","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"as most Hamiltonian will need next nearest neighbor information.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"The only reason why such a field isn't generally mandatory is that the Monte Carlo routine doesn't care about the lattice much. Neighbor information is usually only used in the energy (difference) calculation of a particular configuration like done in energy or propose_local which both belong to a Model.","category":"page"},{"location":"legacy/customize/#Custom-Monte-Carlo-flavors-1","page":"Customize","title":"Custom Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Coming soon...","category":"page"},{"location":"legacy/interfaces/DQMC/#Interface:-Determinant-Quantum-Monte-Carlo-(DQMC)-1","page":"DQMC","title":"Interface: Determinant Quantum Monte Carlo (DQMC)","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Any model that wants to be simulated by means of DQMC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the determinant Monte Carlo flavor Determinant Quantum Monte Carlo (DQMC).","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Example models: Attractive Hubbard Model","category":"page"},{"location":"legacy/interfaces/DQMC/#Mandatory-fields-1","page":"DQMC","title":"Mandatory fields","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"l::AbstractLattice: any AbstractLattice\nflv::Int: number of distinct fermion flavors (e.g. spins, bands, etc.). The Green's function will have shape (flv*N, flv*N), where N is the number of sites. Note that different fermion flavors are often related by symmetry and it's advisable to use this symmetry to work with smaller Green's function matrices. Have a look at the Attractive Hubbard Model as an example where flv=1 although it has spinful fermions.","category":"page"},{"location":"legacy/interfaces/DQMC/#Index-of-all-methods-1","page":"DQMC","title":"Index of all methods","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Pages = [\"DQMC.md\"]","category":"page"},{"location":"legacy/interfaces/DQMC/#Mandatory-methods-1","page":"DQMC","title":"Mandatory methods","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"CurrentModule = MonteCarlo","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"conftype(::Type{DQMC}, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"rand(::DQMC, ::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"hopping_matrix(mc::DQMC, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.hopping_matrix-Tuple{DQMC, Model}","page":"DQMC","title":"MonteCarlo.hopping_matrix","text":"hopping_matrix(mc::DQMC, m::Model)\n\nCalculates the hopping matrix T_isigma jsigma  where i j are  site indices and sigma  sigma  are flavor indices (e.g. spin indices).  The hopping matrix should also contain potential chemical potential terms on the  diagonal.\n\nA matrix element is the hopping amplitude for a hopping process: jsigma   rightarrow isigma.\n\nRegarding the order of indices, if T[i, σ, j, σ'] is your desired 4D hopping  array, then reshape(T, (n_sites * n_flavors, :)) is the hopping matrix.\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"interaction_matrix_exp!(mc::DQMC, m::Model, result::Matrix, conf, slice::Int, power::Float64=1.)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.interaction_matrix_exp!","page":"DQMC","title":"MonteCarlo.interaction_matrix_exp!","text":"interaction_matrix_exp!(\n    mc::DQMC, m::Model, field::AbstractField, \n    result::AbstractArray, slice::Int, power::Float64 = 1.0\n)\n\nCalculate the, exponentiated interaction matrix  exp(- power * delta_tau * V(slice)) and store it in result::AbstractArray. \n\nThis only includes terms with 4 operators, i.e. not the chemical potential or  any hoppings. By default the calculation will be performed by the appropriate  field type (i.e. by interaction_matrix_exp!(field, result, slice, power))\n\nBy default this function will call  interaction_matrix_exp!(field, result, slice, power).\n\nThis is a performance critical method and one might consider efficient in-place  (in result) construction.\n\n\n\n\n\n","category":"function"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"propose_local(mc::DQMC, m::Model, i::Int, conf, E_boson::Float64)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.propose_local-Tuple{DQMC, Model, Int64, Any, Float64}","page":"DQMC","title":"MonteCarlo.propose_local","text":"propose_local(mc::DQMC, m::Model, field::AbstractField, i::Int, slice::Int)\n\nPropose a local move for lattice site i at time slice slice for a field  holding the current configuration. Returns the Green's function determinant  ratio, the boson energy difference ΔE_boson = E_boson_new - E_boson, and any extra information passthrough that might be useful in accept_local.\n\nBy default this function will call propose_local(mc, field, i, slice).\n\nSee also accept_local!.\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"accept_local(mc::DQMC, m::Model, i::Int, slice::Int, conf, delta, detratio, delta_E_boson)","category":"page"},{"location":"legacy/interfaces/DQMC/#Optional-methods-1","page":"DQMC","title":"Optional methods","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"greenseltype(::Type{DQMC}, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"energy_boson(mc::DQMC, m::Model, conf)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.energy_boson-Tuple{DQMC, Model, Any}","page":"DQMC","title":"MonteCarlo.energy_boson","text":"energy_boson(mc::DQMC, model::Model, conf)\n\nCalculate bosonic part (non-Green's function determinant part) of energy for  configuration conf for Model m.\n\nThis is required for global and parallel updates as well as boson energy  measurements, but not for local updates. By default calls  energy_boson(field(mc), conf)\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"prepare_observables(mc::DQMC, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"measure_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable}, conf)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"finish_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable})","category":"page"},{"location":"legacy/flavors/mc/#Monte-Carlo-(MC)-1","page":"MC","title":"Monte Carlo (MC)","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"This is plain simple Monte Carlo (MC). It can for example be used to simulate the Ising model (see 2D Ising model).","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"You can initialize a Monte Carlo simulation of a given model simply through","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"mc = MC(model)","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Allowed keywords are:","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"beta: inverse temperature\nsweeps: number of measurement sweeps\nthermalization: number of thermalization (warmup) sweeps\nglobal_moves: wether global moves should be proposed\nglobal_rate: frequency for proposing global moves\nseed: initialize MC with custom seed","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Afterwards, you can run the simulation by","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"run!(mc)","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Note that you can just do another run!(mc, sweeps=1000) to continue the simulation.","category":"page"},{"location":"legacy/flavors/mc/#Examples-1","page":"MC","title":"Examples","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model.","category":"page"},{"location":"legacy/flavors/mc/#Exports-1","page":"MC","title":"Exports","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"MC.jl\"]","category":"page"},{"location":"legacy/flavors/mc/#MonteCarlo.replay!","page":"MC","title":"MonteCarlo.replay!","text":"replay(mc::MC[, configurations::Iterable = mc.configs; kwargs...])\n\nReplays previously generated configurations and measures observables along the way.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, replay! will generate a\n\nresumable save file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nfilename: Name of the save file. The default is based on safe_before.\nmeasure_rate = 1: Rate at which measurements are taken. Note that this is \n\nbased on the recorded configurations, not actual sweeps.\n\n\n\n\n\n","category":"function"},{"location":"legacy/flavors/mc/#MonteCarlo.run!-Tuple{MC}","page":"MC","title":"MonteCarlo.run!","text":"run!(mc::MC[; kwargs...])\n\nRuns the given Monte Carlo simulation mc. Returns true if the run finished and false if it cancelled early to generate a resumable save-file.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nthermalization: Number of thermalization sweeps. Uses the value passed to\n\nDQMC by default.\n\nsweeps: Number of measurement sweeps. Uses the value passed to DQMC by\n\ndefault.\n\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, run! will generate a resumable\n\nsave file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nresumable_filename: Name of the resumable save file. The default is based on\n\nsafe_before.\n\noverwrite = false: If set to true a file with the same name as\n\nresumable_filename will be overwritten. (This will create a temporary backup)\n\nSee also: resume!\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/mc/#MonteCarlo.MC","page":"MC","title":"MonteCarlo.MC","text":"Monte Carlo simulation\n\n\n\n\n\n","category":"type"},{"location":"legacy/flavors/mc/#MonteCarlo.MC-Tuple{M} where M<:Model","page":"MC","title":"MonteCarlo.MC","text":"MC(m::M; kwargs...) where M<:Model\n\nCreate a Monte Carlo simulation for model m with keyword parameters kwargs.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/mc/#MonteCarlo.MC-Union{Tuple{T}, Tuple{Model, Dict{Symbol, T}}} where T","page":"MC","title":"MonteCarlo.MC","text":"MC(m::M, params::Dict)\nMC(m::M, params::NamedTuple)\n\nCreate a Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/mc/#Potential-extensions-1","page":"MC","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Heat bath (instead of Metropolis) option","category":"page"},{"location":"DQMC/lattice/#Lattices-1","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Lattices are a generic component for both quantum and classical Monte Carlo simulations. At this point they are part of the model. We currently offer a couple of directly implemented lattices, an interface for loading ALPS lattices and an interface to LatticePhysics.jl.","category":"page"},{"location":"DQMC/lattice/#Available-Lattices-1","page":"Lattices","title":"Available Lattices","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"We currently have the following lattices. Unless mentioned, they all include nearest neighbor bonds.","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Chain(N): A one dimensional chain lattice with N sites.\nSquareLattice(L): A two dimensional square lattice with L² sites.\nCubicLattice(D, L): A D dimensional cubic lattice with L^D sites.\nTriangularLattice(L[; Lx = L, Ly = L]): A two dimensional triangular lattice with Lx * Ly sites. This lattice also includes next nearest neighbor bonds.","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Additionally we have ALPSLattice(file) which loads an ALPS lattice from an xml file and LatPhysLattice(lattice) which wraps a generic lattice from LatticePhysics.jl.","category":"page"},{"location":"DQMC/lattice/#Implementing-your-own-Lattice-1","page":"Lattices","title":"Implementing your own Lattice","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"If you want to implement your own lattice you need to implement a couple of things for compatibility. Your lattice should inherit from MonteCarlo.AbstractLattice. It should implement a method length(lattice) returning the total number of sites.  The more complex lattice iterators require a method positions(lattice) returning the positions of each site in matching order, and a method lattice_vectors(lattice) returning D vectors pointing from one end of the lattice to the other along nearest neighbor directions, where D is the dimensionality of the lattice.  If you are using the default models you will also need to implement some way to get nearest neighbor directions. You have two options here - either implement some traits and fields or implement the getter function directly. For the first option you need to implement: ","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"the field neighs::Matrix{Int} with target = neighs[neighbor_idx, source] and has_neighbors_table(lattice) = true\nthe field bonds::Matrix{Int} where (source, target, type) = bonds[total_bond_idx, :] and has_bonds_table(lattice) = true","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"For the second option you need to write your own neighbors(lattice, directed) where directed = Val{true} returns forward and backwards facing bonds and directed = Val{false} considers those the same, returning only one of them.","category":"page"},{"location":"DQMC/lattice/#Lattice-Iterators-1","page":"Lattices","title":"Lattice Iterators","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Lattice Iterators are to some degree a backend component. They specify and often cache a way to iterate through the lattice. They are mainly used for DQMC measurements, which frequently require specific pairing of sites. There are currently three abstract subtypes of lattice iterators, each with multiple concrete types. Each concrete iterator can be created via iterator(dqmc, model).","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"First we have DirectLatticeIterator. These iterators return just site indices, e.g. (source_index, target_index). The concrete implementations include:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"EachSiteAndFlavor iterates all indices from 1 to length(lattice) * nflavors(model)\nEachSite iterates all indices from 1 to length(lattice)\nOnSite also iterates from 1:length(lattice), however returns two indices (i, i) at each step\nEachSitePair iterates through all possible pairs (i, j) where both i and j run from 1 to length(lattice).","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Next we have DeferredLatticeIterator. These iterators return some meta information with each site index, for example a directional index. They are used to do partial summation. The concrete implementations include:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"EachSitePairByDistance which iterates the same range as EachSitePair but returns (dir_idx, i, j) at each step.\nEachLocalQuadByDistance{K} iterates through four sets (1, length(lattice)), returning (combined_dir_idx, src1, trg1, src2, trg2) at each step. Here the directional index relates to three directional indices (dir_idx, dir_idx1, dir_idx2) representing the vectors between src1 and src2, src1 and trg1, and src2 and trg2 respectively. K restricts the included number of bonds between src1 and trg1 (and src2 and trg2). Note that an on-site connection is also counted here - i.e. to include four nearest neighbors you must set K = 5.\nEachLocalQuadBySyncedDistance{K} does the same thing as EachLocalQuadByDistance{K} with the additional of synchronizing the direction between (src1, trg1) and (src2, trg2).","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Note that you can get the directions matching the indices from directions(lattice/model/dqmc).","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Lastly we have LatticeIterationWrapper{LI <: LatticeIterator}. Generally results from DeferredLatticeIterators will be saved in a vector, where values[dir_idx] is the sum of all values with the same directional index. The wrappers are there to further process what happens to these values before they are saved. The parametric type of them specifies the iteration procedure that is used. The concrete implementations are:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Sum{LI} tells the measurement to sum up all values before saving.\nApplySymmetry{LI}(symmetries...) tells the measurement to do sum directional indices past the first with some weights given as symmetries. For example you may use ApplySymmetry{EachLocalQuadByDistance}([1], [0, 1, 1, 1, 1]) to generate s-wave and extended s-wave summations for square lattices.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"(Image: logo)","category":"page"},{"location":"legacy/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is a Julia software library for the simulation of physical models by means of the Markov Chain Monte Carlo technique. The package implements classical and quantum Monte Carlo flavors which can be used to study spin systems, interacting fermions, and boson-fermion mixtures.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe documentation is out-of-date!","category":"page"},{"location":"legacy/#Included-models:-1","page":"Introduction","title":"Included models:","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Ising model\nAttractive Hubbard model","category":"page"},{"location":"legacy/#Included-Monte-Carlo-flavors-1","page":"Introduction","title":"Included Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Classical Monte Carlo\nDeterminant Quantum Monte Carlo (also known as auxiliary field Monte Carlo)","category":"page"},{"location":"legacy/#Included-lattices-1","page":"Introduction","title":"Included lattices","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Cubic lattices (chain, square, cube, ...)\nAny ALPS lattice","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Have a look at the Showcase section to get some inspiration.","category":"page"},{"location":"legacy/#Study-your-own-model-1","page":"Introduction","title":"Study your own model","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"A major idea behind the design of the package is convenient customization. Users should be able to define their own custom physical models (or extend existing ones) and explore their physics through Monte Carlo simulations. We hope that MonteCarlo.jl allows the user to put his focus on his physical model rather than tedious implementations of Monte Carlo schemes.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"To that end, each (quantum) Monte Carlo flavor has a well-defined model interfaces, i.e. a precise specification of mandatory and optional fields and methods. An example can be found here: Interface: Monte Carlo (MC). Practically, it makes sense to start by taking a look at the implementation of one of the predefined models.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"If you implement a custom model that might be worth being added to the collection of supplied models, please consider creating a pull request!","category":"page"},{"location":"legacy/#GitHub-1","page":"Introduction","title":"GitHub","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is open-source. The source code can be found on github. Criticism and contributions are very much welcome - just open an issue. For more details see the Contribution Guide.","category":"page"},{"location":"legacy/models/ising/#Ising-Model-1","page":"Ising model","title":"Ising Model","text":"","category":"section"},{"location":"legacy/models/ising/#Hamiltonian-1","page":"Ising model","title":"Hamiltonian","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"The famous Hamiltonian of the Ising model is given by","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"\\begin{align} \\mathcal{H} = -\\sum{\\langle i,j \\rangle} \\sigmai \\sigma_j , \\end{align}","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"where langle i j rangle indicates that the sum has to be taken over nearest neighbors.","category":"page"},{"location":"legacy/models/ising/#Creating-an-Ising-model-1","page":"Ising model","title":"Creating an Ising model","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"You can create an Ising model as follows,","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"model = IsingModel(; dims::Int=2, L::Int=8)","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"The following parameters can be set via keyword arguments:","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"dims: dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)\nL: linear system size","category":"page"},{"location":"legacy/models/ising/#Supported-Monte-Carlo-flavors-1","page":"Ising model","title":"Supported Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Monte Carlo (MC) (Have a look at the examples section below)","category":"page"},{"location":"legacy/models/ising/#Examples-1","page":"Ising model","title":"Examples","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model.","category":"page"},{"location":"legacy/models/ising/#Exports-1","page":"Ising model","title":"Exports","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"IsingModel.jl\"]","category":"page"},{"location":"legacy/models/ising/#MonteCarlo.IsingModel","page":"Ising model","title":"MonteCarlo.IsingModel","text":"Famous Ising model on a cubic lattice.\n\nIsingModel(; dims, L)\n\nCreate Ising model on dims-dimensional cubic lattice with linear system size L.\n\n\n\n\n\n","category":"type"},{"location":"legacy/models/ising/#MonteCarlo.IsingModel-Union{Tuple{Dict{Symbol, T}}, Tuple{T}} where T","page":"Ising model","title":"MonteCarlo.IsingModel","text":"IsingModel(params::Dict)\nIsingModel(params::NamedTuple)\n\nCreate an Ising model with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"legacy/models/ising/#Analytic-results-1","page":"Ising model","title":"Analytic results","text":"","category":"section"},{"location":"legacy/models/ising/#Square-lattice-(2D)-1","page":"Ising model","title":"Square lattice (2D)","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"The model can be solved exactly by transfer matrix method (Onsager solution). This gives the following results.","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Critical temperature: T_c = frac2ln1+sqrt2","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Magnetization (per site): m = left(1-leftsinh 2beta right^-4right)^frac 18","category":"page"},{"location":"legacy/models/ising/#Potential-extensions-1","page":"Ising model","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Arbitrary dimensions\nMagnetic field\nMaybe explicit J instead of implicit J=1\nNon-cubic lattices (just add lattice::AbstractLattice keyword)","category":"page"},{"location":"examples/ALF1/#Crosscheck-with-ALF-1","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The ALF project (Algorithms for lattice fermions) is a long running project implementing DQMC in Fortran. They have implemented various different models, lattices, stabilization methods and measurements. A relatively simple comparison for us will be the \"plain vanilla Hubbard model\" on a square lattice, which is close to but not exactly the same as our repulsive Hubbard model.","category":"page"},{"location":"examples/ALF1/#The-ALF-Simulation-1","page":"Crosscheck with ALF","title":"The ALF Simulation","text":"","category":"section"},{"location":"examples/ALF1/#Installation-1","page":"Crosscheck with ALF","title":"Installation","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The ALF project provides a python interface which we used for simplicity. For installation instructions see the link. At the time of writing pyALF is linked to ALF 2.0. (Specifically commit 82949f66065eff8214c0149c8be2d10d6d0a6822.)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"note: Note\nYou can also add a load path for pyALF temporarily in an active python session. Try import sys and sys.path.append('path/to/pyALF-ALF-2.0/').","category":"page"},{"location":"examples/ALF1/#Usage-1","page":"Crosscheck with ALF","title":"Usage","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"With python, pyALF and the necessary packages installed we can now setup and run simulations. In python, we run:","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"import os\nfrom py_alf import Simulation        # Interface with ALF\n\nsims = []                            # Vector of Simulation instances\nfor beta in [1.0, 6.0, 12.0]:        # Values of inverse temperature beta\n    sim = Simulation(\n        'Hubbard',                   # Hamiltonian\n        {                            # Model and simulation parameters for each Simulation instance\n        'Model': 'Hubbard',          #    Base model\n        'Lattice_type': 'Square',    #    Lattice type\n        'L1': 4,                     #    Lattice length in the first unit vector direction\n        'L2': 4,                     #    Lattice length in the second unit vector direction\n        'Checkerboard': False,       #    Whether checkerboard decomposition is used or not\n        'Symm': True,                #    Whether symmetrization takes place\n        'ham_T': 1.0,                #    Hopping parameter\n        'ham_U': 4.0,                #    Hubbard interaction\n        'ham_Tperp': 0.0,            #    For bilayer systems\n        'beta': beta,                #    Inverse temperature\n        'Ltau': 1,                   #    '1' for time-displaced Green functions; '0' otherwise \n        'NSweep': 100,                #    Number of sweeps per bin\n        'N_skip': 10,                #    skip 50 bins meaning 50x NSweep\n        'NBin': 60,                 #    Number of bins\n        'Dtau': 0.1,                 #    Only dtau varies between simulations, Ltrot=beta/Dtau\n        'Mz': True,                  #    If true, sets the M_z-Hubbard model: Nf=2, N_sum=1,\n        },                           #             HS field couples to z-component of magnetization\n        alf_dir=os.getenv('ALF_DIR', './ALF'), # Directory with ALF source code. Gets it from \n                                               # environment variable ALF_DIR, if present\n    )\n    sims.append(sim)\n\nsims[0].compile()                        # Compilation needs to be performed only once\n\nimport time\n\nprint(\"\\nRunning sims\\n\")\nfor i, sim in enumerate(sims):\n    t0 = time.time()\n    sim.run()                            # Perform the actual simulation in ALF\n    print(time.time() - t0)\n    \nprint(\"\\nAnalysis:\\n\")\nfor i, sim in enumerate(sims):\n    print(sim.sim_dir)                   # Directory containing the simulation output\n    sim.analysis()","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Let's briefly go over some of the options picked here. One noteworthy option is Symm. With it you can switch between a symmetric (True) and antisymmetric (False) Trotter decomposition. In MonteCarlo.jl we use the symmetric version so we should do so here too. Next we have Ltau. As mentioned in the comment this controls whether time displaced greens function are calculated, and by extension whether time displaced observables (susceptibilties) are calculated. We want to compare as much as possible so we set Ltau = 1. ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"And finally we have the combination of NSweep, N_skip and NBin. NSweep is the number of sweeps in a block, which is usually followed by a measurement. NBin sets how many of those blocks are executed and N_skip disables measurements for some number of blocks at the start. Thus we have the relations thermalization = NSweep * N_skip, sweeps = NSweep * (NBin - N_skip) and measure_rate = NSweep. ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Regarding the choices for NSweep, N_skip and NBin it is also important to discuss the model ALF implements and how it is implemented. As mentioned before it is not quite the same as the repulsive Hubbard model from DQMC. ALF implements","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"mathcalH=\n- t sumlimits_langle i j rangle  sigma=uparrowdownarrow \nleft(  hatc^dagger_i sigma hatc^phantomdagger_jsigma  + textHc right) \n- fracU2sumlimits_ileft\nhatc^dagger_i uparrow hatc^phantomdagger_i uparrow  -   hatc^dagger_i downarrow hatc^phantomdagger_i downarrow  right^2   \n-  mu sum_isigma  hatc^dagger_i sigma  hatc^phantomdagger_isigma ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"which features a quadratic interaction rather than the sim (n_uparrow - 05)(n_downarrow - 05) term used in MonteCarlo.jl. If we apply a Hirsch transformation (like in MonteCarlo.jl) to both of these interactions, we end up with the same expression. Thus they would be the same from the simulations point of view. However ALF uses a different, (potentially) more precise transformation based on Gauß-Hermite quadrature. Thus some small differences are to be expected.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"For more information on the Hamiltonian and transformation used by ALF see the ALF documentation","category":"page"},{"location":"examples/ALF1/#The-MonteCarlo.jl-Simulation-1","page":"Crosscheck with ALF","title":"The MonteCarlo.jl Simulation","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The MonteCarlo.jl simulation should more or less mirror the options picked for ALF. We run ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"using Revise, MonteCarlo, Printf, LinearAlgebra\n\nmcs = []\n@time for beta in [1.0, 6.0, 12.0]\n    m = HubbardModelRepulsive(4, 2, U = 4)\n    mc = DQMC(\n        m, beta=beta, thermalization=5_000, sweeps=15_000, \n        print_rate=5_000, delta_tau = 0.05#, measure_rate=5\n    )\n    \n    # our default versions\n    mc[:G] = greens_measurement(mc, m)\n    mc[:SDCz] = spin_density_correlation(mc, m, :z)\n    mc[:SDSz] = spin_density_susceptibility(mc, m, :z)\n    mc[:T] = noninteracting_energy(mc, m)\n    \n    # ALF defines our I - G as the measured Greens function\n    function mygreens(mc, m, ij, G)\n        i, j = ij; N = length(lattice(mc))\n        swapop(G)[i, j] + swapop(G)[i+N, j+N]\n    end\n    mc[:Gr] = MonteCarlo.Measurement(mc, m, Greens, EachSitePairByDistance(), mygreens)\n    \n    # The interaction energy needs to be adjusted to ALF's Hamiltonian\n    function my_intE(mc, m, G)\n        E = 0.0; N = length(lattice(mc))\n        Gup, Gdown = G.val.blocks\n        for i in 1:N\n            E += (1 - Gup[i, i]) * (1 - Gdown[i, i])\n        end\n        m.U * E\n    end\n    mc[:V] = MonteCarlo.Measurement(mc, m, Greens, nothing, my_intE)\n    \n    # ALF includes 0 and β in the time displaced greens function\n    myGk(mc, m, ij, Gs) = begin G00, G0l, Gl0, Gll = Gs; i, j = ij; Gl0[i, j] end\n    mc[:IGk] = MonteCarlo.Measurement(\n        mc, m, CombinedGreensIterator, EachSitePairByDistance(), myGk\n    )\n        \n    # ALF subtracts the uncorrelated part\n    function myDenDen(mc, m, ij, G)\n        i, j = ij; N = length(lattice(mc))\n        swapop(G)[i, j] * G[i, j] + swapop(G)[i+N, j+N] * G[i+N, j+N]\n    end\n    mc[:DenDen] = MonteCarlo.Measurement(mc, m, Greens, EachSitePairByDistance(), myDenDen)\n    \n    function myDenDenTau(mc, m, ij, Gs)\n        i, j = ij; N = length(lattice(mc))\n        G00, G0l, Gl0, Gll = Gs\n        swapop(G0l)[i, j] * Gl0[i, j] + swapop(G0l)[i+N, j+N] * Gl0[i+N, j+N]\n    end\n    mc[:DenDenTau] = MonteCarlo.Measurement(mc, m, CombinedGreensIterator, EachSitePairByDistance(), myDenDenTau)\n    \n    run!(mc)\n    push!(mcs, mc)\nend","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"We run our simulations with a small Deltatau and larger number of sweeps to reduce errors. With the given parameters the simulations will take about 6min.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"A lot of the observables we measure have been adjusted to match ALF. First we have the real space equal time Greens function :Gr which measures delta(Delta r) - G(Delta r) = sum_r c_r^dagger c_r + Delta r. The MonteCarlo.jl Greens function is given as c c^dagger, so we need to swap the operators with swapop. We also need to explicitly sum the spin up and spin down channels.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Next we have the interaction energy :V which needs adjustments to the different pre-transformation term. We calculate langle V rangle = fracU2 sum_i langle V_i rangle where ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"langle V_i rangle = langle\nhatc^dagger_i uparrow hatc^phantomdagger_i uparrow hatc^dagger_i uparrow hatc^phantomdagger_i uparrow\n- hatc^dagger_i uparrow hatc^phantomdagger_i uparrow hatc^dagger_i downarrow hatc^phantomdagger_i downarrow\n- hatc^dagger_i downarrow hatc^phantomdagger_i downarrow hatc^dagger_i uparrow hatc^phantomdagger_i uparrow\n+ hatc^dagger_i downarrow hatc^phantomdagger_i downarrow hatc^dagger_i downarrow hatc^phantomdagger_i downarrow\nrangle","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Each term needs to be Wicks-expanded","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nlangle V_i rangle = phantom- \nlangle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle langle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle\n+ langle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle langle hatc^phantomdagger_i uparrow hatc^dagger_i uparrow rangle\n- langle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle\n- langle hatc^dagger_i uparrow hatc^phantomdagger_i downarrow rangle langle hatc^phantomdagger_i uparrow hatc^dagger_i downarrow rangle \n- langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle langle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle\n- langle hatc^dagger_i downarrow hatc^phantomdagger_i uparrow rangle langle hatc^phantomdagger_i downarrow hatc^dagger_i uparrow rangle\n+ langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle\n+ langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle langle hatc^phantomdagger_i downarrow hatc^dagger_i downarrow  rangle\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"so it can be exchanged by Greens function elements","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nlangle V_i rangle = phantom-\n  (I - G_ii^uparrow uparrow) (I - G_ii^uparrow uparrow)\n+ (I - G_ii^uparrow uparrow) G_ii^uparrow uparrow\n- (I - G_ii^uparrow uparrow) (I - G_ii^downarrow downarrow)\n- (I - G_ii^downarrow uparrow) G_ii^uparrow downarrow \n- (I - G_ii^downarrow downarrow) (I - G_ii^uparrow uparrow)\n- (I - G_ii^uparrow downarrow) G_ii^downarrow uparrow\n+ (I - G_ii^downarrow downarrow) (I - G_ii^downarrow downarrow)\n+ (I - G_ii^downarrow downarrow) G_ii^downarrow downarrow\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Next we make use of the symmetries of the model. Specifically that we do not have mixed spin terms, i.e. G_ij^sigma sigma^prime = 0 if sigma ne sigma^prime. We can also replace I by 1 in the remaining cases as both spin and site index are equal. We get","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nlangle V_i rangle = phantom-\n  (1 - G_ii^uparrow uparrow) (1 - G_ii^uparrow uparrow)\n+ (1 - G_ii^uparrow uparrow) G_ii^uparrow uparrow\n- (1 - G_ii^uparrow uparrow) (1 - G_ii^downarrow downarrow) \n- (1 - G_ii^downarrow downarrow) (1 - G_ii^uparrow uparrow)\n+ (1 - G_ii^downarrow downarrow) (1 - G_ii^downarrow downarrow)\n+ (1 - G_ii^downarrow downarrow) G_ii^downarrow downarrow\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"which we simplify further by using x = 1 - (1 - x).","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nlangle V_i rangle = \n(1 - G_ii^uparrow uparrow) + (1 - G_ii^downarrow downarrow) \n- 2 (1 - G_ii^uparrow uparrow) (1 - G_ii^downarrow downarrow) \n= G_ii^uparrow uparrow + G_ii^downarrow downarrow\n- 2 G_ii^uparrow uparrow G_ii^downarrow downarrow\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"This is however not what ALF implements as the potential energy. Instead of the above, ALF uses","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nfrac12 langle V_i rangle = (1 - G_ii^uparrow uparrow) (1 - G_ii^downarrow downarrow) \n= 1 - G_ii^uparrow uparrow - G_ii^downarrow downarrow\n+ G_ii^uparrow uparrow G_ii^downarrow downarrow\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"which is implemented above. After that we have the Fourier transformed time displaced Greens function :IGk which calculates the Fourier transform of G^prime(Delta r) = sum_tau = Deltatau^beta Deltatau sum_r c_r(tau) c_r + Delta r^dagger(0). Finally we have the charge density correlation :DenDen and susceptibility :DenDenTau which implement sum_r langle langle n_r n_r - Delta r rangle - langle n_r rangle langle n_r + Delta r rangle rangle_MC. We note here that the subtraction happens before taking the Monte Carlo average denoted by langle cdot rangle_MC.","category":"page"},{"location":"examples/ALF1/#Loading-ALF-Data-1","page":"Crosscheck with ALF","title":"Loading ALF Data","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"ALF will generate a folder with multiple files for each measurement. You should find these in your pyALF directory under ALF_data. To load everything you need to compare results we run","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"using Statistics\np = \"path/to/ALF_data\"\nfolders = [\n    \"Hubbard_Square_L1=4_L2=4_Checkerboard=False_Symm=True_T=1.0_U=4.0_Tperp=0.0_beta=1.0_Dtau=0.1_Mz=True\",\n    \"Hubbard_Square_L1=4_L2=4_Checkerboard=False_Symm=True_T=1.0_U=4.0_Tperp=0.0_beta=6.0_Dtau=0.1_Mz=True\",\n    \"Hubbard_Square_L1=4_L2=4_Checkerboard=False_Symm=True_T=1.0_U=4.0_Tperp=0.0_beta=12.0_Dtau=0.1_Mz=True\",\n]\n\n# equal time Greens\ndirs = []\nGs = []\ndGs = []\n\n# other equal time observables\nTs = []      # SpinT ~ 4 * (sx + sy + sz) / 3\ndTs = []\nSDCxys = []  # SpinXY ~ 2 * (sx + sy)\ndSDCxys = []\nSDCzs = []   # SpinZ ~ 4 * sz\ndSDCzs = []\nCDCs = []    # Den\ndCDCs = []\nCDCks = []    # Den\ndCDCks = []\n\n# Energies\nKs = []\ndKs = []\nVs = []\ndVs = []\nEs = []\ndEs = []\n\n# unequal time\nks = []\nGks = []\ndGks = []\nCDCts = []    # Den\ndCDCts = []\nSDSzs = []   # SpinZ ~ 4 * sz\ndSDSzs = []\n\nfunction read_scal(filename)\n    open(filename, \"r\") do f\n        data = map(eachline(f)) do line\n            parts = filter(x -> !isempty(x), split(line, r\" +\"))\n            parse(Float64, split(parts[2], ',')[1][2:end])\n        end\n        mean(data), std(data) / sqrt(length(data))\n    end\nend\n\nfunction readJR(filename)\n    open(filename, \"r\") do f\n        data = map(eachline(f)) do line\n            parse.(Float64, filter(x -> !isempty(x), split(line, r\" +\")))\n        end\n        drs = data[1:2:end]\n        ys = getindex.(data[2:2:end], 3)\n        dys = getindex.(data[2:2:end], 4)\n        drs, ys, dys\n    end\nend\n\nfunction read_tauJK(filename)\n    open(filename, \"r\") do f\n        data = map(eachline(f)) do line\n            parse.(Float64, filter(x -> !isempty(x), split(line, r\" +\")))\n        end\n        dks = [d[1:2] for d in data]\n        gs = [ComplexF64(d[3], d[5]) for d in data]\n        dgs = [ComplexF64(d[4], d[6]) for d in data]\n        dks, gs, dgs\n    end\nend\n\n\nfor folder in folders\n    drs, gs, dgs = readJR(joinpath(p, folder, \"Green_eqJR\"))\n    if isempty(dirs)\n        push!(dirs, drs)\n    else\n        @assert dirs[end] == drs\n    end\n    push!(Gs, gs)\n    push!(dGs, dgs)\n    \n    drs, cdcs, dcdcs = readJR(joinpath(p, folder, \"Den_eqJR\"))\n    @assert dirs[end] == drs\n    push!(CDCs, cdcs)\n    push!(dCDCs, dcdcs)\n     \n    drs, ts, dts = readJR(joinpath(p, folder, \"SpinT_eqJR\"))\n    @assert dirs[end] == drs\n    push!(Ts, ts)\n    push!(dTs, dts)\n    \n    drs, sdcxys, dsdcxys = readJR(joinpath(p, folder, \"SpinXY_eqJR\"))\n    @assert dirs[end] == drs\n    push!(SDCxys, sdcxys)\n    push!(dSDCxys, dsdcxys)\n    \n    drs, sdczs, dsdczs = readJR(joinpath(p, folder, \"SpinZ_eqJR\"))\n    @assert dirs[end] == drs\n    push!(SDCzs, sdczs)\n    push!(dSDCzs, dsdczs)\n    \n    dks, gks, dgks = readJR(joinpath(p, folder, \"Den_eqJK\"))\n    if isempty(ks)\n        push!(ks, dks)\n    else\n        @assert ks[end] == dks\n    end\n    push!(CDCks, gks)\n    push!(dCDCks, dgks)\n    \n    dks, gks, dgks = read_tauJK(joinpath(p, folder, \"Green_tauJK\"))\n    @assert ks[end] == dks\n    push!(Gks, gks)\n    push!(dGks, dgks)\n    \n    dks, gks, dgks = read_tauJK(joinpath(p, folder, \"Den_tauJK\"))\n    @assert ks[end] == dks\n    push!(CDCts, gks)\n    push!(dCDCts, dgks)\n        \n    dks, gks, dgks = read_tauJK(joinpath(p, folder, \"SpinZ_tauJK\"))\n    @assert ks[end] == dks\n    push!(SDSzs, gks)\n    push!(dSDSzs, dgks)\n    \n    \n    e, de = read_scal(joinpath(p, folder, \"Kin_scal\"))\n    push!(Ks, e)\n    push!(dKs, de)\n    \n    e, de = read_scal(joinpath(p, folder, \"Pot_scal\"))\n    push!(Vs, e)\n    push!(dVs, de)\n    \n    e, de = read_scal(joinpath(p, folder, \"Ener_scal\"))\n    push!(Es, e)\n    push!(dEs, de)\nend\n\nmc_drs = MonteCarlo.directions(mcs[1])\nidxs = map(v -> findfirst(isequal(v), dirs[1]), mc_drs)\nidxs[end-1] = 13","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The only thing worth mentioning here is the order of offset vectors Delta r. The order of observable values is linked to these vectors, whose order differs between MonteCarlo.jl and ALF. To adjust the order we compute idxs here. Note that because we work with periodic lattices there are multiple valid options for some of these vectors. Because of this we set one index explicitly. ","category":"page"},{"location":"examples/ALF1/#Comparing-the-results-1","page":"Crosscheck with ALF","title":"Comparing the results","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"To compare the results we will plot points over each other. Most observables have the same layout, i.e. values vs either spatial or reciprocal distance vectors. We will plot these with the following functions.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"using CairoMakie\n\nfunction plot_by_distance(\n        ys, dys, key; \n        idxs = idxs, xs = 1:16, xticks = map(v -> \"[$(v[1]), $(v[2])]\", mc_drs), \n        ylabel, legend_pos = :rt\n    )\n\n    fig = Figure(figure_padding = (10, 20, 10, 10))\n    ax = Axis(fig[1, 1])\n\n    cs = (:blue, :purple, :red)\n    for l in 1:3 # temperature index\n        band!(ax, xs, ys[l][idxs] .- dys[l][idxs], ys[l][idxs] .+ dys[l][idxs], color = (cs[l], 0.1))\n        scatter!(ax, xs, ys[l][idxs], color = cs[l], marker='+', markersize=12)\n\n        low = mean(mcs[l][key]) .- std_error(mcs[l][key])\n        high = mean(mcs[l][key]) .+ std_error(mcs[l][key])\n        band!(ax, xs, low, high, color = (cs[l], 0.1))\n        scatter!(ax, xs, mean(mcs[l][key]), color = cs[l], marker='x', markersize=12)\n    end\n\n    lbls = [\n        \"β = 1\", \"β = 1\",\n        \"β = 6\", \"β = 6\",\n        \"β = 12\", \"β = 12\"\n    ]\n    axislegend(ax, ax.scene.plots[3:2:end], lbls, \"  ALF    MonteCarlo.jl\", nbanks=2, position = legend_pos)\n\n    ax.ylabel[] = ylabel\n    ax.xticks[] = (xs, xticks)\n    ax.xlabel[] = \"Distance Δr\"\n    ax.xticklabelrotation[] = -0.7\n\n    # to fix bad spacing, likely unnecessary in the near future\n    ax.xlabelpadding[] = 10\n    \n    fig, ax\nend\n\nfunction plot_reciprocal(\n        ys, dys, key; \n        xs = 1:16, ylabel, legend_pos = :rt,\n        xticks = labels = map(ks[1]) do k\n            pieces = map(k) do x\n                if x ≈ 0.5f0 * pi;       \"π/2\"\n                elseif x ≈ 1f0 * pi;     \"π\"\n                elseif x ≈ -0.5f0 * pi;  \"-π/2\"\n                elseif x ≈ 0.0;          \"0\"\n                else;                    \"$x\"\n                end\n            end\n            \"[\" * join(pieces, \", \") * \"]\"\n        end\n    )\n\n    fig = Figure(figure_padding = (10, 20, 10, 10))\n    ax = Axis(fig[1, 1])\n\n    cs = (:blue, :purple, :red)\n    for l in 1:3 # temperature index\n        low  = real(real(ys[l]) .- real(dys[l]))\n        high = real(real(ys[l]) .+ real(dys[l]))\n        band!(ax, xs, low, high, color = (cs[l], 0.1))\n        scatter!(ax, xs, real(ys[l]), color = cs[l], marker='+', markersize=12)\n\n        _ys = map(1:16) do j\n            MonteCarlo.fourier_transform(\n                ks[1][j:j], \n                directions(mcs[l]), \n                mcs[l][key] |> mean\n            )[1]\n        end\n        _dys = map(1:16) do j\n            vals = std_error(mcs[l][key])\n            dirs = directions(mcs[l])\n            q = ks[1][j]\n            sum((cis(dot(q, v)) * o)^2 for (v, o) in zip(dirs, vals)) |> mean |> sqrt\n        end\n\n        low  = real(_ys .- _dys)\n        high = real(_ys .+ _dys)\n        band!(ax, xs, low, high, color = (cs[l], 0.1))\n        scatter!(ax, xs, real(_ys), color = cs[l], marker='x', markersize=12)\n    end\n\n    lbls = [\n        \"β = 1\", \"β = 1\",\n        \"β = 6\", \"β = 6\",\n        \"β = 12\", \"β = 12\"\n    ]\n    axislegend(ax, ax.scene.plots[3:2:end], lbls, \"  ALF    MonteCarlo.jl\", nbanks=2, position = legend_pos)\n\n    ax.ylabel[] = ylabel\n    ax.xticks[] = (xs, xticks)\n    ax.xlabel[] = \"Reciprocal Vector Δk\"\n    ax.xticklabelrotation[] = -0.7\n\n    # to fix bad spacing, likely unnecessary in the near future\n    ax.xlabelpadding[] = 10\n    \n    fig, ax\nend","category":"page"},{"location":"examples/ALF1/#Equal-time-Greens-function-1","page":"Crosscheck with ALF","title":"Equal time Greens function","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The equal time Greens function shows a clean overlap between the two libraries.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_by_distance(\n    Gs, dGs, :Gr, factor = 2.0, \n    ylabel = \"δ(Δr) - G(Δr) = ∑ᵣ ⟨c^†(r) c(r + Δr)⟩\"\n)\nMakie.save(\"equal_time_greens.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Time-displaced-Greens-function-1","page":"Crosscheck with ALF","title":"Time displaced Greens function","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"For the time-displaced Greens function the overlap becomes visibly less precise. This is likely a result of the different transformations used. Reducing Delta tau in MonteCarlo.jl decreases the error.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_reciprocal(\n    Gks, dGks, :IGk,\n    ylabel = \"Integrated Greens function ∑ₖ ∫ ⟨c(τ, k) c^†(0, k + Δk)⟩ dτ\"\n)\nMakie.save(\"time_displaced_greens.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Energies-1","page":"Crosscheck with ALF","title":"Energies","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"For the kinetic energy and interaction we only get one value per simulation so we just compare them numerically. In this case all values match with errors. The first group shows kinetic energy and the second interaction.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Inv. Temp. ALF MonteCarlo.jl  ALF MonteCarlo.jl\n1 -16.855 ± 0.005 -16.83 ± 0.07  8.775 ± 0.003 8.75 ± 0.03\n6 -21.107 ± 0.002 -21.00 ± 0.08  7.72  ± 0.02 7.64 ± 0.09\n12 -21.109 ± 0.002 -21.12 ± 0.09  7.538 ± 0.006 7.54 ± 0.05","category":"page"},{"location":"examples/ALF1/#Charge-Density-Correlations-1","page":"Crosscheck with ALF","title":"Charge Density Correlations","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Like the equal time Greens function the charge density matches close to exactly.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_by_distance(CDCs, dCDCs, :DenDen, ylabel = \"Charge Density Correlation ∑ᵣ ⟨n(r) n(r + Δr)⟩\")\nMakie.save(\"charge_density_correlation.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Charge-Density-Susceptibility-1","page":"Crosscheck with ALF","title":"Charge Density Susceptibility","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The charge susceptibility shows some larger errors but still matches fairly well. The errors we see here are generally smaller than what we saw in the integrated Greens function.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_reciprocal(\n    CDCts, dCDCts, :DenDenTau,\n    ylabel = \"Charge Density Susceptibility ∑ᵣ ∫ ⟨n(τ, r) n(0, r + Δr)⟩ dτ\"\n)\nMakie.save(\"charge_density_susceptibility.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Spin-Density-Correlation-1","page":"Crosscheck with ALF","title":"Spin Density Correlation","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Like the other equal time correlations spin density also fits almost exactly.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_by_distance(SDCzs, dSDCzs, :SDCz, ylabel = \"Spin Density Correlation ∑ᵣ ⟨s_z(r) s_z(r + Δr)⟩\")\nMakie.save(\"spin_density_correlation.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Spin-Density-Susceptibility-1","page":"Crosscheck with ALF","title":"Spin Density Susceptibility","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Like the other susceptibilities, this shows some larger deviations than its equal time variant but no qualitative difference from ALF.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"lbl = L\"Spin Density Susceptibility $\\sum_{r, r^\\prime} \\int_0^\\beta s_z(\\tau, r) s_z(0, r^\\prime) e^{i \\Delta k (r^\\prime - r)} d\\tau$\"\nfig, ax = plot_reciprocal(\n    SDSzs, dSDSzs, :SDSz, legend_pos = :lt,\n    ylabel = lbl\n)\nMakie.save(\"spin_density_susceptibility.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"DQMC/scheduler/#Update-Scheduler-1","page":"Update Scheduler","title":"Update Scheduler","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The update scheduler keeps track of and iterates through various Monte Carlo updates. Currently there are two schedulers, SimpleScheduler and AdaptiveScheduler, and five (full) updates.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"note: Note\nThis is a DQMC only feature at the moment.","category":"page"},{"location":"DQMC/scheduler/#Schedulers-1","page":"Update Scheduler","title":"Schedulers","text":"","category":"section"},{"location":"DQMC/scheduler/#SimpleScheduler-1","page":"Update Scheduler","title":"SimpleScheduler","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The SimpleScheduler keeps track of a sequence of updates and cycles through them as update(scheduler, mc, model) is called. It is constructed by simply passing a sequence of updates, i.e. SimpleScheduler(update1, update2, ...).","category":"page"},{"location":"DQMC/scheduler/#AdaptiveScheduler-1","page":"Update Scheduler","title":"AdaptiveScheduler","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The AdaptiveScheduler also has a static sequence of updates, but allows some of these updates to be Adaptive(). Any Adaptive() update in the sequence is replaced with an update from a pool based on their relative weights. These weights are derived from their acceptance rates with some lag.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"An adaptive scheduler is created with a sequence of updates and a pool of updates, i.e.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"sequence = (update1, Adaptive())\npool = (update2, update3)\nscheduler = AdaptiveScheduler(sequence, pool)","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Additionally there are a couple of keywords to configure how weights are adjusted.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"minimum_sampling_rate = 0.01: This defines the threshold under which the ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"sampling rate is set to 0.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"grace_period = 99: This sets a minimum number of times an update needs to ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"be called before its sampling rate is adjusted. ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"adaptive_rate = 9.0: Controls how fast the sampling rate is adjusted to the ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"acceptance rate. More means slower.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The adjustments of the sampling rate follow the formula \\begin{equation} \\frac{(adaptiverate * samplingrate + \\frac{accepted}{total} }{ adaptive_rate + 1 } \\end{equation}","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"note: Note\nAll schedulers wrap their updates in AcceptanceStatistics. This wrapper keeps track of the total number of update attempts and the number of accepted updates.","category":"page"},{"location":"DQMC/scheduler/#Updates-1","page":"Update Scheduler","title":"Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Updates are small or even empty structs used to dispatch to different update functions. They are assumed to implement name(::MyUpdate) = \"MyUpdate\" and a method update(::MyUpdate, mc, model). ","category":"page"},{"location":"DQMC/scheduler/#Local-Updates-1","page":"Update Scheduler","title":"Local Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Local updates affect one site at one time slice. In order for this to be on a similar scale as global and parallel updates, local updates should come in full sweeps. ","category":"page"},{"location":"DQMC/scheduler/#LocalSweep-1","page":"Update Scheduler","title":"LocalSweep","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Currently there is only one local update - LocalSweep([N=1]). It performs N standard sweeps of local updates, which means two updates per site and time slice each in DQMC. (Two because we go from tau = 0 to tau = beta back to tau = 0.) This update returns a float corresponding to its internal acceptance rate accepted  (2 N_sites M_slices","category":"page"},{"location":"DQMC/scheduler/#Global-Updates-1","page":"Update Scheduler","title":"Global Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Global updates affect not just one site at one time slice, but most if not all sites at all time slices. In other words they attempt to adjust the full configuration. We currently have the following global updates.","category":"page"},{"location":"DQMC/scheduler/#GlobalFlip-1","page":"Update Scheduler","title":"GlobalFlip","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The GlobalFlip() proposes a flip of the full configuration, i.e. pm 1 to mp 1.","category":"page"},{"location":"DQMC/scheduler/#GlobalShuffle-1","page":"Update Scheduler","title":"GlobalShuffle","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"GlobalShuffle() performs a shuffle(current_configuration) to generate a new configuration.","category":"page"},{"location":"DQMC/scheduler/#SpatialShuffle-1","page":"Update Scheduler","title":"SpatialShuffle","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"SpatialShuffle shuffles only the spatial part of a configuration. This means that if two sites are swapped, they are swapped the same way for all time slice indices.","category":"page"},{"location":"DQMC/scheduler/#TemporalShuffle-1","page":"Update Scheduler","title":"TemporalShuffle","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"TemporalShuffle shuffles only the imaginary time part of the configuration, meaning that the swap occurs for all lattice indices the same way.","category":"page"},{"location":"DQMC/scheduler/#Denoise-1","page":"Update Scheduler","title":"Denoise","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Denoise attempts to align the configuration in lattice space. Specifically, it sets each site to the majority value of its neighbors (including itself with a lower weight). Note that this update assumes configuration values pm 1. Also note that the new configuration is solely based on the old, i.e. it does not take changes of nearby sites into account. Because of this the update may not always push the configuration to a more uniform distribution.","category":"page"},{"location":"DQMC/scheduler/#DenoiseFlip-1","page":"Update Scheduler","title":"DenoiseFlip","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"DenoiseFlip follows the logic of Denoise, but flips the resulting configuration.","category":"page"},{"location":"DQMC/scheduler/#StaggeredDenoise-1","page":"Update Scheduler","title":"StaggeredDenoise","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"StaggeredDenoise follows the same logic as Denoise, but multiplies a factor pm 1 based on the lattice site index. ","category":"page"},{"location":"DQMC/scheduler/#Parallel-Updates-1","page":"Update Scheduler","title":"Parallel Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Parallel updates communicate between different simulations running on different workers. Note that these simulations must produce configurations of the same size, i.e. have same number of time slices and sites.","category":"page"},{"location":"DQMC/scheduler/#ReplicaExchange-1","page":"Update Scheduler","title":"ReplicaExchange","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The ReplicaExchange(target) update requires a target worker, and it requires that worker to be in sync. Specifically that means if worker 1 has a ReplicaExchange(2) followed by ReplicaExchange(3), worker 2 must have ReplicaExchange(1) as its first replica exchange update and worker 3 must have ReplicaExchange(1) as its second replica exchange update.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The idea of a replica exchange update is to propose swapping configurations between two simulations. The exchange is based on the product of both of their acceptance probabilities. With C_i the configuration of simulation i and w_i(C) the weight of simulation i with the given configuration the acceptance probability is given by","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"p = fracw_1(C_2)w_1(C_1) cdot fracw_2(C_1)w_2(C_2)","category":"page"},{"location":"DQMC/scheduler/#ReplicaPull-1","page":"Update Scheduler","title":"ReplicaPull","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"ReplicaPull() is an experimental parallel update. Instead of synchronizing with another simulations it pulls a configuration asynchronously and uses that for a global update. This means that there is little waiting on other simulations, but configurations will be duplicated.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"This update cycles through a pool of connected workers. This pool can be of any size. Each simulation must make itself available for pulling via connect(target_workers). The target_workers should generally be the workers the simulation wants to receive configurations from. When a simulation reaches the end it will automatically disconnect(target_workers).","category":"page"},{"location":"DQMC/scheduler/#MPI-Updates-1","page":"Update Scheduler","title":"MPI Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#MPIReplicaExchange-1","page":"Update Scheduler","title":"MPIReplicaExchange","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"This is a MPI version of the replica exchange update. In this case target is an MPI rank. Much like the normal replica exchange update simulations need to be paired such that they request updates from each other.","category":"page"},{"location":"DQMC/model/#Models-1","page":"Model","title":"Models","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"The Model is an abstract type whose concrete versions should implement lightweight description of a Hamiltonian. There are two Models implemented for DQMC - the attractive and repulsive Hubbard model.","category":"page"},{"location":"DQMC/model/#Attractive-Hubbard-Model-1","page":"Model","title":"Attractive Hubbard Model","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"The attractive (negative interaction term) Hubbard model is given by","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"mathcalH = -t sum_langle ij rangle sigma left( c^dagger_isigma c_jsigma + texthc right) - U sum_j left( n_juparrow - frac12 right) left( n_jdownarrow - frac12 right) - musum_j n_j","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"where sigma denotes spin, t is the hopping amplitude, U the on-site attractive interaction strength, mu the chemical potential and langle i j rangle indicates that the sum has to be taken over nearest neighbors. Note that (1) is written in particle-hole symmetric form such that mu = 0 corresponds to half-filling.","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"The parameters U = 10, t = 10 and mu = 0 as well as the lattice are saved in the model. They can be specified via keyword arguments when calling HubbardModelAttractive().","category":"page"},{"location":"DQMC/model/#Repulsive-Hubbard-Model-1","page":"Model","title":"Repulsive Hubbard Model","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"The repulsive (positive interaction term) Hubbard model is given by","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"mathcalH = -t sum_langle ij rangle sigma left( c^dagger_isigma c_jsigma + texthc right) + U sum_j left( n_juparrow - frac12 right) left( n_jdownarrow - frac12 right)","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"where sigma denotes spin, t is the hopping amplitude, U the on-site repulsive interaction strength and langle i j rangle indicates that the sum has to be taken over nearest neighbors. This model does not include a chemical potential due to the sign problem.","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"The parameters U = 10 and t = 10 as well as the lattice are saved in the model. They can be specified via keyword arguments when calling HubbardModelRepulsive().","category":"page"},{"location":"DQMC/model/#Creating-your-own-Model-1","page":"Model","title":"Creating your own Model","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"To create your own model you will need to inherit from Model. There is a set of mandatory and optional methods you must/can implement:","category":"page"},{"location":"DQMC/model/#Mandatory-Methods-1","page":"Model","title":"Mandatory Methods","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"rand(::Type{DQMC}, m::Model, nslices) should return a full new random configuration, where nslices is the number of imaginary time slices.\nnflavors(m::Model) should return the number of fermion flavors used by the model. This controls the size of most simulation matrices, e.g. the greens matrix, hopping and interaction matrices, etc.\nhopping_matrix(dqmc::DQMC, m::Model) should return the hopping matrix of the model. This includes all terms that are not connected to a bosonic field.\ninteraction_matrix_exp!(dqmc::DQMC, m::Model, result::AbstractArray, conf, slice, power=1.0) should calculate exp(- power cdot delta_tau cdot V_slice) for the current conf at time slice slice and save it to result. Note that this method is performance critical.\npropose_local(dqmc::DQMC; m::Model, i, slice, conf) should propose a local update at site i and the current tiem slice. It should calculate the determinant ratio and bosonic energy difference (which maybe 0 for some models) and return determinant_ratio, bosonic_energy, passthrough where passthrough are a tuple of variables you may want to use in accept_local!. Note this is also a performance critical method.\naccept_local!(mc::DQMC, m::Model, i, slice, conf, detratio, ΔE_boson, passthrough) should update the greens function when the proposed change is accepted. Specifically this means updating dqmc.stack.greens. This is a performance critical method.","category":"page"},{"location":"DQMC/model/#(Semi-)-Optional-Methods-1","page":"Model","title":"(Semi-) Optional Methods","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"greenseltype(::Type{DQMC}, m::Model) = ComplexF64 sets the element type of the greens function. If your greens function is real this function should be implemented for better performance.\nhoppingeltype(::Type{DQMC}, m::Modle) = Float64 sets the expected element type of the hopping matrix. Adjust this if it is wrong.\ninteraction_matrix_type(::Type{DQMC}, m::Model) = Matrix{greenseltype(DQMC, m)} Sets the matrix type of the interaction matrix. For the Hubbard model this is Diagonal{Float64}.\nhopping_matrix_type(::Type{DQMC}, m::Model) = Matrix{hoppingeltype(DQMC, m)} Sets the matrix type of the hopping matrix. If there is a more efficient way to represent your matrix you may use this to change to that representation. The repulsive Hubbard model uses BlockDiagonal matrices, for example, which are implemented by MonteCarlo.jl\ngreens_matrix_type(::Type{DQMC}, m::Model) = Matrix{greenseltype(DQMC, m)} Sets the matrix type of the greens matrix. The repulsive Hubbard model also uses BlockDiagonal here.\ninit_interaction_matrix(m::Model) initializes the interaction matrix. If you are using a custom matrix type you must implement this. Note that the values are irrelevant.\nenergy_boson(dqmc::DQMC, m::Model, conf) should be implemented if you want to measure energies in your simulation.\nparameters(m::Model) should collect the parameters from the model and lattice in a NamedTuple. This is purely utility.","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"Also note that you may need to update the measurement kernels. More information about that on the measurement page.","category":"page"},{"location":"DQMC/Introduction/#Determinant-Quantum-Monte-Carlo-1","page":"Introduction","title":"Determinant Quantum Monte Carlo","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"Determinant Quantum Monte Carlo is a Quantum Monte Carlo algorithm for fermionic Hamiltonians. The general idea is to use the Hubbard-Stranovich transformation to simplify the Hamiltonian to one with only quadratic fermionic degrees of freeedom. This introduces a bosonic fields for quartic terms, which can be sampled by a Monte Carlo procedure.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"The minimal working example for a DQMC simulation is the following.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"using MonteCarlo\n\nmodel = HubbardModelAttractive(4, 2)\ndqmc = DQMC(model, beta=1.0)\nrun(dqmc)","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"This will set up and run a DQMC simulation at inverse temperature beta = 10 using an attractive Hubbard model with a four by four square lattice. Note that by default no measurements are taken. ","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"In the following pages we will discuss the various components that go into a DQMC simulation.","category":"page"},{"location":"DQMC/Introduction/#Derivation-1","page":"Introduction","title":"Derivation","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"If you are interested in the derivation of DQMC you may check Introduction to Quantum Monte Carlo Simulations for fermionic Systems, the book Quantum Monte Carlo Methods or World-line and Determinantal Quantum Monte Carlo Methods for Spins, Phonons and Electrons. The first reference is most in-line with the implementation of this package.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"If you want to go through the source code, compare it and verify for yourself that it is correct there a couple of things that should be pointed out. Most educational sources use the asymmetric two term Suzuki-Trotter decomposition. We use the symmetric three term version for increased accuracy.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"B(l) = e^-Deltatau sum_l T+V(l) = prod_j e^-Deltatau T2 e^-Deltatau V e^-Deltatau T2 + mathcalO(Deltatau^2)","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"This change is however no trivial as the first or last element of the B matrix/operator needs to be an exponentiated interaction. To get this we use an effective greens function, which cyclically permutes one exponentiation hopping term to the other end of the chain. This adjustment needs to be undone for the actual greens function, which happens in greens().","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"Another thing worth mentioning is that depending on the choices made at the start of the derivation, matrix products may have different order and indices may vary. The first source should have the same definitions.","category":"page"},{"location":"examples/triangular_Hubbard/#Triangular-Attractive-Hubbard-1","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"This example implements the model from the paper Attractive Hubbard model on a triangular lattice. This also serves as a cross-check for the DQMC and a few measurements, such as pairing correlations and occupations. ","category":"page"},{"location":"examples/triangular_Hubbard/#Simulation-1","page":"Triangular Attractive Hubbard","title":"Simulation","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"In the paper simulations were done with 500-1000 sweeps and Deltatau = 0125. Occupations are measured the same way as in MonteCarlo.jl. Pairing correlations seem to use Delta Delta^dagger rather than the Delta^dagger Delta + Delta Delta^dagger given in the paper. The latter is the default in MonteCarlo.jl. To have the former we need to explicitly pass kernel = MonteCarlo.pc_kernel.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The first figure is done with interaction strength U = -4, linear system size L = 4 at beta = 2 5 7 for varying mu. The following simulations should take about 2 minutes.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"using MonteCarlo\n\nbetas = (2.0, 5.0, 7.0)\nmus = vcat(-2.0, -1.5, -1.25:0.05:-1.0, -0.8:0.2:0.8, 0.9:0.05:1.25, 1.5, 2.0)\nlattice = TriangularLattice(4)\ndqmcs = []\n\ncounter = 0\nN = length(mus) * length(betas)\n@time for beta in betas, mu in mus\n    counter += 1\n    print(\"\\r[\", lpad(\"$counter\", 2), \"/$N]\")\n    m = HubbardModelAttractive(l = lattice, t = 1.0, U = 4.0, mu = mu)\n    dqmc = DQMC(\n        m, beta = beta, delta_tau = 0.125, safe_mult = 8, \n        thermalization = 1000, sweeps = 1000, measure_rate = 1,\n        recorder = Discarder\n    )\n    dqmc[:occ] = occupation(dqmc, m)\n    dqmc[:PC] = pairing_correlation(dqmc, m, kernel = MonteCarlo.pc_kernel)\n    run!(dqmc, verbose = false)\n\n    # for simplicity we just keep the whole simulation around\n    push!(dqmcs, dqmc)\nend","category":"page"},{"location":"examples/triangular_Hubbard/#Processing-Data-1","page":"Triangular Attractive Hubbard","title":"Processing Data","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"After running all the simulations we need to do a little bit of post-processing on the measured data. ","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"N = length(mus)\noccs = []\nΔoccs = []\npcs = []\nΔpcs = []\n\nfor i in 0:2\n    # Measurements are saved in a LogBinner from BinningAnalysis by default.\n    # Taking the mean (std_error) of a LogBinner will return the Monte Carlo \n    # average (error). Occupation measurements happen per site, so we need \n    # another mean afterwards. \n    _occs = [2 * mean(mean(dqmcs[N*i + j][:occ])) for j in 1:N]\n    doccs = [2 * sqrt(mean(std_error(dqmcs[N*i + j][:occ]).^2)) for j in 1:N]\n    push!(occs, _occs)\n    push!(Δoccs, doccs)\n\n    # pairing correlations are saved in a partially processed state - a 3D matrix\n    # where each index corresponds to vectors between sites\n    # y_{i, j, k} = ∑_x ⟨c_{x, ↑} c_{x+j, ↓} c_{x+i+k, ↓}^† c_{x+i, ↑}^†\n    # The vectors corresponding to the indices i, j, k are returned by \n    # directions(lattice(dqmc)). To compute the pairing correlation of a certain\n    # symmetry, we need to apply the weights corresponding vector indices j, k.\n    # For s-wave symmetry these weights are always (1, 0, ..., 0) (only vector 0).\n    # To match the paper the index i should just be summed over. This is \n    # equivalent to a q=0 Fourier transform.\n    _pcs = [sum(mean(dqmcs[N*i + j][:PC])[:, 1, 1]) for j in 1:N]\n    dpcs = [sqrt(sum(std_error(dqmcs[N*i + j][:PC])[:, 1, 1].^2)) for j in 1:N]\n    push!(pcs, _pcs)\n    push!(Δpcs, dpcs)\nend","category":"page"},{"location":"examples/triangular_Hubbard/#Plotting-1","page":"Triangular Attractive Hubbard","title":"Plotting","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"With the data in a processed form we can now plot it. To make comparison easier, we plot our data directly over figure 1 from our reference.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"using CairoMakie, FileIO, Colors\n\n\nfig = Figure(resolution = (800, 800))\ntop = Axis(fig[1, 1])\nbot = Axis(fig[2, 1])\n\n# References\np = pkgdir(MonteCarlo)\ntop_ref = FileIO.load(joinpath(p, \"docs/src/examples/assets/triangular/tri_Hub_ref1_1.png\"))\nbot_ref = FileIO.load(joinpath(p, \"docs/src/examples/assets/triangular/tri_Hub_ref1_2.png\"))\nip = image!(top, -2..2, 0..2, top_ref'[:, end:-1:1])\ntranslate!(ip, 0, 0, -1)\nip = image!(bot, -2..2, 0..2.5, bot_ref'[:, end:-1:1], transparency=true)\ntranslate!(ip, 0, 0, -1)\n\nc = HSV(250, 0.6, 1)\nfor (i, (ys, dys)) in enumerate(zip(occs, Δoccs))\n    band!(top, mus, ys .- dys, ys .+ dys, color = (:red, 0.3))\n    lines!(top, mus, ys, color = (c, 0.5), linewidth=2)\n    scatter!(top, mus, ys, color = c, marker = ('■', '□', 'o')[i])\nend\n\naxislegend(top, top.scene.plots[4:3:end], [\"β = 2\", \"β = 5\", \"β = 7\"], position = :rb)\n\nfor (i, (ys, dys)) in enumerate(zip(pcs, Δpcs))\n    band!(bot, mus, ys .- dys, ys .+ dys, color = (:red, 0.3), transparency=true)\n    lines!(bot, mus, ys, color = (c, 0.5), linewidth=2)\n    scatter!(bot, mus, ys, color = c, marker = ('■', '□', 'o')[i])\nend\n\nxlims!(top, -2 , 2)\nylims!(top, 0 , 2)\nxlims!(bot, -2 , 2)\nylims!(bot, 0 , 2.5)\n\nCairoMakie.save(joinpath(p, \"docs/src/examples/assets/triangular/fig1_comparison.png\"), fig)","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#Other-runs-1","page":"Triangular Attractive Hubbard","title":"Other runs","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The paper has two more versions of the above plot for system sizes L = 6 and L = 8. These show significantly different results.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"For L = 6 we use mus = vcat(-2.0:0.25:-0.25, -0.1:0.1:1.1, 1.25, 1.5, 2.0) with the same parameters other than that. The simulation should take about 5 minutes.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"For L=8 we use mus = vcat(-2.0:0.5:-0.5, -0.1:0.1:1.1, 1.25, 1.5, 2.0) and betas = (2.0, 5.0, 6.0, 7.0). The resulting simulation takes about 30min.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#Charge-Density-Structure-Factor-1","page":"Triangular Attractive Hubbard","title":"Charge Density Structure Factor","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The paper also investigates the charge density structure factor as a function of reciprocal lattice vectors q. In general structure factors can be computed from correlations via Fourier transform. In this case it is not quite as simple since MonteCarlo.jl implements langle n_i n_j rangle while the paper uses langle n_i n_j rangle - langle n_i rangle langle n_j rangle. As such we need to implement our own reduced charge density correlation measurement. First we need to figure out what this observable looks like in terms of Greens function elements.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"beginaligned\n\tlangle n_i s n_j s^prime rangle - langle n_i s rangle langle n_j s^prime rangle\n\t= langle c_i s^dagger c_i s c_j s^prime^dagger c_j s^prime rangle  - langle n_i s rangle langle n_j s^prime rangle\n\t= langle c_i s^dagger c_i s rangle langle c_j s^prime^dagger c_j s^prime rangle + langle c_i s^dagger c_j s^prime rangle langle c_i s c_j s^prime^dagger rangle  - langle n_i s rangle langle n_j s^prime rangle\n\t= (delta_ij delta_ss^prime - G_ji^s^prime s) G_ij^ss^prime\nendaligned","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"Here we expanded the term into creation and annihilation operators, applied Wicks theorem and finally used G_ij^ss^prime = langle c_i c_j^dagger rangle to express the term with Greens function elements. (We note that expectation values of two creation or two annihilation operators are always zero in DQMC and are therefore dropped.) For the attractive Hubbard model, greens function elements with different spins G_ij^ss^prime are zero and G_ij^uparrowuparrow = G_ij^downarrowdownarrow. Thus the full expectation value is given by","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"langle n_i n_j rangle - langle n_i s rangle langle n_j s^prime rangle = 2 (delta_ij - G_ji) G_ij","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"which needs to be implemented as a function and passed to MonteCarlo.Measurement to be used.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"function my_kernel(::DQMC, ::HubbardModelAttractive, ij::NTuple{2}, G::AbstractArray)\n    i, j = ij\n    4 * (I[j, i] - G[j, i]) * G[i, j]\nend\n\ndqmc[:CDC] = MonteCarlo.Measurement(mc, model, Greens, EachSitePairByDistance, my_kernel)","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"In the above, Greens is a greens function iterator used by the measurement. It yields an equal time greens function to the measurement which is eventually passed as G to the kernel. EachSitePairByDistance defines which lattice indices are passed to the kernel and how they are saved. In this case i and j run through each site index independently and the results are summed such that we have one value per unique distance vector.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"With that measurement we can now compare to the paper. We simulate with L = 6 8, beta = 8, mu = 0 and U = 4, which should take about a minute.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"To match the paper we simulate L = 6 8, beta = 8, mu = 0 and U = -4 with the new measurement. This should take about a minute. After the simulation we compute the fourier transform at various q with","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"qs = vcat(\n    range(Float64[0, 0],   Float64[pi, 0], length=10),\n    range(Float64[pi, 0],  Float64[pi, pi], length=10),\n    range(Float64[pi, pi], Float64[0, 0], length=10),\n)\nys = map(dqmcs) do dqmc\n    MonteCarlo.fourier_transform(\n        qs, directions(MonteCarlo.lattice(dqmc)), mean(dqmc[:CDC])\n    ) |> real\nend","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#Magnetic-Susceptibility-1","page":"Triangular Attractive Hubbard","title":"Magnetic Susceptibility","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The uniform susceptibility featured in figure 7 of the paper can be reproduced more easily. For it we need to run our simulation with a spin_density_susceptibility(dqmc, model, :z) measurement. The result will again be in a partially summed per-distance-vector form. The q=0 Fourier transform follows from simple summation. With L = 6 and betas = [1.0, 2.0, 4.0, 5.0, 6.0, 7.0, 8.0] this simulation should take about a minute.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"legacy/methods/general/#Methods:-General-1","page":"General","title":"Methods: General","text":"","category":"section"},{"location":"legacy/methods/general/#","page":"General","title":"General","text":"Below you find all general exports.","category":"page"},{"location":"legacy/methods/general/#Index-1","page":"General","title":"Index","text":"","category":"section"},{"location":"legacy/methods/general/#","page":"General","title":"General","text":"Pages = [\"general.md\"]","category":"page"},{"location":"legacy/methods/general/#Documentation-1","page":"General","title":"Documentation","text":"","category":"section"},{"location":"legacy/methods/general/#","page":"General","title":"General","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"abstract.jl\"]","category":"page"},{"location":"legacy/methods/general/#Base.length-Tuple{AbstractLattice}","page":"General","title":"Base.length","text":"length(l::AbstractLattice)\n\nNumber of lattice sites.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#Base.size-Tuple{AbstractLattice}","page":"General","title":"Base.size","text":"size(l::AbstractLattice)\n\nReturns the linear system size of a lattice.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.lattice-Tuple{T} where T<:Model","page":"General","title":"MonteCarlo.lattice","text":"lattice(model)\n\nReturns the lattice of a given model.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.neighbors-Tuple{AbstractLattice, Integer}","page":"General","title":"MonteCarlo.neighbors","text":"neighbors(l::AbstractLattice, site_index::Integer)\n\nReturns a list of site indices neighboring the specified site_index.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.neighbors-Tuple{AbstractLattice}","page":"General","title":"MonteCarlo.neighbors","text":"neighbors(l::AbstractLattice[, directed=Val(false)])\n\nReturns an iterator over bonds, given as tuples (source index, target index). If directed = Val(true) bonds are assumed to be directed, i.e. both (1, 2) and (2, 1) are included. If directed = Val(false) bonds are assumed to be undirected, i.e. (1, 2) and (2, 1) are assumed to be equivalent and only one of them will be included.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.parameters-Tuple{Model}","page":"General","title":"MonteCarlo.parameters","text":"parameters(model)\n\nCollects relevant parametrs of a model into a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.reset!-Tuple{MonteCarloFlavor}","page":"General","title":"MonteCarlo.reset!","text":"reset!(mc::MonteCarloFlavor)\n\nResets the Monte Carlo simulation mc. Previously set parameters will be retained.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.run!-Tuple{MonteCarloFlavor}","page":"General","title":"MonteCarlo.run!","text":"run!(mc)\n\nRun the Monte Carlo Simulation.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.AbstractLattice","page":"General","title":"MonteCarlo.AbstractLattice","text":"Abstract definition of a lattice.\n\n\n\n\n\n","category":"type"},{"location":"legacy/methods/general/#MonteCarlo.Model","page":"General","title":"MonteCarlo.Model","text":"Abstract model.\n\n\n\n\n\n","category":"type"},{"location":"legacy/methods/general/#MonteCarlo.MonteCarloFlavor","page":"General","title":"MonteCarlo.MonteCarloFlavor","text":"Abstract definition of a Monte Carlo flavor.\n\n\n\n\n\n","category":"type"},{"location":"legacy/manual/showcase/#Showcase-1","page":"Showcase","title":"Showcase","text":"","category":"section"},{"location":"legacy/manual/showcase/#D-Ising-model-1","page":"Showcase","title":"2D Ising model","text":"","category":"section"},{"location":"legacy/manual/showcase/#","page":"Showcase","title":"Showcase","text":"Results: (Image: )","category":"page"},{"location":"legacy/manual/showcase/#","page":"Showcase","title":"Showcase","text":"Code:","category":"page"},{"location":"legacy/manual/showcase/#","page":"Showcase","title":"Showcase","text":"using MonteCarlo, Distributions, PyPlot, DataFrames, JLD\n\nTdist = Normal(MonteCarlo.IsingTc, .64)\nn_Ts = 2^8\nTs = sort!(rand(Tdist, n_Ts))\nTs = Ts[Ts.>=1.2]\nTs = Ts[Ts.<=3.8]\ntherm = 10^4\nsweeps = 10^3\n\ndf = DataFrame(L=Int[], T=Float64[], M=Float64[], χ=Float64[], E=Float64[], C_V=Float64[])\n\nfor L in 2 .^ [3, 4, 5, 6]\n\tprintln(\"L = \", L)\n\tfor (i, T) in enumerate(Ts)\n\t\tprintln(\"\\t T = \", T)\n\t\tbeta = 1/T\n\t\tmodel = IsingModel(dims=2, L=L)\n\t\tmc = MC(model, beta=beta)\n\t\trun!(mc, sweeps=sweeps, thermalization=therm, verbose=false)\n\t\tpush!(df, [L, T, mean(mc.obs[\"m\"]), mean(mc.obs[\"χ\"]), mean(mc.obs[\"e\"]), mean(mc.obs[\"C\"])])\n\tend\n\tflush(stdout)\nend\n\nsort!(df, [:L, :T])\n@save \"ising2d.jld\" df\n\n# plot results together\ngrps = groupby(df, :L)\nfig, ax = subplots(2,2, figsize=(12,8))\nfor g in grps\n\tL = g[:L][1]\n\tax[1].plot(g[:T], g[:E], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[2].plot(g[:T], g[:C_V], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[3].plot(g[:T], g[:M], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[4].plot(g[:T], g[:χ], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\nend\nax[1].legend(loc=\"best\")\nax[1].set_ylabel(\"Energy\")\nax[1].set_xlabel(\"Temperature\")\n\nax[2].set_ylabel(\"Specific heat\")\nax[2].set_xlabel(\"Temperature\")\nax[2].axvline(x=MonteCarlo.IsingTc, color=\"black\", linestyle=\"dashed\", label=\"\\$ T_c \\$\")\nax[2].legend(loc=\"best\")\n\nax[3].set_ylabel(\"Magnetization\")\nax[3].set_xlabel(\"Temperature\")\nx = range(1.2, stop=MonteCarlo.IsingTc, length=100)\ny = (1 .- sinh.(2.0 ./ (x)).^(-4)).^(1/8)\nax[3].plot(x,y, \"k--\", label=\"exact\")\nax[3].plot(range(MonteCarlo.IsingTc, stop=3.8, length=100), zeros(100), \"k--\")\nax[3].legend(loc=\"best\")\n\nax[4].set_ylabel(\"Susceptibility χ\")\nax[4].set_xlabel(\"Temperature\")\nax[4].axvline(x=MonteCarlo.IsingTc, color=\"black\", linestyle=\"dashed\", label=\"\\$ T_c \\$\")\nax[4].legend(loc=\"best\")\ntight_layout()\nsavefig(\"ising2d.pdf\")","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is a package implementing classical and quantum Monte Carlo simulations primarily for solid state physics. Currently the focus is on finding a overall design for the package and verifying that determinant Quantum Monte Carlo (DQMC) is working correctly. As such the package may still go through significant changes and the documentation may be outdated and incomplete.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Note that classical Monte Carlo is also not a focus at this point. It is probably usable, but a lot of the adjustments made to DQMC have not been added to classical Monte Carlo, or have been added without thorough testing.","category":"page"},{"location":"DQMC/recorder/#Configuration-Recorder-1","page":"Configuration Recorder","title":"Configuration Recorder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"Sometimes it's useful to keep configurations around, for example to perform new measurements after the original simulation has finished. This is especially true in the case of DQMC where simulations can take weeks to run, but measurement on their own are relatively fast. We currently offer two objects for this purpose - Discarder and ConfigRecorder.","category":"page"},{"location":"DQMC/recorder/#General-Interface-1","page":"Configuration Recorder","title":"General Interface","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"Any AbstractRecorder follows an array-like interface. Configurations are added via push!(recorder, mc, model, sweep) and can be retrieved via getindex. The recorder has a length and implements isempty. Furthermore it can be iterated, saved and loaded.","category":"page"},{"location":"DQMC/recorder/#Discarder-1","page":"Configuration Recorder","title":"Discarder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"As the name suggests this recorder simply discards all configurations. It is used by default for classical Monte-Carlo simulations.","category":"page"},{"location":"DQMC/recorder/#ConfigRecorder-1","page":"Configuration Recorder","title":"ConfigRecorder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"This recorder keeps track of compressed configurations in memory. On creation a rate can be specified as the last argument in the constructor to reduce the amount of configurations saved. Compression relies on overloads of compress(mc, model, conf) and decompress(mc, model, conf). For the available Hubbard models these simply transform from and to BitArray.","category":"page"}]
}
