var documenterSearchIndex = {"docs":
[{"location":"legacy/interfaces/MC/#Interface:-Monte-Carlo-(MC)-1","page":"MC","title":"Interface: Monte Carlo (MC)","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"Any model that wants to be simulated by means of MC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the Monte Carlo flavor Monte Carlo (MC).","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"Example models: Ising Model","category":"page"},{"location":"legacy/interfaces/MC/#Mandatory-fields-1","page":"MC","title":"Mandatory fields","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"l::Lattice: any Lattice","category":"page"},{"location":"legacy/interfaces/MC/#Index-of-all-methods-1","page":"MC","title":"Index of all methods","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"Pages = [\"MC.md\"]","category":"page"},{"location":"legacy/interfaces/MC/#Mandatory-methods-1","page":"MC","title":"Mandatory methods","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"CurrentModule = MonteCarlo","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"conftype(::Type{MC}, m::Model)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"energy(mc::MC, m::Model, conf)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"rand(::MC, ::Model)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"propose_local(mc::MC, m::Model, i::Int, conf, E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#MonteCarlo.propose_local-Tuple{MC, Model, Int64, Any, Float64}","page":"MC","title":"MonteCarlo.propose_local","text":"propose_local(mc::DQMC, m::Model, field::AbstractField, i::Int, slice::Int)\n\nPropose a local move for lattice site i at time slice slice for a field  holding the current configuration. Returns the Green's function determinant  ratio, the boson energy difference ΔE_boson = E_boson_new - E_boson, and any extra information passthrough that might be useful in accept_local.\n\nBy default this function will call propose_local(mc, field, i, slice).\n\nSee also accept_local!.\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"accept_local!(mc::MC, m::Model, i::Int, conf, E::Float64, delta_i, delta_E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#Optional-methods-1","page":"MC","title":"Optional methods","text":"","category":"section"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"global_move(mc::MC, m::Model, conf, E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"prepare_observables(mc::MC, m::Model)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"measure_observables!(mc::MC, m::Model, obs::Dict{String,Observable}, conf, E::Float64)","category":"page"},{"location":"legacy/interfaces/MC/#","page":"MC","title":"MC","text":"finish_observables!(mc::MC, m::Model, obs::Dict{String,Observable})","category":"page"},{"location":"legacy/models/hubbardattractive/#Attractive-Hubbard-Model-1","page":"Attractive Hubbard model","title":"Attractive Hubbard Model","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#Hamiltonian-1","page":"Attractive Hubbard model","title":"Hamiltonian","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The Hamiltonian of the attractive (negative U) Hubbard model reads","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} \\mathcal{H} = -t \\sum{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger{i\\sigma} c{j\\sigma} + \\text{h.c.} \\right) - |U| \\sumj \\left( n{j\\uparrow} - \\frac{1}{2} \\right) \\left( n{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sumj n{j}, \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"where sigma denotes spin, t is the hopping amplitude, U the on-site repulsive interaction strength, mu the chemical potential and langle i j rangle indicates that the sum has to be taken over nearest neighbors. Note that (1) is written in particle-hole symmetric form such that mu = 0 corresponds to half-filling.","category":"page"},{"location":"legacy/models/hubbardattractive/#Constructor-1","page":"Attractive Hubbard model","title":"Constructor","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"You can create an attractive Hubbard model instance as follows,","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"model = HubbardModelAttractive(dims=1, L=8)","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The following parameters can be set via keyword arguments:","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"dims::Int: dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)\nL::Int: linear system size\nt::Float64 = 1.0: hopping energy\nU::Float64 = 1.0: onsite interaction strength, \"Hubbard U\"\nmu::Float64 = 0.0: chemical potential","category":"page"},{"location":"legacy/models/hubbardattractive/#Supported-Monte-Carlo-flavors-1","page":"Attractive Hubbard model","title":"Supported Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Determinant Quantum Monte Carlo (DQMC), see details below","category":"page"},{"location":"legacy/models/hubbardattractive/#DQMC-formulation-1","page":"Attractive Hubbard model","title":"DQMC formulation","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"We decouple the onsite electron-electron interaction by performing a Hirsch transformation, i.e. a discrete Hubbard-Stratonovich transformation in the density/charge channel,","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} e^{|U|\\Delta \\tau \\left( n{i\\uparrow} - \\frac{1}{2} \\right) \\left(n{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum{s=\\pm 1} \\prod{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The interaction matrix of the model then reads","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} V{ij}(l) &= \\delta{ij} Vi(l), \\\\\nVi(l) &= - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"For completeness, the hopping matrix is \\begin{align} T_{ij} &= \\begin{cases} -t & \\text{if i and j are nearest neighbors,} \\\\\n-\\mu & \\text{if i == j,} \\\\\n0 & \\text{otherwise.} \\end{cases} \\end{align}","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"As neither T nor V depend on spin, neither does the equal-times Green's function. We can therefore restrict our computations to one spin flavor (flv=1) and benefit from operating with smaller matrices.","category":"page"},{"location":"legacy/models/hubbardattractive/#Potential-extensions-1","page":"Attractive Hubbard model","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Arbitrary lattices (so far only cubic lattices supported)","category":"page"},{"location":"DQMC/dqmc/#DQMC-1","page":"DQMC","title":"DQMC","text":"","category":"section"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"The DQMC struct represents both the determinant quantum monte carlo algorithm and the simulation as a whole. Because of that it includes a bunch of options that aren't directly relevant to the algorithm. The minimal default is given by dqmc = DQMC(model, beta=beta) and the simulation can then be started with run!(dqmc). Additional keyword arguments include:","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"beta: The inverse temperature of the simulation.\ndelta_tau = 0.1: The imaginary time discretization.\nslices = beta / delta_tau: The number of imaginary time slices.\nsafe_mult = 10: The number of save matrix multiplications.\nthermalization = 100: The number of thermalization sweeps.\nsweeps = 100: The number of measurement sweeps.\ncheck_sign_problem = true: Enables or disables checks for sign problems. (negative or imaginary probabilities)\ncheck_propagation_error = true: Enables or disables checks for time slices propagation errors. (Which may happen if safemult or deltatau is too large.)\nsilent = false: Enable or disable prints for the checks above.\nmeasure_rate = 10: Sets the frequency of measurements. Every measure_rate sweeps a new measurement is taken.\nprint_rate = 10: Sets the frequency of general information prints (not checks).\nseed = -1: Sets a random seed for the simulation. If set to -1 the seed will be chosen randomly.\nlast_sweep = 0: Sets the last finished sweep. Used internally for continued simulations.","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"Beyond this there are a couple of keyword arguments which are more involved and will be discussed in other chapters. These include","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"scheduler = SimpleScheduler(LocalSweep()): This sets up the sequence of updates performed by the simulation.\nmeasurements = Dict{Symbol, AbstractMeasurement}(): A collection of named measurements that run during the simulation. These are usually added after creating the simulation.\nthermalization_measurements = Dict{Symbol, AbstractMeasurement}(): Same as the above, but the measurements run during the thermalization stage. Might be useful to judge convergence or the number of necessary sweeps.\nrecorder = ConfigRecorder: A recorder for the configurations generated during the simulation.\nrecording_rate = measure_rate: The rate at which configurations are recorded.\nfield::Type = choose_field(model): The type of the field used by the simulation","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"Running a simulation also comes with a bunch of options via keyword arguments - most dealing with saving the simulation. The options for run(dqmc) include:","category":"page"},{"location":"DQMC/dqmc/#","page":"DQMC","title":"DQMC","text":"verbose = true: Enables or disables information printing during the runtime.\nignore = tuple(): Measurement keys to ignore during this run (none by default).\nsafe_before::TimeType = now() + Year(100): Sets a time stamp before which the simulation will cancel itself and save.\nsafe_every::TimePeriod = Hour(10000): Sets a time period interval for regular saves.\ngrace_period::TimePeriod = Minute(5): Sets a buffer time period for saving. By default saves at least 5 minutes before the requested time.\nresumable_filename = \"resumable_$datestring.jld2: Sets the name the savefile generated from safebefore and safeevery.\noverwrite = true: Enables or disables overwriting of existing files. \nmin_update_rate = 0.001: Sets a minimum update acceptance rate under which a simulation is considered \"failed\". This will only trigger after 1 / min_update_rate sweeps and only if all updates fall below this rate.\nfail_filename = \"failed_$datestring.jld2\": Sets the filename of a failed simulation.","category":"page"},{"location":"legacy/manual/gettingstarted/#Getting-Started-1","page":"Getting started","title":"Getting Started","text":"","category":"section"},{"location":"legacy/manual/gettingstarted/#Installation-1","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"MonteCarlo.jl hasn't yet been released. To clone the package execute the following command in the Julia REPL:","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"Pkg.clone(\"https://github.com/crstnbr/MonteCarloObservable.jl\")\nPkg.clone(\"https://github.com/crstnbr/MonteCarlo.jl\")","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"To update to the latest version of the package just do Pkg.update() or specifically Pkg.update(\"MonteCarlo\").","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"warning: Warning\nThe package is still in pre-alpha phase and shouldn't yet be used for production runs.","category":"page"},{"location":"legacy/manual/gettingstarted/#Usage-1","page":"Getting started","title":"Usage","text":"","category":"section"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"This is a simple demontration of how to perform a Monte Carlo simulation of the 2D Ising model:","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"# load packages\nusing MonteCarlo\n\n# load your model\nm = IsingModel(dims=2, L=8);\n\n# choose a Monte Carlo flavor and run the simulation\nmc = MC(m, beta=0.35);\nrun!(mc, sweeps=1000, thermalization=1000, verbose=false);\n\n# analyze results\nobservables(mc) # what observables do exist for that simulation?\nm = mc.obs[\"m\"] # magnetization\nmean(m)\nstd(m) # one-sigma error\n\n# create standard plots\nhist(m)\nplot(m)","category":"page"},{"location":"legacy/manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"legacy/flavors/dqmc/#Determinant-Quantum-Monte-Carlo-(DQMC)-1","page":"DQMC","title":"Determinant Quantum Monte Carlo (DQMC)","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"This is determinant quantum Monte Carlo (MC) also known auxiliary field quantum Monte Carlo. It can be used to simulate interacting fermion systems, here the auxiliary boson arises from a Hubbard Stratonovich transformation, or fermions which are naturally coupled to bosons. An example is the Attractive Hubbard Model.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"You can initialize a determinant quantum Monte Carlo simulation of a given model simply through","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"dqmc = DQMC(model, beta=5.0)","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Mandatory keywords are:","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"beta: inverse temperature","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Allowed keywords are:","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"delta_tau::Float64 = 0.1: imaginary time step size\nsafe_mult::Int = 10: stabilize Green's function calculations every safe_mult step (How many slice matrices can be multiplied until singular value information is lost due to numerical unaccuracy?)\ncheckerboard::Float64 = false: use Checkerboard decomposition (faster)\nsweeps: number of measurement sweeps\nthermalization: number of thermalization (warmup) sweeps\nseed: initialize DQMC with custom seed\nall_checks::Bool = true: turn off to suppress some numerical checks","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Afterwards, you can run the simulation by","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"run!(dqmc)","category":"page"},{"location":"legacy/flavors/dqmc/#Technical-details-1","page":"DQMC","title":"Technical details","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#Symmetric-Suzuki-Trotter-decomposition-1","page":"DQMC","title":"Symmetric Suzuki-Trotter decomposition","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"We use the symmetric version of the Suzuki-Trotter decomposition, i.e.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"\\begin{align} e^{-\\Delta\\tau \\suml T+V(l)} = \\prodj e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"where T is the hopping matrix and V(l) is the interaction matrix with l an imaginary time slice index indicating an auxiliary field dependence.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"With the imaginary time slice matrices B_l = e^-Deltatau T2 e^-Deltatau V(l) e^-Deltatau T2 the equal-time Green's function is G = left( 1 + B_M cdots B_1 right)^-1.","category":"page"},{"location":"legacy/flavors/dqmc/#Checkerboard-decomposition-1","page":"DQMC","title":"Checkerboard decomposition","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"We provide a general algorithm to construct the \"checkerboard\" split up of a generic AbstractLattice. The only requirement is that the AbstractLattice has the following two fields,","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"n_bonds::Int: total number of bonds (lattice graph edges)\nbonds::Matrix{Int}: bond matrix of shape (n_bonds, 3). Rows correspond to bonds and columns indicate source site, target site, and bond type in this order.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Of course, one can also manually construct a (more efficient) checkerboard split up by overloading the following function for the specific AbstractLattice subtype.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"MonteCarlo.build_checkerboard(l::MonteCarlo.AbstractLattice)","category":"page"},{"location":"legacy/flavors/dqmc/#MonteCarlo.build_checkerboard-Tuple{AbstractLattice}","page":"DQMC","title":"MonteCarlo.build_checkerboard","text":"build_checkerboard(l::Lattice)\n\nGenerates a collection of groups containing (src, trg) pairs where each group  only touches each site (src or trg) once. Each group also represents only one  bond direction, though multiple groups can represent the same direction. Bond  reversals (i.e. trg -> src relative to src -> trg) are not considered here, as  they are always present.\n\nReturns groups in a nested structure groups[idx1][idx2][idx3], where idx1 picks the bond direction, idx2 a subset with non-overlapping sites and idx3 the individual site pairs involved in a bond.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#Effective-slice-matrices-and-Green's-function-1","page":"DQMC","title":"Effective slice matrices and Green's function","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Combining the symmetric Suzuki-Trotter and checkerboard decomposition we can write (assuming two checkerboard groups a and b)","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"\\begin{align} e^{-\\Delta\\tau \\suml T+V(l)} &= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} \\\\\n&\\times \\left( \\prodj e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"For performance resons we internally work with effective imaginary time slice matrices","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"B_l^texteff = e^-Deltatau T_b2 e^-Deltatau T_a e^-Deltatau T_b2 e^-Deltatau V","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"instead of the original B_ls above.","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"warning: Warning\nNote that one consequence is that the field dqmc.s.greens isn't the actual Green's function but an effective one defined by \\begin{align} G &= \\left( 1 + BM \\cdots B1 \\right)^{-1} \\\\\n&= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} \\left( 1 + B^{\\text{eff}}M \\cdots B^{\\text{eff}}1 \\right)^{-1} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta/2} \\\\\n&= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} G^{\\text{eff}} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta/2} \\end{align}To obtain the actual equal-times Green's function, for example for measuring, use greens(dqmc::DQMC). Note that although Goverset=G^texteff} one can readily show that det G = det G^texteff holds and the Metropolis acceptance is not affected by switching to the effective matrices.","category":"page"},{"location":"legacy/flavors/dqmc/#Exports-1","page":"DQMC","title":"Exports","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"DQMC.jl\"]","category":"page"},{"location":"legacy/flavors/dqmc/#MonteCarlo.replay!","page":"DQMC","title":"MonteCarlo.replay!","text":"replay(mc::DQMC[; configurations::Iterable = mc.recorder; kwargs...])\n\nReplays previously generated configurations and measures observables along the way.\n\nKeyword Arguments (both):\n\nverbose = true: If true, print progress messaged to stdout.\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, replay! will generate a\n\nresumable save file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nfilename: Name of the save file. The default is based on safe_before.\nstart=1: The first sweep in the simulation. This will be changed when using\n\nresume!(save_file).\n\nignore: A collection of measurement keys to ignore. Defaults to the key of\n\nthe configuration measurement.\n\nmeasure_rate = 1: Rate at which measurements are taken. Note that this is \n\nbased on the recorded configurations, not actual sweeps.\n\n\n\n\n\n","category":"function"},{"location":"legacy/flavors/dqmc/#MonteCarlo.run!-Tuple{DQMC}","page":"DQMC","title":"MonteCarlo.run!","text":"run!(mc::DQMC[; kwargs...])\n\nRuns the given Monte Carlo simulation mc. Returns SUCCESS::ExitCode = 0 if  the simulation finished normally or various other codes if failed or cancelled.  See ExitCode.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nthermalization: Number of thermalization sweeps. Uses the value passed to\n\nDQMC by default.\n\nsweeps: Number of measurement sweeps. Uses the value passed to DQMC by\n\ndefault.\n\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, run! will generate a resumable\n\nsave file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nresumable_filename: Name of the resumable save file. The default is based on\n\nsafe_before.\n\noverwrite = false: If set to true a file with the same name as\n\nresumable_filename will be overwritten. (This will create a temporary backup)\n\nSee also: resume!\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#MonteCarlo.DQMC-Tuple{Model, Dict{Symbol, V} where V}","page":"DQMC","title":"MonteCarlo.DQMC","text":"DQMC(m::M, params::Dict)\nDQMC(m::M, params::NamedTuple)\n\nCreate a determinant quantum Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#MonteCarlo.DQMC-Tuple{M} where M<:Model","page":"DQMC","title":"MonteCarlo.DQMC","text":"DQMC(m::M; kwargs...) where M<:Model\n\nCreate a determinant quantum Monte Carlo simulation for model m with keyword parameters kwargs.\n\nKeyword Arguments:\n\nseed: The random seed used by the simulation.\ncheckerboard=false: If true, the simulation uses a generic checkerboard\n\ndecomposition.\n\nthermalization_measurements::Dict{Symbol, AbstractMeasurement}: A collection\n\nof measurements run during the thermalization stage. By default, none are used.\n\nmeasurements::Dict{Symbol, AbstractMeasurement}: A collection of measurements\n\nrun during the measurement stage. Calls default_measurements if not specified.\n\nrecorder = ConfigRecorder: Type of recorder used for saving configurations\n\ngenerated during the simulation. Used (by default) when replay!ing simulations.  (Discarder or ConfigRecorder)\n\nrecording_rate = measure_rate: Rate at which configurations are recorded.\nthermalization = 100: Number of thermalization sweeps\nsweeps: Number of measurement sweeps\nall_checks = true: Check for Propagation instabilities and sign problems.\nsafe_mult = 10: Number of \"safe\" matrix multiplications. Every safe_mult\n\nmultiplications, a UDT decomposition is used to stabilize the product.\n\ndelta_tau = 0.1: Time discretization of the path integral\nbeta::Float64: Inverse temperature used in the simulation\nslices::Int = beta / delta_tau: Number of imaginary time slice in the\n\nsimulation\n\nmeasure_rate = 10: Number of sweeps discarded between every measurement.\nlast_sweep = 0: Sets the index of the last finished sweep. The simulation\n\nwill start with sweep last_sweep + 1.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/dqmc/#Potential-extensions-1","page":"DQMC","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"todo","category":"page"},{"location":"DQMC/measurements/#Measurements-1","page":"Measurements","title":"Measurements","text":"","category":"section"},{"location":"DQMC/measurements/#Construction-Measurements-1","page":"Measurements","title":"Construction Measurements","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Measurement are created and added to a Simulation via dqmc[:name] = measurement(dqmc, model). Various properties of the measurement can be adjusted via keyword arguments, such as the lattice iteration scheme or the Wicks expanded expectation value. This will be discussed in more detail later.","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The currently implemented measurements are the following:","category":"page"},{"location":"DQMC/measurements/#Greens-1","page":"Measurements","title":"Greens","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The equal time greens function can be measured via greens_measurement(dqmc, model). The measurement will take the Monte Carlo average of greens(dqmc, model).","category":"page"},{"location":"DQMC/measurements/#Occupation-1","page":"Measurements","title":"Occupation","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The per-site occupation langle n_i rangle can be measured via occupation(dqmc, model). This will average 1 - G_ii.","category":"page"},{"location":"DQMC/measurements/#Charge-Density-1","page":"Measurements","title":"Charge Density","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The charge density correlation langle sum_r n(r) n(r+Delta r) rangle can be measured with charge_density_correlation(dqmc, model). The time integral of that, the charge density susceptibility can be measure with charge_density_susceptibility(mc, model).","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Note that you can also pass kernel = MonteCarlo.reduced_cdc_kernel to measure just the correlated part, i.e. langle sum_r n(r) n(r+Delta r) rangle - langle n(r) rangle langle n(r+Delta r) rangle instead.","category":"page"},{"location":"DQMC/measurements/#Magnetization-1","page":"Measurements","title":"Magnetization","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"magnetization(dqmc, model, dir::Symbol) measures the per-site x-, y- or z-magnetizations.","category":"page"},{"location":"DQMC/measurements/#Spin-Density-1","page":"Measurements","title":"Spin Density","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The spin density correlation langle S_gamma S_gamma rangle in x-, y- or z-direction can be measured with spin_density_correlation(dqmc, model, dir::Symbol). The respective susceptibilities follow from spin_density_susceptibility(dqmc, model, dir).","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Like with charge density there are additional kernels that only measure the correlated part of the spin density. Use kernel = MonteCarlo.reduced_sdc_γ_kernel with gamma in x y z for the respective direction.","category":"page"},{"location":"DQMC/measurements/#Pairing-1","page":"Measurements","title":"Pairing","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The pairing susceptibility Delta_v(s_1 t_1)(tau) Delta_v^dagger(s_2 t_2)(0) can be calculated with pairing_susceptibility(dqmc, model). The tau = 0 pairing correlation follows from pairing_correlation(dqmc, model).","category":"page"},{"location":"DQMC/measurements/#Current-Current-Susceptibility-1","page":"Measurements","title":"Current-Current Susceptibility","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"current_current_susceptibility(dqmc, model) measures langle j_t_2 - s_2(s_2 l) j_t_1 - s_1(s_1 0)rangle with j_t - s(s tau) = langle i sum_sigma T_ts c_t^dagger(tau) c_s(tau) - T_st c_s^dagger(tau) c_t(tau) rangle where i^2 = -1 and T is the hopping matrix.","category":"page"},{"location":"DQMC/measurements/#Superfluid-Density-1","page":"Measurements","title":"Superfluid Density","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The superfluid density can be derived from the current-current susceptibility and the Greens function. [MonteCarloAnalysis.jl](https://github.com/ffreyer/MonteCarloAnalysis] provides functionality for that.","category":"page"},{"location":"DQMC/measurements/#Energies-1","page":"Measurements","title":"Energies","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The energy can be measured with total_energy(dqmc, model). The interacting and hopping parts can be measured independently with interaction_energy(dqmc, model) and kinetic_energy(dqmc, model)","category":"page"},{"location":"DQMC/measurements/#General-Notes-1","page":"Measurements","title":"General Notes","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"All measurements are implemented via","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"struct DQMCMeasurement{F <: Function, GI, LI, FI, OT, T} <: AbstractMeasurement\n    greens_iterator::GI\n    lattice_iterator::LI\n    flavor_iterator::FI\n    kernel::F\n    observable::OT\n    temp::T\nend","category":"page"},{"location":"DQMC/measurements/#kernel-1","page":"Measurements","title":"kernel","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The auxiliary field dependent greens function is readily available at any point in the simulation. As such it is the object on which measurements typically rely on. Using Wick's theorem most expectation values can be expressed in terms of greens function elements G_ij(k l) = langle c_i(k Deltatau) c_j^dagger(l Deltatau)rangle where i j represent sites and flavors (spins), and k l represent imaginary time. The kernel implements this expanded form. ","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"For example, the full_cdc_kernel implementing langle sum_r n(r) n(r+Delta r) rangle looks like this:","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"@inline Base.@propagate_inbounds function full_cdc_kernel(\n        mc, ::Model, ij::NTuple{2}, packed_greens::_GM4{<: Matrix}, flv\n    )\n    i, j = ij\n    f1, f2 = flv\n\tG00, G0l, Gl0, Gll = packed_greens\n    N = length(lattice(mc))\n    \n    id = I[i, j] * I[G0l.k, G0l.l] * I[f1, f2]\n    s1 = N * (f1 - 1)\n    s2 = N * (f2 - 1)\n\n    # ⟨n_{σ₁}(l) n_{σ₂}(0)⟩ =\n    #   ⟨n_{σ₁}(l)⟩ ⟨n_{σ₂}(0)⟩ + \n    #   ⟨c_{σ₁}^†(l) c_{σ₂}(0)⟩ ⟨c_{σ₁}(l) c_{σ₂}^†(0)⟩ =\n    return (1 - Gll.val[i+s1, i+s1]) * (1 - G00.val[j+s2, j+s2]) +\n            (id - G0l.val[j+s1, i+s2]) * Gl0.val[i+s1, j+s2]\nend","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"Here i, j = ij are site indices representing r r + Delta r coming from the lattice iterator, G00, G0l, Gl0, Gll = packed_greens are Greens matrices at different imaginary times coming from the greens iterator, and f1, f2 = flv are flavor (spin) indices coming from the flavor iterator. The result of the kernel is the charge density expectation value for a specific set of those indices.","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"These functions generally have a specialized methods implemented for the different matrix types that are used in DQMC. You can check the source code under \"flavors/DQMC/measurements/constructors\" for more examples. ","category":"page"},{"location":"DQMC/measurements/#greens_iterator-1","page":"Measurements","title":"greens_iterator","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The greens_iterator controls which Greens functions are passed on to the kernel. Internally measurements that use the same greens_iterator will be bundled to avoid expensive recalculations. The available iterators include:","category":"page"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"nothing specifies that no Greens function is needed\nGreens() forwards the equal time greens function G(0, 0) (which matches all other equal time greens functions)\nGreensAt(k, l) forwards the result of greens(dqmc, k, l), i.e. a greens function at the specific time indices k l.\nTimeIntegral([recalculate = 2 mc.parameters.safe_mult]) creates an iterator for calculating imaginary time integral of the form O_i = int_0^beta O_(tau) dtau as O_i approx sum_l = 0^M-1 05 Deltatau (O_(l Deltatau) + O_((l+1) Deltatau)). In every step this iterator will generate four greens matrices G(0 0), G(0 lDeltatau), G(lDeltatau 0), G(lDeltatau lDeltatau). This internally uses CombinedGreensIterator(mc[; start, stop, recalculate]) to generate these matrices.","category":"page"},{"location":"DQMC/measurements/#lattice_iterator-1","page":"Measurements","title":"lattice_iterator","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The lattice_iterator controls which combination of site indices are passed to the kernel and how they are further combined before saving the measurements. For example, EachSitePairByDistance passes any combination of two sites indices to the kernel and sums up site pairs which have the same distance between them. See the Lattices section for more detail.","category":"page"},{"location":"DQMC/measurements/#flavor_iterator-1","page":"Measurements","title":"flavor_iterator","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The flavor_iterator similarly specifies which flavor (spin) indices should be iterated. This is primarily an optimization used to pull a flavor sum out of the kernel. Note that this is not always possible/useful, so some measurements may not use this iterator even though multiple flavors are involved. As such this iterator should generally not be adjusted.","category":"page"},{"location":"DQMC/measurements/#observable-1","page":"Measurements","title":"observable","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The observable is the final storage of the measured values. By default this is a LogBinner from BinningAnalysis.jl but that can be changed. The only hard requirement is that the data structure implements push!. If you want to use your own storage structure you can get a zero element from MonteCarlo._binner_zero_element(dqmc, lattice_iterator, MonteCarlo.geltype(dqmc)) if you need it.","category":"page"},{"location":"DQMC/measurements/#temp-1","page":"Measurements","title":"temp","text":"","category":"section"},{"location":"DQMC/measurements/#","page":"Measurements","title":"Measurements","text":"The temp field is a temporary storage Array used as a target for summation before pushing the final result of the measurement. It should be initialized with MonteCarlo._measurement_buffer(dqmc, lattice_iterator, geltype(dqmc)). Note that this is often but not always the same as the zero element.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Topological-Flat-Band-Model-1","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"This will be a rather extensive example and crosscheck with the 2020 paper \"Superconductivity, pseudogap, and phase separation in topological flat bands:'a quantum Monte Carlo study\" (arxiv) by Hofmann, Berg and Chowdhury. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#Introduction-1","page":"Topological Flat Band Model","title":"Introduction","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The paper investigates an attractive square lattice Hubbard model with complex hoppings up to the 5th order. It generates a flat and a dispersive band, where the flatness of the former can increased with the right ratio of hoppings. At partial filling of the flat band superconductivity is observed. The model reads","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"beginaligned\n\tH_kin = left\n        -t_1 sum_langle i j rangle_1 sigma e^iphi_ij^sigma c_i sigma^dagger c_j sigma\n        -t_2 sum_langle i j rangle_2 sigma s_langle i j rangle_2 c_i sigma^dagger c_j sigma\n        -t_5 sum_langle i j rangle_5 sigma c_i sigma^dagger c_j sigma\n        + hc\n    right - mu sum_i n_i \n    H_int = - fracU2 sum_i (n_i - 1)^2\nendaligned","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where t_n refers to n-th nearest neighbor hopping and langle i j rangle_n refers to the involved site pairs. We will discuss the prefactors more closely when implementing the lattice model. The interactive term is a variation of what we use in our standard attractive Hubbard model and can be dealt with using the same Hirsch transformation.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Implementation-1","page":"Topological Flat Band Model","title":"Implementation","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#The-Lattice-1","page":"Topological Flat Band Model","title":"The Lattice","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The model is defined for a square lattice, however the paper suggests defining it via two site basis A = (0 0), B = (0 1) with lattice vector a_1 = (1 1) and a_2 = (1 -1). We will follow this suggestion. The model uses first, second and fifth neighbor hoppings.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The nearest neighbors are directed, catching different values for phi_ij^sigma as a result. We need to create two groups, one with directions as indicated in figure 1a) in the paper, and one with the reverse. For second nearest neighbors the prefactor s_langle i j rangle_2 depends on the combination of sublattice and direction. In a_1 direction the value is positive (negative) on the A (B) sublattice, and in a_2 it is negative (positive) on the A (B) sublattice. The fifth nearest neighbors always have the same weight and thus do not require special grouping.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"using MonteCarlo: UnitCell, Bond, Lattice\n\nfunction HBCLattice(Lx, Ly = Lx)\n    uc = UnitCell(\n        # name\n        \"HBC Square\",\n\n        # Bravais lattice vectors\n        ([1.0, +1.0], [1.0, -1.0]),\n        \n        # Sites\n        [[0.0, 0.0], [0.0, 1.0]],\n\n        # Bonds\n        [\n            # NN, directed\n            # bonds from ref plot, π/4 weight for spin up\n            Bond(1, 2, ( 0,  1), 1),\n            Bond(1, 2, (-1,  0), 1),\n            Bond(2, 1, (+1, -1), 1),\n            Bond(2, 1, ( 0,  0), 1),\n\n            # NN reversal\n            Bond(2, 1, ( 0, -1), 2),\n            Bond(2, 1, (+1,  0), 2),\n            Bond(1, 2, (-1, +1), 2),\n            Bond(1, 2, ( 0,  0), 2),\n            \n            # NNN\n            # positive weight (we need forward and backward facing bonds here too)\n            Bond(1, 1, (+1,  0), 3),\n            Bond(1, 1, (-1,  0), 3),\n            Bond(2, 2, ( 0, +1), 3),\n            Bond(2, 2, ( 0, -1), 3),\n            # negative weight\n            Bond(1, 1, ( 0, +1), 4),\n            Bond(1, 1, ( 0, -1), 4),\n            Bond(2, 2, (+1,  0), 4),\n            Bond(2, 2, (-1,  0), 4),\n            \n            # Fifth nearest neighbors\n            Bond(1, 1, (2, 0), 5),\n            Bond(2, 2, (2, 0), 5),\n            Bond(1, 1, (0, 2), 5),\n            Bond(2, 2, (0, 2), 5),\n            # backwards facing bonds\n            Bond(1, 1, (-2,  0), 5),\n            Bond(2, 2, (-2,  0), 5),\n            Bond(1, 1, ( 0, -2), 5),\n            Bond(2, 2, ( 0, -2), 5),\n        ]\n    )\n\n    return Lattice(uc, (Lx, Ly))\nend","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"With this implementation we can then generate a lattice of arbitrary size with","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"L = 8\nl = HBCLattice(L)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where L is the linear system size. Note that due to the two basis sites the total number of sites is 2L^2. To verify our lattice implementation it is useful to create a comparable plot. In Makie, for example, we may run","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"using GLMakie\n\n# get small lattice without periodic bonds\nl = HBCLattice(3)\n\n# create figure and axis without background grid and stretching\nfig = Figure()\nax = Axis(fig[1, 1], aspect=DataAspect(), xgridvisible = false, ygridvisible = false)\n\n# collect list of bonds grouped by label\nps = Point2f.(positions(l))\nls = [Point2f[] for _ in 1:5]\nfor b in bonds_open(l, true)\n    push!(ls[b.label], ps[b.from], ps[b.to])\nend\n\n# Draw arrows for NN groups\nds = ls[1][2:2:end] .- ls[1][1:2:end]\na = arrows!(ax, ls[1][1:2:end] .+ 0.35 .* ds, 0.55 .* ds, color = :black, arrowsize = 16)\nds = ls[2][2:2:end] .- ls[2][1:2:end]\narrows!(ax, ls[2][1:2:end] .+ 0.65 .* ds, 0.25 .* ds, color = :lightgray, arrowsize = 16)\n\n# NNN\nlinesegments!(ax, ls[3], color = :black, linewidth=1)\nlinesegments!(ax, ls[4], color = :black, linewidth=1, linestyle = :dash)\n\n# 5th nearest neighbors\nlinesegments!(ax, ls[5] .+ Point2f(0, 0.05), color = :red)\n\n# draw A and B sites\nAs = ps[1, :, :][:]\nBs = ps[2, :, :][:]\nscatter!(ax, As, color = :black, markersize = 10)\nscatter!(ax, Bs, color = :black, marker='■', markersize = 16)\n\n# Label A and B sites\ntext!(ax, \"A\", position = Point2f(2-0.2, 0), align = (:right, :center))\ntext!(ax, \"B\", position = Point2f(2-0.2, 1), align = (:right, :center))\n\nMakie.save(\"HBC_lattice.png\", fig)\nfig\n\n","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"In the plot we indicate the first group of nearest neighbors with black arrows and the second, i.e. the reversals with light gray ones. Next nearest neighbors are indicated with full (group 3) or dashed lines (group 4) like in the paper. The fifth nearest neighbors (group 5) are drawn in red like in the reference.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Hopping-and-Interaction-Matrix-1","page":"Topological Flat Band Model","title":"Hopping and Interaction Matrix","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Now that we have the lattice we can generate a fitting hopping matrix. But before we do this, let us briefly discuss some optimizations. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"LoopVectorization.jl is a great tool when pushing for peak single threaded/single core linear algebra performance. The linear algebra needed for DQMC is reimplemented in MonteCarlo.jl using it for both Float64 and ComplexF64. The latter uses MonteCarlo.CMat64 and MonteCarlo.CVec64 as concrete array types which are based on StructArrays.jl under the hood. They should be used in this model. Furthermore we can make use of MonteCarlo.BlockDiagonal as we have no terms with differing spin indices. Thus we set","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"using MonteCarlo: StructArray, BlockDiagonal, CMat64\n\nMonteCarlo.@with_kw_noshow struct HBCModel <: Model\n    # parameters with defaults based on paper\n    mu::Float64 = 0.0\n    U::Float64 = 1.0\n    @assert U >= 0. \"U must be positive.\"\n    t1::Float64 = 1.0\n    t2::Float64 = 1.0 / sqrt(2.0)\n    t5::Float64 = (1 - sqrt(2)) / 4\n\n    # lattice\n    l::Lattice{2}\n    @assert l.unitcell.name == \"HBC Square\"\nend\n\nMonteCarlo.hopping_eltype(::Type{DQMC}, ::HBCModel) = ComplexF64\nMonteCarlo.hopping_matrix_type(::Type{DQMC}, ::HBCModel) = BlockDiagonal{ComplexF64, 2, CMat64}\nMonteCarlo.greens_eltype(::Type{DQMC}, ::HBCModel) = ComplexF64\nMonteCarlo.greens_matrix_type( ::Type{DQMC}, ::HBCModel) = BlockDiagonal{ComplexF64, 2, CMat64}","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"for our model. The definition of the hopping matrix then follows from the various weights in the Hamiltonian as","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"function MonteCarlo.hopping_matrix(m::HBCModel)\n    # number of sites\n    N = length(m.l)\n\n    # spin up and spin down blocks of T\n    tup = diagm(0 => fill(-ComplexF64(m.mu), N))\n    tdown = diagm(0 => fill(-ComplexF64(m.mu), N))\n\n    # positive and negative prefactors for t1, t2\n    t1p = m.t1 * cis(+pi/4) # ϕ_ij^↑ = + π/4\n    t1m = m.t1 * cis(-pi/4) # ϕ_ij^↓ = - π/4\n    t2p = + m.t2\n    t2m = - m.t2\n    \n    for b in bonds(m.l, Val(true))\n        # NN paper direction\n        if b.label == 1 \n            tup[b.from, b.to]   = - t1p\n            tdown[b.from, b.to] = - t1m\n        \n        # NN reverse direction\n        elseif b.label == 2\n            tup[b.from, b.to]   = - t1m\n            tdown[b.from, b.to] = - t1p\n            \n        # NNN solid bonds\n        elseif b.label == 3\n            tup[b.from, b.to]   = - t2p\n            tdown[b.from, b.to] = - t2p\n\n        # NNN dashed bonds\n        elseif b.label == 4\n            tup[b.from, b.to]   = - t2m\n            tdown[b.from, b.to] = - t2m\n\n        # Fifth nearest neighbors\n        else\n            tup[b.from, b.to]   = - m.t5\n            tdown[b.from, b.to] = - m.t5\n        end\n    end\n\n    return BlockDiagonal(StructArray(tup), StructArray(tdown))\nend","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"We note that the hermitian conjugates of a hopping c_j^dagger c_i can also be understood as reversing the bond direction. Since we include both directions in our lattice definitions, second and fifth nearest neighbor hermitian conjugates are taken care of. First nearest neighbors get a phase shift from complex conjugation, which is included by swapping t1p and t1m between group one and two.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To finish off the mandatory model interface we need to provide three more methods. The first is lattice(model) which simply return the lattice of the model. The other two are unique_flavors(model) and total_flavors(model). The latter returns the total number of flavors a model has without making use of any symmetries, i.e. 2 for a spin 1/2 model. The former returns the number of flavors that will result in unique entries in the hopping matrix. For this model we have a hopping directly depending on spin, thus also 2 flavors here.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"MonteCarlo.lattice(m::HBCModel) = m.l\nMonteCarlo.unique_flavors(::HBCModel) = 2\nMonteCarlo.total_flavors(::HBCModel) = 2","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"There are a few more methods we can implement for convenience. The most important of these is choose_field(model), which sets a default field for our model. The best choice here should be DensityHirschField or DensityGHQField as the model uses an attractive interaction. Beyond this we could implement parameters(model), save_model, _load_model and printing.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"HBCModel(l::MonteCarlo.AbstractLattice; kwargs...) = HBCModel(l = l; kwargs...)\nMonteCarlo.choose_field(::HBCModel) = DensityHirschField","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The full code including these convenience functions can be found here","category":"page"},{"location":"examples/HofmannBergChowdhury/#Simulation-Setup-1","page":"Topological Flat Band Model","title":"Simulation Setup","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To keep the runtime of this crosscheck reasonable we used the smallest linear system size the paper considers, L = 8. We also set U = 1 and the fifth nearest neighbor hopping t5 = 0. This corresponds to a flatness ratio F = 02. To be comparable to the paper we will need to tune the chemical potential mu to hit half filling. This can be done through trial and error on a smaller lattice. The optimal mu, after running the main simulation with a small set of different values, seems to be mu approx -2206. Thus the basic setup for our simulation becomes","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"l = HBCLattice(8)\nm = HBCModel(l, t5 = 0.0, mu = -2.206) # other defaults match F = 0.2 setup\nmc = DQMC(\n    m, beta = beta, thermalization = 1000, sweeps = 5000, \n    measure_rate = 5, print_rate = 100, recorder = Discarder()\n)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where beta needs to run over a reasonable set of inverse temperatures. We will use [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 10.0, 12.0, 14.0, 17.0, 20.0, 25.0, 30.0, 35.0, 40.0]. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"note: Note\nIn our actual simulation we used a BufferedConfigRecorder to record configurations. That way the simulation can be replayed with different measurements. This is very useful when you are still unsure about what you want to measure or how exactly those measurements are supposed to work.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Measurements-1","page":"Topological Flat Band Model","title":"Measurements","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"We will consider the following measurements for comparison:","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Z-spin susceptibility, solid red line in figure 1d)\nSuperfluid stiffness, figure 2b)\nReciprocal s-wave pairing susceptibility, solid red line in figure 4a)\nReciprocal charge susceptibility, solid blue line in figure 4a)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Z-Spin-Susceptibility-1","page":"Topological Flat Band Model","title":"Z-Spin Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The z-spin susceptibility int_0^beta dtau langle m_z(r^prime tau) m_z(r 0) rangle can be measure with","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:SDSz] = spin_density_susceptibility(mc, m, :z)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The integral will be evaluated by MonteCarlo.jl and the result, accessible with mean(mc[:SDCz]), will return the average result by direction. I.e. mean(mc[:SDCz])[i] will contain the average z-spin susceptibility in directions(mc)[i].","category":"page"},{"location":"examples/HofmannBergChowdhury/#Reciprocal-Charge-Susceptibility-1","page":"Topological Flat Band Model","title":"Reciprocal Charge Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The paper defines the charge susceptibility as int_0^beta dtau langle N(tau) N(0) rangle where N(tau) = sum_j (n_j(tau) - nu) and nu is the filling. The charge density susceptibility that MonteCarlo.jl defines, on the other hand, is langle n_j(tau) n_i(0)rangle. To connect these two we expand the papers' definition:","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"beginaligned\n\tlangle N(tau) N(0) rangle \n        = langle sum_j (n_j(tau) - nu) sum_i (n_i(0) - nu) rangle \n        = sum_ij langle n_j(tau) n_i(0) - n_j(tau) nu - nu n_i(0) + nu nu rangle \n        = sum_ij langle n_j(tau) n_i(0) rangle - langle sum_i n_i rangle^2\nendaligned","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"In the last step we associated nu = sum_i langle n_i rangle  N, i.e. the average occupation. We can use this representation to calculate the reciprocal charge susceptibility as 1  (O - nu^2) where O is MonteCarlo.jl's charge density susceptibility and nu is the average occupation. We measure","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:occ] = occupation(mc, m)\nmc[:CDS] = charge_density_susceptibility(mc, m)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Reciprocal-S-Wave-Pairing-Susceptibility-1","page":"Topological Flat Band Model","title":"Reciprocal S-Wave Pairing Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The paper defines the (s-wave) pairing susceptibilities as O(tau) = sum_j c_j uparrow c_j downarrow + hc. More generally you would consider a site offset between the pairs of operators and use weighted sums to get pairing susceptibilities of various symmetries like d-wave, p-wave, etc. For s-wave this offset is vec0. In MonteCarlo.jl these offsets are set via the lattice iterator. For example you may use EachLocalQuadByDistance([2, 4, 5]) to consider the directions(mc)[[2, 4, 5]] as offsets. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The pairing_suceptibility constructors from MonteCarlo.jl is written with these offsets in mind. By default it will include offsets for all nearest neighbors as well as offsets of vec0. To reduce computational complexity we may reduce these to just vec0 offsets by requesting just first offset:","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:PS] = pairing_susceptibility(mc, m, K=1)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Superfluid-Stiffness-1","page":"Topological Flat Band Model","title":"Superfluid Stiffness","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The superfluid stiffness is given by 025 - K_x - Lambda_xx(q = 0) in the paper. Both the diamagnetic contribution K_x and the Fourier transformed current-current correlation Lambda_xx(q) are things we need to measure individually.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The diamagnetic contribution K_x is the simpler one. For that we refer to equations 15a - 15j in the paper. The sum of all of these is the K_x we seek. Since all terms are quadratic in creation and annihilation operators we do not need to worry about expanding them with Wicks theorem. Instead we can simply measure the Greens matrix during the simulation. If we compare the equations with the Hamiltonian we will also notice that they are (almost) the same as the hopping terms. Thus we can get weights from the hopping matrix and apply them afterwards. We measure","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:G] = greens_measurement(mc, m)","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"For current-current correlations we need to measure int_0^beta d tau langle J_x^alpha(r^prime tau) J_x^beta(r 0) rangle where J_x(r tau) is given in equation 14a - 14j. These terms are partially implemented in MonteCarlo.jl with rest implemented in MonteCarloAnalysis.jl.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"Specifically MonteCarlo.jl implements cc_kernel as a generic version of the terms 14a - 14j with the directional prefactor langle hatx Delta r_alpha removed. These prefactors are instead introduced in cached_para_ccc from MonteCarloAnalysis.jl, which computes Lambda_xx(q). The hopping directions considered in cc_kernel are set by the lattice iterator. By default, it will consider half the bonds of the lattice, dropping reverse bonds. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The included bonds can be adjusted by passing a lattice_iterator = EachBondPairByBravaisDistance([1,6,9,11,13,15]) to the measurements. The indices apply to lattice(mc).unitcell.bonds and in this case pick the bonds fitting terms 14a - 14f. The remaing terms are 0 with the choice of t_5 = 0.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"mc[:CCS] = current_current_susceptibility(\n    mc, m, lattice_iterator = EachBondPairByBravaisDistance([1,6,9,11,13,15])\n)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Running-the-simulations-1","page":"Topological Flat Band Model","title":"Running the simulations","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To run the simulation we simply use run!(mc).","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"We should point out that these simulations are lot more complex than the other two examples. We are working with 128 sites as opposed to 16 and inverse temperatures as large as 40 instead of le 12. We are also using complex matrices which bring 2 - 4 times the complexity and we need to consider both a spin up and down sector in the greens matrix. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"It is therefore advised that you run this on a cluster, in parallel. To figure out how much time is needed you can check the sweep time for the smallest beta with measurements. The scaling should be roughly linear (w.r.t. beta). Note that you can pass a safe_before::TimeType to make sure the simulation saves and exits in time. If your cluster restricts you to full nodes it might be useful to create files for each simulation beforehand and distribute filenames to different cores on the same node. (src/mpi.jl might be helpful.)","category":"page"},{"location":"examples/HofmannBergChowdhury/#Results-1","page":"Topological Flat Band Model","title":"Results","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"In this section we plot the results from our simulations on top of the results from the paper. There are 5 points per temperature coming from different chemical potentials mu. The filling varies from 0.22 to 0.265 between them. Note also that not every simulation did the full number of sweeps. The shortest simulation ran for about 3000 sweeps, which includes 1000 thermalization sweeps.","category":"page"},{"location":"examples/HofmannBergChowdhury/#Z-Spin-Susceptibility-2","page":"Topological Flat Band Model","title":"Z-Spin Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To get the results from the paper we need to perform a q = 0 Fourier transform which is simply a sum. We calculate real(sum(mean(mc[:SDCz]))) and plot against 1 / mc.parameters.beta.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"examples/HofmannBergChowdhury/#Reciprocal-Charge-Susceptibility-2","page":"Topological Flat Band Model","title":"Reciprocal Charge Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"For the reciprocal charge susceptibility we plot","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"CDS = real(sum(mean(mc[:CDS])))\nocc = real(sum(mean(mc[:occ])))\nxs = 1 / mc.parameters.beta\nys = 1 / (CDS - mc.parameters.beta * occ^2 / length(lattice(mc)))","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"where the factor mc.parameters.beta / length(lattice(mc)) comes from the imaginary time integral.","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"examples/HofmannBergChowdhury/#Reciprocal-Pairing-Susceptibility-1","page":"Topological Flat Band Model","title":"Reciprocal Pairing Susceptibility","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"The pairing susceptibility comes with three directional indices after taking mean(mc[:PS]). The first is associated with the distance r - r^prime between the two pairing operators Delta(r) in langle Delta^alpha(r) Delta^beta(r^prime) rangle. The second and third are displacements inside them. Since we only care about s-wave pairing the internal displacements are zero or index 1. Thus we plot 1 / real(sum(mean(mc[:PS])[:, 1, 1])) against 1 / mc.parameters.beta for the reciprocal pairing susceptibility. ","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"examples/HofmannBergChowdhury/#Superfluid-Stiffness-2","page":"Topological Flat Band Model","title":"Superfluid Stiffness","text":"","category":"section"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"To compute the superfluid stiffness we make use of the relevant functions from MonteCarloAnalysis.jl. It is given by:","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"using MonteCarloAnalysis\n\n# The diamagnetic contribution follows from the greens function. We set the \n# direction of the current response to x = [1, 0] like the reference paper.\nK_x = dia_K(mc, :G, [1, 0])\n\n# The paramagnetic contribution is calculated in full, i.e. Λxx(q) from the \n# CCS measurement.\nΛxx = cached_para_ccc(mc, :CCS, [1,0])\n\n# Following the paper the superfluid stiffness becomes\nSFS = 0.25 * (-K_x - Λxx[1, 1])","category":"page"},{"location":"examples/HofmannBergChowdhury/#","page":"Topological Flat Band Model","title":"Topological Flat Band Model","text":"(Image: )","category":"page"},{"location":"legacy/lattices/#Lattices-1","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"The package ships with a couple of standard lattices","category":"page"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"Type Description\nMonteCarlo.Chain 1-dimensional chain\nMonteCarlo.SquareLattice 2-dimensional square lattice\nMonteCarlo.CubicLattice D-dimensional cubic lattice","category":"page"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"It also provides routines to load the following common lattice formats","category":"page"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"Type Description\nMonteCarlo.ALPSLattice ALPS simple lattice graph (XML file)","category":"page"},{"location":"legacy/lattices/#Didn't-find-your-desired-lattice?-1","page":"Lattices","title":"Didn't find your desired lattice?","text":"","category":"section"},{"location":"legacy/lattices/#","page":"Lattices","title":"Lattices","text":"Just implement your own lattice for later use in a model of choice. See Custom lattices.","category":"page"},{"location":"legacy/customize/#Customize-1","page":"Customize","title":"Customize","text":"","category":"section"},{"location":"legacy/customize/#Custom-models-1","page":"Customize","title":"Custom models","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Although MonteCarlo.jl already ships with famous models, foremost the Ising and Hubbard models, the central idea of the design of the package is to have a (rather) well defined interface between models and Monte Carlo flavors. This way it should be easy for you to extend the package and implement your own physical model (or variations of existing models). You can find the interfaces in the corresponding section of the documentation, for example: Interface: Monte Carlo (MC).","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Sometimes examples tell the most, so feel encouraged to have a look at the implementations of the above mentioned models to get a feeling of how to implement your own model.","category":"page"},{"location":"legacy/customize/#General-remarks-for-lattice-models-1","page":"Customize","title":"General remarks for lattice models","text":"","category":"section"},{"location":"legacy/customize/#Semantics-1","page":"Customize","title":"Semantics","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"For lattice models, we define a Model to be a Hamiltonian on a lattice. Therefore, the lattice is part of the model (and not the Monte Carlo flavor). The motivation for this modeling is that the physics of a system does not only depend on the Hamiltonian but also (sometime drastically) on the underlying lattice. This is for example very obvious for spin systems which due to the lattice might become (geometrically) frustrated and show spin liquids physics. Also, from a technical point of view, lattice information is almost exclusively processed in energy calculations which both relate to the Hamiltonian (and therefore the model).","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"note: Note\nWe will generally use the terminology Hamiltonian, energy and so on. However, this doesn't restrict you from defining your model as an Lagrangian with an action in any way as this just corresponds to a one-to-one mapping of interpretations.","category":"page"},{"location":"legacy/customize/#Lattice-requirements-1","page":"Customize","title":"Lattice requirements","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"The Hamiltonian of your model might impose some requirements on the AbstractLattice object that you use as it must provide you with enough lattice information.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"It might be educating to look at the structure of the simple SquareLattice struct.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"mutable struct SquareLattice <: AbstractCubicLattice\n   L::Int\n   sites::Int\n   neighs::Matrix{Int} # row = up, right, down, left; col = siteidx\n   neighs_cartesian::Array{Int, 3} # row (1) = up, right, down, left; cols (2,3) = cartesian siteidx\n   sql::Matrix{Int}\n   SquareLattice() = new()\nend","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"It only provides access to next nearest neighbors through the arrays neighs and neighs_cartesian. If your model's Hamiltonian requires higher order neighbor information, because of, let's say, a next next nearest neighbor hopping term, the SquareLattice doesn't suffice. You could either extend this lattice or implement a NNSquareLattice for example.","category":"page"},{"location":"legacy/customize/#Custom-lattices-1","page":"Customize","title":"Custom lattices","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"As described in Custom models a lattice is considered to be part of a model. Hence, most of the requirements for fields of a AbstractLattice subtype come from potential models (see Lattice requirements). Below you'll find information on which fields are mandatory from a Monte Carlo flavor point of view.","category":"page"},{"location":"legacy/customize/#Mandatory-fields-1","page":"Customize","title":"Mandatory fields","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Any concrete lattice type, let's call it MyLattice in the following, must be a subtype of the abstract type MonteCarlo.AbstractLattice. To work with a Monte Carlo flavor, it must internally have at least have the following field,","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"sites: number of lattice sites.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"However, as already mentioned above depending on the physical model of interest it will typically also have (at least) something like","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"neighs: next nearest neighbors,","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"as most Hamiltonian will need next nearest neighbor information.","category":"page"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"The only reason why such a field isn't generally mandatory is that the Monte Carlo routine doesn't care about the lattice much. Neighbor information is usually only used in the energy (difference) calculation of a particular configuration like done in energy or propose_local which both belong to a Model.","category":"page"},{"location":"legacy/customize/#Custom-Monte-Carlo-flavors-1","page":"Customize","title":"Custom Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/customize/#","page":"Customize","title":"Customize","text":"Coming soon...","category":"page"},{"location":"legacy/interfaces/DQMC/#Interface:-Determinant-Quantum-Monte-Carlo-(DQMC)-1","page":"DQMC","title":"Interface: Determinant Quantum Monte Carlo (DQMC)","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Any model that wants to be simulated by means of DQMC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the determinant Monte Carlo flavor Determinant Quantum Monte Carlo (DQMC).","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Example models: Attractive Hubbard Model","category":"page"},{"location":"legacy/interfaces/DQMC/#Mandatory-fields-1","page":"DQMC","title":"Mandatory fields","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"l::AbstractLattice: any AbstractLattice\nflv::Int: number of distinct fermion flavors (e.g. spins, bands, etc.). The Green's function will have shape (flv*N, flv*N), where N is the number of sites. Note that different fermion flavors are often related by symmetry and it's advisable to use this symmetry to work with smaller Green's function matrices. Have a look at the Attractive Hubbard Model as an example where flv=1 although it has spinful fermions.","category":"page"},{"location":"legacy/interfaces/DQMC/#Index-of-all-methods-1","page":"DQMC","title":"Index of all methods","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Pages = [\"DQMC.md\"]","category":"page"},{"location":"legacy/interfaces/DQMC/#Mandatory-methods-1","page":"DQMC","title":"Mandatory methods","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"CurrentModule = MonteCarlo","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"conftype(::Type{DQMC}, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"rand(::DQMC, ::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"hopping_matrix(mc::DQMC, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"interaction_matrix_exp!(mc::DQMC, m::Model, result::Matrix, conf, slice::Int, power::Float64=1.)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.interaction_matrix_exp!","page":"DQMC","title":"MonteCarlo.interaction_matrix_exp!","text":"interaction_matrix_exp!(\n    mc::DQMC, m::Model, field::AbstractField, \n    result::AbstractArray, slice::Int, power::Float64 = 1.0\n)\n\nCalculate the, exponentiated interaction matrix  exp(- power * delta_tau * V(slice)) and store it in result::AbstractArray. \n\nThis only includes terms with 4 operators, i.e. not the chemical potential or  any hoppings. By default the calculation will be performed by the appropriate  field type (i.e. by interaction_matrix_exp!(field, result, slice, power))\n\nBy default this function will call  interaction_matrix_exp!(field, result, slice, power).\n\nThis is a performance critical method and one might consider efficient in-place  (in result) construction.\n\n\n\n\n\n","category":"function"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"propose_local(mc::DQMC, m::Model, i::Int, conf, E_boson::Float64)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.propose_local-Tuple{DQMC, Model, Int64, Any, Float64}","page":"DQMC","title":"MonteCarlo.propose_local","text":"propose_local(mc::DQMC, m::Model, field::AbstractField, i::Int, slice::Int)\n\nPropose a local move for lattice site i at time slice slice for a field  holding the current configuration. Returns the Green's function determinant  ratio, the boson energy difference ΔE_boson = E_boson_new - E_boson, and any extra information passthrough that might be useful in accept_local.\n\nBy default this function will call propose_local(mc, field, i, slice).\n\nSee also accept_local!.\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"accept_local(mc::DQMC, m::Model, i::Int, slice::Int, conf, delta, detratio, delta_E_boson)","category":"page"},{"location":"legacy/interfaces/DQMC/#Optional-methods-1","page":"DQMC","title":"Optional methods","text":"","category":"section"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"greenseltype(::Type{DQMC}, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"energy_boson(mc::DQMC, m::Model, conf)","category":"page"},{"location":"legacy/interfaces/DQMC/#MonteCarlo.energy_boson-Tuple{DQMC, Model, Any}","page":"DQMC","title":"MonteCarlo.energy_boson","text":"energy_boson(mc::DQMC, model::Model, conf)\n\nCalculate bosonic part (non-Green's function determinant part) of energy for  configuration conf for Model m.\n\nThis is required for global and parallel updates as well as boson energy  measurements, but not for local updates. By default calls  energy_boson(field(mc), conf)\n\n\n\n\n\n","category":"method"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"prepare_observables(mc::DQMC, m::Model)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"measure_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable}, conf)","category":"page"},{"location":"legacy/interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"finish_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable})","category":"page"},{"location":"legacy/flavors/mc/#Monte-Carlo-(MC)-1","page":"MC","title":"Monte Carlo (MC)","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"This is plain simple Monte Carlo (MC). It can for example be used to simulate the Ising model (see 2D Ising model).","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"You can initialize a Monte Carlo simulation of a given model simply through","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"mc = MC(model)","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Allowed keywords are:","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"beta: inverse temperature\nsweeps: number of measurement sweeps\nthermalization: number of thermalization (warmup) sweeps\nglobal_moves: wether global moves should be proposed\nglobal_rate: frequency for proposing global moves\nseed: initialize MC with custom seed","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Afterwards, you can run the simulation by","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"run!(mc)","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Note that you can just do another run!(mc, sweeps=1000) to continue the simulation.","category":"page"},{"location":"legacy/flavors/mc/#Examples-1","page":"MC","title":"Examples","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model.","category":"page"},{"location":"legacy/flavors/mc/#Exports-1","page":"MC","title":"Exports","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"MC.jl\"]","category":"page"},{"location":"legacy/flavors/mc/#MonteCarlo.replay!","page":"MC","title":"MonteCarlo.replay!","text":"replay(mc::MC[, configurations::Iterable = mc.configs; kwargs...])\n\nReplays previously generated configurations and measures observables along the way.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, replay! will generate a\n\nresumable save file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nfilename: Name of the save file. The default is based on safe_before.\nmeasure_rate = 1: Rate at which measurements are taken. Note that this is \n\nbased on the recorded configurations, not actual sweeps.\n\n\n\n\n\n","category":"function"},{"location":"legacy/flavors/mc/#MonteCarlo.run!-Tuple{MC}","page":"MC","title":"MonteCarlo.run!","text":"run!(mc::MC[; kwargs...])\n\nRuns the given Monte Carlo simulation mc. Returns SUCCESS::ExitCode = 0 if  the simulation finished normally or various other codes if failed or cancelled.  See ExitCode.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nthermalization: Number of thermalization sweeps. Uses the value passed to\n\nDQMC by default.\n\nsweeps: Number of measurement sweeps. Uses the value passed to DQMC by\n\ndefault.\n\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, run! will generate a resumable\n\nsave file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nresumable_filename: Name of the resumable save file. The default is based on\n\nsafe_before.\n\noverwrite = false: If set to true a file with the same name as\n\nresumable_filename will be overwritten. (This will create a temporary backup)\n\nSee also: resume!\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/mc/#MonteCarlo.MC","page":"MC","title":"MonteCarlo.MC","text":"Monte Carlo simulation\n\n\n\n\n\n","category":"type"},{"location":"legacy/flavors/mc/#MonteCarlo.MC-Tuple{M} where M<:Model","page":"MC","title":"MonteCarlo.MC","text":"MC(m::M; kwargs...) where M<:Model\n\nCreate a Monte Carlo simulation for model m with keyword parameters kwargs.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/mc/#MonteCarlo.MC-Union{Tuple{T}, Tuple{Model, Dict{Symbol, T}}} where T","page":"MC","title":"MonteCarlo.MC","text":"MC(m::M, params::Dict)\nMC(m::M, params::NamedTuple)\n\nCreate a Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"legacy/flavors/mc/#Potential-extensions-1","page":"MC","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/flavors/mc/#","page":"MC","title":"MC","text":"Heat bath (instead of Metropolis) option","category":"page"},{"location":"DQMC/lattice/#Lattices-1","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"A lattice as we implement it describes a collection of sites in space, connected by bonds.","category":"page"},{"location":"DQMC/lattice/#Interface-1","page":"Lattices","title":"Interface","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"There are a few functions defined for lattices which you may find useful. ","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"position(lattice) returns an iterator which produces all site position of the lattice. When collected, this will create a D+1 dimensional array for a D dimensional lattice, where the first index represents the basis and the following represent the extend along the different lattice vectors.\nbonds(lattice[, directed = Val(false)]) returns an iterator which produces all bonds of the lattice. If directed = Val(false) bonds will be assumed to be directionless, meaning that only one of 1 to 2 and 2 to 1 will be returned. If directed = Val(true) both bonds will be generated.\nbond_open(lattice[, directed = false) returns an iterator which filters out periodic bonds which might be useful for plotting.\nbonds(lattice, site::Int) returns an iterator which produces bonds starting from site.\nlattice_vectors(lattice) returns the lattice vectors of the lattice. (These are the vectors v_i in R = v_1 i_1 + v_2 i_2 + v_3 i_3, i.e.e the vectors that generate the periodic Bravais lattice.)\nreciprocal_vectors(lattice) returns the Fourier transformed lattice vectors.\nlength(lattice) returns the total number of sites in the lattice.\nsize(lattice) returns the size of the lattice starting with the number of basis sites. \neachindex(lattice) returns a 1:length(lattice)\nBravais(lattice) returns a wrapped lattice for which the above methods ignore the basis. For example positions(Bravais(lattice)) will return an iterator of all Bravais lattice positions.","category":"page"},{"location":"DQMC/lattice/#Implementing-your-own-lattice-1","page":"Lattices","title":"Implementing your own lattice","text":"","category":"section"},{"location":"DQMC/lattice/#LatticePhysics.jl-1","page":"Lattices","title":"LatticePhysics.jl","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"LatticePhysics.jl already has a lot of common lattices implemented, which can be converted to MonteCarlo.jl lattices. For this you simple need to call MonteCarlo.Lattice(lattice_physics_lattice). Note that the reverse is also implemented as LatPhysBase.Lattice(mc_lattice).","category":"page"},{"location":"DQMC/lattice/#MonteCarlo.jl-1","page":"Lattices","title":"MonteCarlo.jl","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"If neither MonteCarlo.jl nor LatticePhysics.jl implements the lattice you need, you can implement your own through a custom constructor. This process is very similar between both libraries. Let us take the implementation for the Honeycomb lattice as an example:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"function Honeycomb(Lx, Ly = Lx)\n    uc = UnitCell(\n        # Name\n        \"Honeycomb\",\n        # lattice vectors\n        (Float64[sqrt(3.0)/2, -0.5], Float64[sqrt(3.0)/2, +0.5]),\n        # basis\n        [Float64[0.0, 0.0], Float64[1/sqrt(3.0), 0.0]],\n        # bonds\n        [\n            Bond(1, 2, (0, 0)), Bond(1, 2, (-1, 0)), Bond(1, 2, (0, -1)),\n            Bond(2, 1, (0, 0)), Bond(2, 1, ( 1, 0)), Bond(2, 1, (0,  1)),\n        ]\n    )\n\n    return Lattice(uc, (Lx, Ly))\nend","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"As you can see the main task here is to create a fitting unit cell. In order, the unit cell constructors takes the following arguments.","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"The name of the lattice. This is used for printing and might be useful if you wish to restrict a model to a specific lattice.\nThe basis of the lattice. (The positions of sites within a unit cell.)\nThe lattice vectors, i.e. the vectors that generate the periodic Bravais lattice.\nThe bonds of the lattice. Each bond contains three values: The basis site the bond starts at, the basis site it ends at and the Bravais shift which allows a bond to connect to neighboring unit cell. ","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Note that bonds also have an integer label which can be used to differentiate them later. Note as well that the UnitCell constructor will generate missing bonds b to a if a to b exists.","category":"page"},{"location":"DQMC/lattice/#Lattice-Iterators-1","page":"Lattices","title":"Lattice Iterators","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Lattice Iterators are to some degree a backend component. They specify a way to iterate through the lattice, and are mainly used for DQMC measurements which frequently require specific pairings of sites. The iterators fall into three categories:","category":"page"},{"location":"DQMC/lattice/#DirectLatticeIterator-1","page":"Lattices","title":"DirectLatticeIterator`","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"First we have DirectLatticeIterator. These iterators return just site indices, e.g. (source_index, target_index). The concrete implementations include:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"EachSiteAndFlavor iterates all indices from 1 to length(lattice) * nflavors(mc)\nEachSite iterates through eachindex(lattice)\nEachSitePair iterates through all possible pairs (i, j) where both i and j iterate eachindex(lattice).","category":"page"},{"location":"DQMC/lattice/#DeferredLatticeIterator-1","page":"Lattices","title":"DeferredLatticeIterator","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"The second category inherit from DeferredLatticeIterator. Iterators in this category produce two sets of indices, one which is used to access lattice sites and one which is used to access some output array. In this category we have:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"OnSite which also eachindex(lattice), but returns three indices (i, i, i) at each step.\nEachSitePairByDistance which iterates the same range as EachSitePair but returns (combined_idx, i, j) at each step. The combined_idx combines the index of source basis site, the target basis and an index corresponding to a Bravais lattice direction. The output array is generally assumed to be three dimensional, matching those indices.\nEachLocalQuadByDistance(directions) iterators through combinations of four sites s^prime leftarrow s rightarrow t rightarrow t^prime. The given directions are directional indices used to derive s^prime and t^prime from the current source and target site s and t. The full output of this iterator is (combined_idx, s, t, s', t'), where combined_idx includes the basis index of s, t, the direction s to t as well as the indices into directions for s to s^prime and t to t^prime.\nEachLocalQuadBySyncedDistance(directions) is the same as EachLocalQuadByDistance with the restriction that the directions s to s^prime and t to t^prime are the same. The combined_idx does contain an index t to t^prime as result.","category":"page"},{"location":"DQMC/lattice/#Wrappers-1","page":"Lattices","title":"Wrappers","text":"","category":"section"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"The last category are wrappers around lattice iterators. They are used either to adjust the summation and further compress the output array, or to dispatch to different methods during measurement. The following are currently available:","category":"page"},{"location":"DQMC/lattice/#","page":"Lattices","title":"Lattices","text":"Sum(iter) sets the output index to 1. This has the effect of summing all site combinations.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"(Image: logo)","category":"page"},{"location":"legacy/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is a Julia software library for the simulation of physical models by means of the Markov Chain Monte Carlo technique. The package implements classical and quantum Monte Carlo flavors which can be used to study spin systems, interacting fermions, and boson-fermion mixtures.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe documentation is out-of-date!","category":"page"},{"location":"legacy/#Included-models:-1","page":"Introduction","title":"Included models:","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Ising model\nAttractive Hubbard model","category":"page"},{"location":"legacy/#Included-Monte-Carlo-flavors-1","page":"Introduction","title":"Included Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Classical Monte Carlo\nDeterminant Quantum Monte Carlo (also known as auxiliary field Monte Carlo)","category":"page"},{"location":"legacy/#Included-lattices-1","page":"Introduction","title":"Included lattices","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Cubic lattices (chain, square, cube, ...)\nAny ALPS lattice","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"Have a look at the Showcase section to get some inspiration.","category":"page"},{"location":"legacy/#Study-your-own-model-1","page":"Introduction","title":"Study your own model","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"A major idea behind the design of the package is convenient customization. Users should be able to define their own custom physical models (or extend existing ones) and explore their physics through Monte Carlo simulations. We hope that MonteCarlo.jl allows the user to put his focus on his physical model rather than tedious implementations of Monte Carlo schemes.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"To that end, each (quantum) Monte Carlo flavor has a well-defined model interfaces, i.e. a precise specification of mandatory and optional fields and methods. An example can be found here: Interface: Monte Carlo (MC). Practically, it makes sense to start by taking a look at the implementation of one of the predefined models.","category":"page"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"If you implement a custom model that might be worth being added to the collection of supplied models, please consider creating a pull request!","category":"page"},{"location":"legacy/#GitHub-1","page":"Introduction","title":"GitHub","text":"","category":"section"},{"location":"legacy/#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is open-source. The source code can be found on github. Criticism and contributions are very much welcome - just open an issue. For more details see the Contribution Guide.","category":"page"},{"location":"legacy/models/ising/#Ising-Model-1","page":"Ising model","title":"Ising Model","text":"","category":"section"},{"location":"legacy/models/ising/#Hamiltonian-1","page":"Ising model","title":"Hamiltonian","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"The famous Hamiltonian of the Ising model is given by","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"\\begin{align} \\mathcal{H} = -\\sum{\\langle i,j \\rangle} \\sigmai \\sigma_j , \\end{align}","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"where langle i j rangle indicates that the sum has to be taken over nearest neighbors.","category":"page"},{"location":"legacy/models/ising/#Creating-an-Ising-model-1","page":"Ising model","title":"Creating an Ising model","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"You can create an Ising model as follows,","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"model = IsingModel(; dims::Int=2, L::Int=8)","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"The following parameters can be set via keyword arguments:","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"dims: dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)\nL: linear system size","category":"page"},{"location":"legacy/models/ising/#Supported-Monte-Carlo-flavors-1","page":"Ising model","title":"Supported Monte Carlo flavors","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Monte Carlo (MC) (Have a look at the examples section below)","category":"page"},{"location":"legacy/models/ising/#Examples-1","page":"Ising model","title":"Examples","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model.","category":"page"},{"location":"legacy/models/ising/#Exports-1","page":"Ising model","title":"Exports","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"IsingModel.jl\"]","category":"page"},{"location":"legacy/models/ising/#MonteCarlo.IsingModel","page":"Ising model","title":"MonteCarlo.IsingModel","text":"Famous Ising model on a cubic lattice.\n\nIsingModel(; dims, L)\n\nCreate Ising model on dims-dimensional cubic lattice with linear system size L.\n\n\n\n\n\n","category":"type"},{"location":"legacy/models/ising/#MonteCarlo.IsingModel-Union{Tuple{Dict{Symbol, T}}, Tuple{T}} where T","page":"Ising model","title":"MonteCarlo.IsingModel","text":"IsingModel(params::Dict)\nIsingModel(params::NamedTuple)\n\nCreate an Ising model with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"legacy/models/ising/#Analytic-results-1","page":"Ising model","title":"Analytic results","text":"","category":"section"},{"location":"legacy/models/ising/#Square-lattice-(2D)-1","page":"Ising model","title":"Square lattice (2D)","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"The model can be solved exactly by transfer matrix method (Onsager solution). This gives the following results.","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Critical temperature: T_c = frac2ln1+sqrt2","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Magnetization (per site): m = left(1-leftsinh 2beta right^-4right)^frac 18","category":"page"},{"location":"legacy/models/ising/#Potential-extensions-1","page":"Ising model","title":"Potential extensions","text":"","category":"section"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Pull requests are very much welcome!","category":"page"},{"location":"legacy/models/ising/#","page":"Ising model","title":"Ising model","text":"Arbitrary dimensions\nMagnetic field\nMaybe explicit J instead of implicit J=1\nNon-cubic lattices (just add lattice::AbstractLattice keyword)","category":"page"},{"location":"examples/ALF1/#Crosscheck-with-ALF-1","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The ALF project (Algorithms for lattice fermions) is a long running project implementing DQMC in Fortran. They have implemented various different models, lattices, stabilization methods and measurements. A relatively simple comparison for us will be the \"plain vanilla Hubbard model\" on a square lattice, which is close to but not exactly the same as our repulsive Hubbard model.","category":"page"},{"location":"examples/ALF1/#The-ALF-Simulation-1","page":"Crosscheck with ALF","title":"The ALF Simulation","text":"","category":"section"},{"location":"examples/ALF1/#Installation-1","page":"Crosscheck with ALF","title":"Installation","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The ALF project provides a python interface which we used for simplicity. For installation instructions see the link. At the time of writing pyALF is linked to ALF 2.0. (Specifically commit 82949f66065eff8214c0149c8be2d10d6d0a6822.)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"note: Note\nYou can also add a load path for pyALF temporarily in an active python session. Try import sys and sys.path.append('path/to/pyALF-ALF-2.0/').","category":"page"},{"location":"examples/ALF1/#Usage-1","page":"Crosscheck with ALF","title":"Usage","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"With python, pyALF and the necessary packages installed we can now setup and run simulations. In python, we run:","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"import os\nfrom py_alf import Simulation        # Interface with ALF\n\nsims = []                            # Vector of Simulation instances\nfor beta in [1.0, 6.0, 12.0]:        # Values of inverse temperature beta\n    sim = Simulation(\n        'Hubbard',                   # Hamiltonian\n        {                            # Model and simulation parameters for each Simulation instance\n        'Model': 'Hubbard',          #    Base model\n        'Lattice_type': 'Square',    #    Lattice type\n        'L1': 4,                     #    Lattice length in the first unit vector direction\n        'L2': 4,                     #    Lattice length in the second unit vector direction\n        'Checkerboard': False,       #    Whether checkerboard decomposition is used or not\n        'Symm': True,                #    Whether symmetrization takes place\n        'ham_T': 1.0,                #    Hopping parameter\n        'ham_U': 4.0,                #    Hubbard interaction\n        'ham_Tperp': 0.0,            #    For bilayer systems\n        'beta': beta,                #    Inverse temperature\n        'Ltau': 1,                   #    '1' for time-displaced Green functions; '0' otherwise \n        'NSweep': 100,                #    Number of sweeps per bin\n        'N_skip': 10,                #    skip 50 bins meaning 50x NSweep\n        'NBin': 60,                 #    Number of bins\n        'Dtau': 0.1,                 #    Only dtau varies between simulations, Ltrot=beta/Dtau\n        'Mz': True,                  #    If true, sets the M_z-Hubbard model: Nf=2, N_sum=1,\n        },                           #             HS field couples to z-component of magnetization\n        alf_dir=os.getenv('ALF_DIR', './ALF'), # Directory with ALF source code. Gets it from \n                                               # environment variable ALF_DIR, if present\n    )\n    sims.append(sim)\n\nsims[0].compile()                        # Compilation needs to be performed only once\n\nimport time\n\nprint(\"\\nRunning sims\\n\")\nfor i, sim in enumerate(sims):\n    t0 = time.time()\n    sim.run()                            # Perform the actual simulation in ALF\n    print(time.time() - t0)\n    \nprint(\"\\nAnalysis:\\n\")\nfor i, sim in enumerate(sims):\n    print(sim.sim_dir)                   # Directory containing the simulation output\n    sim.analysis()","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Let's briefly go over some of the options picked here. One noteworthy option is Symm. With it you can switch between a symmetric (True) and antisymmetric (False) Trotter decomposition. In MonteCarlo.jl we use the symmetric version so we should do so here too. Next we have Ltau. As mentioned in the comment this controls whether time displaced greens function are calculated, and by extension whether time displaced observables (susceptibilties) are calculated. We want to compare as much as possible so we set Ltau = 1. ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"And finally we have the combination of NSweep, N_skip and NBin. NSweep is the number of sweeps in a block, which is usually followed by a measurement. NBin sets how many of those blocks are executed and N_skip disables measurements for some number of blocks at the start. Thus we have the relations thermalization = NSweep * N_skip, sweeps = NSweep * (NBin - N_skip) and measure_rate = NSweep. ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Regarding the choices for NSweep, N_skip and NBin it is also important to discuss the model ALF implements and how it is implemented. As mentioned before it is not quite the same as the repulsive Hubbard model from DQMC. ALF implements","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"mathcalH=\n- t sumlimits_langle i j rangle  sigma=uparrowdownarrow \nleft(  hatc^dagger_i sigma hatc^phantomdagger_jsigma  + textHc right) \n- fracU2sumlimits_ileft\nhatc^dagger_i uparrow hatc^phantomdagger_i uparrow  -   hatc^dagger_i downarrow hatc^phantomdagger_i downarrow  right^2   \n-  mu sum_isigma  hatc^dagger_i sigma  hatc^phantomdagger_isigma ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"which features a quadratic interaction rather than the sim (n_uparrow - 05)(n_downarrow - 05) term used in MonteCarlo.jl. If we apply a Hirsch transformation (like in MonteCarlo.jl) to both of these interactions, we end up with the same expression. Thus they would be the same from the simulations point of view. However ALF uses a different, (potentially) more precise transformation based on Gauß-Hermite quadrature. Thus some small differences are to be expected.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"For more information on the Hamiltonian and transformation used by ALF see the ALF documentation","category":"page"},{"location":"examples/ALF1/#The-MonteCarlo.jl-Simulation-1","page":"Crosscheck with ALF","title":"The MonteCarlo.jl Simulation","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The MonteCarlo.jl simulation should more or less mirror the options picked for ALF. We run ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"using Revise, MonteCarlo, Printf, LinearAlgebra\n\nmcs = []\n@time for beta in [1.0, 6.0, 12.0]\n    m = HubbardModel(4, 2, U = -4.0)\n    # There are propagation errors on the scale of 10^-7 - 10^-6 which produce\n    # frequent warnings without silent = true\n    mc = DQMC(\n        m, beta=beta, thermalization=5_000, sweeps=15_000, \n        print_rate=5_000, delta_tau = 0.1, measure_rate=1,\n        field = MagneticGHQField, safe_mult = 10, silent = true\n    )\n    \n    # our default versions\n    mc[:G] = greens_measurement(mc, m)\n    mc[:SDCz] = spin_density_correlation(mc, m, :z)\n    mc[:SDSz] = spin_density_susceptibility(mc, m, :z)\n    mc[:T] = kinetic_energy(mc, m)\n    # charge density correlations in ALF only consider the correlated part\n    mc[:DenDen] = charge_density_correlation(mc, m, kernel = MonteCarlo.reduced_cdc_kernel)\n    mc[:DenDenTau] = charge_density_susceptibility(mc, m, kernel = MonteCarlo.reduced_cdc_kernel)\n\n    # ALF defines our I - G as the measured Greens function\n    function mygreens(mc, m, ij, G, flv)\n        i, j = ij\n        return I[i, j] - G.val.blocks[flv][j, i]\n    end\n    mc[:Gr] = MonteCarlo.Measurement(\n        mc, m, Greens(), EachSitePairByDistance(), 1:2, mygreens\n    )\n    \n    # The interaction energy needs to be adjusted to ALF's Hamiltonian\n    function my_intE(mc, m, idxs, G, flv)\n        E = 0.0; N = length(lattice(mc))\n        Gup, Gdown = G.val.blocks\n        for i in 1:N\n            E += (1 - Gup[i, i]) * (1 - Gdown[i, i])\n        end\n        m.U * E\n    end\n    mc[:V] = MonteCarlo.Measurement(mc, m, Greens(), nothing, nothing, my_intE)\n    \n    function myGk(mc, m, ij, Gs, flv)\n        G00, G0l, Gl0, Gll = Gs; \n        i, j = ij\n        0.5 * Gl0.val.blocks[flv][i, j]\n    end\n    mc[:IGk] = MonteCarlo.Measurement(\n        mc, m, TimeIntegral(mc), EachSitePairByDistance(), 1:2, myGk\n    )\n    \n    run!(mc)\n    push!(mcs, mc)\nend","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"With the given parameters the simulations will take about 6min. This can be reduced further by cutting down on the number of sweeps or the measure_rate at the cost of accuracy.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"A few observables we measure have been adjusted to match ALF. First we have the real space equal time Greens function :Gr which measures delta(Delta r) - G(Delta r) = sum_r c_r^dagger c_r + Delta r. The MonteCarlo.jl Greens function is given as c c^dagger, so we need to swap the operator order. This can be done with swapop(G)[i + (flv-1)*N, j + (flv-1)*N] or more efficiently with I[i, j] - G.val.blocks[flv][j, i]. The former works for any matrix type, but calls slow custom indexing. The latter is specialized for BlockDiagonal matrices, which we have in this case. flv represents the spin index which results in a shift by N (number of sites) in the first case and access to the second block in the latter.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Next we have the interaction energy :V which needs adjustments to the different pre-transformation term ALF uses. We calculate langle V rangle = fracU2 sum_i langle V_i rangle where ","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"langle V_i rangle = langle\nhatc^dagger_i uparrow hatc^phantomdagger_i uparrow hatc^dagger_i uparrow hatc^phantomdagger_i uparrow\n- hatc^dagger_i uparrow hatc^phantomdagger_i uparrow hatc^dagger_i downarrow hatc^phantomdagger_i downarrow\n- hatc^dagger_i downarrow hatc^phantomdagger_i downarrow hatc^dagger_i uparrow hatc^phantomdagger_i uparrow\n+ hatc^dagger_i downarrow hatc^phantomdagger_i downarrow hatc^dagger_i downarrow hatc^phantomdagger_i downarrow\nrangle","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Each term needs to be Wicks-expanded","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nlangle V_i rangle = phantom- \nlangle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle langle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle\n+ langle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle langle hatc^phantomdagger_i uparrow hatc^dagger_i uparrow rangle\n- langle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle\n- langle hatc^dagger_i uparrow hatc^phantomdagger_i downarrow rangle langle hatc^phantomdagger_i uparrow hatc^dagger_i downarrow rangle \n- langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle langle hatc^dagger_i uparrow hatc^phantomdagger_i uparrow rangle\n- langle hatc^dagger_i downarrow hatc^phantomdagger_i uparrow rangle langle hatc^phantomdagger_i downarrow hatc^dagger_i uparrow rangle\n+ langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle\n+ langle hatc^dagger_i downarrow hatc^phantomdagger_i downarrow rangle langle hatc^phantomdagger_i downarrow hatc^dagger_i downarrow  rangle\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"so it can be exchanged by Greens function elements","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nlangle V_i rangle = phantom-\n  (I - G_ii^uparrow uparrow) (I - G_ii^uparrow uparrow)\n+ (I - G_ii^uparrow uparrow) G_ii^uparrow uparrow\n- (I - G_ii^uparrow uparrow) (I - G_ii^downarrow downarrow)\n- (I - G_ii^downarrow uparrow) G_ii^uparrow downarrow \n- (I - G_ii^downarrow downarrow) (I - G_ii^uparrow uparrow)\n- (I - G_ii^uparrow downarrow) G_ii^downarrow uparrow\n+ (I - G_ii^downarrow downarrow) (I - G_ii^downarrow downarrow)\n+ (I - G_ii^downarrow downarrow) G_ii^downarrow downarrow\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Next we make use of the symmetries of the model. Specifically that we do not have mixed spin terms, i.e. G_ij^sigma sigma^prime = 0 if sigma ne sigma^prime. We can also replace I by 1 in the remaining cases as both spin and site index are equal. We get","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nlangle V_i rangle = phantom-\n  (1 - G_ii^uparrow uparrow) (1 - G_ii^uparrow uparrow)\n+ (1 - G_ii^uparrow uparrow) G_ii^uparrow uparrow\n- (1 - G_ii^uparrow uparrow) (1 - G_ii^downarrow downarrow) \n- (1 - G_ii^downarrow downarrow) (1 - G_ii^uparrow uparrow)\n+ (1 - G_ii^downarrow downarrow) (1 - G_ii^downarrow downarrow)\n+ (1 - G_ii^downarrow downarrow) G_ii^downarrow downarrow\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"which we simplify further by using x = 1 - (1 - x).","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nlangle V_i rangle = \n(1 - G_ii^uparrow uparrow) + (1 - G_ii^downarrow downarrow) \n- 2 (1 - G_ii^uparrow uparrow) (1 - G_ii^downarrow downarrow) \n= G_ii^uparrow uparrow + G_ii^downarrow downarrow\n- 2 G_ii^uparrow uparrow G_ii^downarrow downarrow\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"This is however not what ALF implements as the potential energy. Instead of the above, ALF uses","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"beginaligned\nfrac12 langle V_i rangle = (1 - G_ii^uparrow uparrow) (1 - G_ii^downarrow downarrow) \n= 1 - G_ii^uparrow uparrow - G_ii^downarrow downarrow\n+ G_ii^uparrow uparrow G_ii^downarrow downarrow\nendaligned","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"which is implemented above. Finally that we have the Fourier transformed time displaced Greens function :IGk which calculates the Fourier transform of G^prime(Delta r) = int_0^beta sum_r c_r(tau) c_r + Delta r^dagger(0) dtau. ","category":"page"},{"location":"examples/ALF1/#Loading-ALF-Data-1","page":"Crosscheck with ALF","title":"Loading ALF Data","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"ALF will generate a folder with multiple files for each measurement. You should find these in your pyALF directory under ALF_data. To load everything you need to compare results we run","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"using Statistics\np = \"path/to/ALF_data\"\nfolders = [\n    \"Hubbard_Square_L1=4_L2=4_Checkerboard=False_Symm=True_T=1.0_U=4.0_Tperp=0.0_beta=1.0_Dtau=0.1_Mz=True\",\n    \"Hubbard_Square_L1=4_L2=4_Checkerboard=False_Symm=True_T=1.0_U=4.0_Tperp=0.0_beta=6.0_Dtau=0.1_Mz=True\",\n    \"Hubbard_Square_L1=4_L2=4_Checkerboard=False_Symm=True_T=1.0_U=4.0_Tperp=0.0_beta=12.0_Dtau=0.1_Mz=True\",\n]\n\n# equal time Greens\ndirs = []\nGs = []\ndGs = []\n\n# other equal time observables\nTs = []      # SpinT ~ 4 * (sx + sy + sz) / 3\ndTs = []\nSDCxys = []  # SpinXY ~ 2 * (sx + sy)\ndSDCxys = []\nSDCzs = []   # SpinZ ~ 4 * sz\ndSDCzs = []\nCDCs = []    # Den\ndCDCs = []\nCDCks = []    # Den\ndCDCks = []\n\n# Energies\nKs = []\ndKs = []\nVs = []\ndVs = []\nEs = []\ndEs = []\n\n# unequal time\nks = []\nGks = []\ndGks = []\nCDCts = []    # Den\ndCDCts = []\nSDSzs = []   # SpinZ ~ 4 * sz\ndSDSzs = []\n\nfunction read_scal(filename)\n    open(filename, \"r\") do f\n        data = map(eachline(f)) do line\n            parts = filter(x -> !isempty(x), split(line, r\" +\"))\n            parse(Float64, split(parts[2], ',')[1][2:end])\n        end\n        mean(data), std(data) / sqrt(length(data))\n    end\nend\n\nfunction readJR(filename)\n    open(filename, \"r\") do f\n        data = map(eachline(f)) do line\n            parse.(Float64, filter(x -> !isempty(x), split(line, r\" +\")))\n        end\n        drs = data[1:2:end]\n        ys = getindex.(data[2:2:end], 3)\n        dys = getindex.(data[2:2:end], 4)\n        drs, ys, dys\n    end\nend\n\nfunction read_tauJK(filename)\n    open(filename, \"r\") do f\n        data = map(eachline(f)) do line\n            parse.(Float64, filter(x -> !isempty(x), split(line, r\" +\")))\n        end\n        dks = [d[1:2] for d in data]\n        gs = [ComplexF64(d[3], d[5]) for d in data]\n        dgs = [ComplexF64(d[4], d[6]) for d in data]\n        dks, gs, dgs\n    end\nend\n\n\nfor folder in folders\n    drs, gs, dgs = readJR(joinpath(p, folder, \"Green_eqJR\"))\n    if isempty(dirs)\n        push!(dirs, drs)\n    else\n        @assert dirs[end] == drs\n    end\n    push!(Gs, gs)\n    push!(dGs, dgs)\n    \n    drs, cdcs, dcdcs = readJR(joinpath(p, folder, \"Den_eqJR\"))\n    @assert dirs[end] == drs\n    push!(CDCs, cdcs)\n    push!(dCDCs, dcdcs)\n     \n    drs, ts, dts = readJR(joinpath(p, folder, \"SpinT_eqJR\"))\n    @assert dirs[end] == drs\n    push!(Ts, ts)\n    push!(dTs, dts)\n    \n    drs, sdcxys, dsdcxys = readJR(joinpath(p, folder, \"SpinXY_eqJR\"))\n    @assert dirs[end] == drs\n    push!(SDCxys, sdcxys)\n    push!(dSDCxys, dsdcxys)\n    \n    drs, sdczs, dsdczs = readJR(joinpath(p, folder, \"SpinZ_eqJR\"))\n    @assert dirs[end] == drs\n    push!(SDCzs, sdczs)\n    push!(dSDCzs, dsdczs)\n    \n    dks, gks, dgks = readJR(joinpath(p, folder, \"Den_eqJK\"))\n    if isempty(ks)\n        push!(ks, dks)\n    else\n        @assert ks[end] == dks\n    end\n    push!(CDCks, gks)\n    push!(dCDCks, dgks)\n    \n    dks, gks, dgks = read_tauJK(joinpath(p, folder, \"Green_tauJK\"))\n    @assert ks[end] == dks\n    push!(Gks, gks)\n    push!(dGks, dgks)\n    \n    dks, gks, dgks = read_tauJK(joinpath(p, folder, \"Den_tauJK\"))\n    @assert ks[end] == dks\n    push!(CDCts, gks)\n    push!(dCDCts, dgks)\n        \n    dks, gks, dgks = read_tauJK(joinpath(p, folder, \"SpinZ_tauJK\"))\n    @assert ks[end] == dks\n    push!(SDSzs, gks)\n    push!(dSDSzs, dgks)\n    \n    \n    e, de = read_scal(joinpath(p, folder, \"Kin_scal\"))\n    push!(Ks, e)\n    push!(dKs, de)\n    \n    e, de = read_scal(joinpath(p, folder, \"Pot_scal\"))\n    push!(Vs, e)\n    push!(dVs, de)\n    \n    e, de = read_scal(joinpath(p, folder, \"Ener_scal\"))\n    push!(Es, e)\n    push!(dEs, de)\nend\n\nmc_drs = MonteCarlo.directions(mcs[1] |> lattice)\nidxs = map(v -> findfirst(isequal(v), dirs[1]), mc_drs)\nidxs[end-1] = 13","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The only thing worth mentioning here is the order of offset vectors Delta r. The order of observable values is linked to these vectors, whose order differs between MonteCarlo.jl and ALF. To adjust the order we compute idxs here. Note that because we work with periodic lattices there are multiple valid options for some of these vectors. Because of this we set one index explicitly. ","category":"page"},{"location":"examples/ALF1/#Comparing-the-results-1","page":"Crosscheck with ALF","title":"Comparing the results","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"To compare the results we will plot points over each other. Most observables have the same layout, i.e. values vs either spatial or reciprocal distance vectors. We will plot these with the following functions.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"using CairoMakie, LaTeXStrings, LinearAlgebra\nimport MonteCarloAnalysis # fourier transform\n\nfunction plot_by_distance(\n        ys, dys, key; \n        idxs = idxs, xs = 1:16, xticks = map(v -> \"[$(v[1]), $(v[2])]\", mc_drs), \n        ylabel, legend_pos = :rt\n    )\n\n    fig = Figure(figure_padding = (10, 20, 10, 10))\n    ax = Axis(fig[1, 1], xlabel = L\"Distance $\\Delta r$\", ylabel = ylabel)\n\n    cs = (:blue, :purple, :red)\n    for l in 1:3 # temperature index\n        band!(ax, xs, ys[l][idxs] .- dys[l][idxs], ys[l][idxs] .+ dys[l][idxs], color = (cs[l], 0.1))\n        scatter!(ax, xs, ys[l][idxs], color = cs[l], marker='+', markersize=12)\n\n        low  = real(mean(mcs[l][key]) .- try std_error(mcs[l][key]) catch e; 0.0 end)\n        high = real(mean(mcs[l][key]) .+ try std_error(mcs[l][key]) catch e; 0.0 end)\n        band!(ax, xs[:], low[:], high[:], color = (cs[l], 0.1))\n        scatter!(ax, xs, mean(mcs[l][key])[:], color = cs[l], marker='x', markersize=12)\n    end\n\n    lbls = [\n        \"β = 1\", \"β = 1\",\n        \"β = 6\", \"β = 6\",\n        \"β = 12\", \"β = 12\"\n    ]\n    axislegend(ax, ax.scene.plots[3:2:end], lbls, \"  ALF    MonteCarlo.jl\", nbanks=2, position = legend_pos)\n\n    ax.xticks[] = (xs, xticks)\n    ax.xticklabelrotation[] = -0.7\n\n    # to fix bad spacing, likely unnecessary in the near future\n    ax.xlabelpadding[] = 10\n    \n    fig, ax\nend\n\nfunction plot_reciprocal(\n        ys, dys, key; \n        xs = 1:16, ylabel, legend_pos = :rt,\n        xticks = labels = map(ks[1]) do k\n            pieces = map(k) do x\n                if x ≈ 0.5f0 * pi;       \"π/2\"\n                elseif x ≈ 1f0 * pi;     \"π\"\n                elseif x ≈ -0.5f0 * pi;  \"-π/2\"\n                elseif x ≈ 0.0;          \"0\"\n                else;                    \"$x\"\n                end\n            end\n            \"[\" * join(pieces, \", \") * \"]\"\n        end\n    )\n\n    fig = Figure(figure_padding = (10, 20, 10, 10))\n    ax = Axis(fig[1, 1], xlabel = L\"Reciprocal Vector $\\Delta k$\", ylabel = ylabel)\n\n    cs = (:blue, :purple, :red)\n    for l in 1:3 # temperature index\n        low  = real(real(ys[l]) .- real(dys[l]))\n        high = real(real(ys[l]) .+ real(dys[l]))\n        band!(ax, xs, low, high, color = (cs[l], 0.1))\n        scatter!(ax, xs, real(ys[l]), color = cs[l], marker='+', markersize=12)\n\n        _ys = let\n            m = mcs[l][key]\n            fourier(ks[1], directions(lattice(mcs[l]), m.lattice_iterator), mean(m))\n        end\n        _dys = map(1:16) do j\n            vals = std_error(mcs[l][key])[:]\n            dirs = directions(lattice(mcs[l]))\n            q = ks[1][j]\n            sum((cis(dot(q, v)) * o)^2 for (v, o) in zip(dirs, vals)) |> mean |> sqrt\n        end\n\n        low  = real(_ys .- _dys)\n        high = real(_ys .+ _dys)\n        band!(ax, xs, low, high, color = (cs[l], 0.1))\n        scatter!(ax, xs, real(_ys), color = cs[l], marker='x', markersize=12)\n    end\n\n    lbls = [\n        \"β = 1\", \"β = 1\",\n        \"β = 6\", \"β = 6\",\n        \"β = 12\", \"β = 12\"\n    ]\n    axislegend(ax, ax.scene.plots[3:2:end], lbls, \"  ALF    MonteCarlo.jl\", nbanks=2, position = legend_pos)\n\n    ax.xticks[] = (xs, xticks)\n    ax.xticklabelrotation[] = -0.7\n\n    # to fix bad spacing, likely unnecessary in the near future\n    ax.xlabelpadding[] = 10\n    \n    fig, ax\nend","category":"page"},{"location":"examples/ALF1/#Equal-time-Greens-function-1","page":"Crosscheck with ALF","title":"Equal time Greens function","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The equal time Greens function shows a clean overlap between the two libraries.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_by_distance(\n    Gs, dGs, :Gr, factor = 2.0, \n    ylabel = \"δ(Δr) - G(Δr) = ∑ᵣ ⟨c^†(r) c(r + Δr)⟩\"\n)\nMakie.save(\"equal_time_greens.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Time-displaced-Greens-function-1","page":"Crosscheck with ALF","title":"Time displaced Greens function","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"For the time-displaced Greens function the overlap becomes visibly less precise. This is likely a result of the different transformations used. Reducing Delta tau in MonteCarlo.jl decreases the error.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_reciprocal(\n    Gks, dGks, :IGk,\n    ylabel = \"Integrated Greens function ∑ₖ ∫ ⟨c(τ, k) c^†(0, k + Δk)⟩ dτ\"\n)\nMakie.save(\"time_displaced_greens.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Energies-1","page":"Crosscheck with ALF","title":"Energies","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"For the kinetic energy and interaction we only get one value per simulation so we just compare them numerically. In this case all values match with errors. The first group shows kinetic energy and the second interaction.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Inv. Temp. ALF MonteCarlo.jl  ALF MonteCarlo.jl\n1 -16.855 ± 0.005 -16.83 ± 0.07  8.775 ± 0.003 8.75 ± 0.03\n6 -21.107 ± 0.002 -21.00 ± 0.08  7.72  ± 0.02 7.64 ± 0.09\n12 -21.109 ± 0.002 -21.12 ± 0.09  7.538 ± 0.006 7.54 ± 0.05","category":"page"},{"location":"examples/ALF1/#Charge-Density-Correlations-1","page":"Crosscheck with ALF","title":"Charge Density Correlations","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Like the equal time Greens function the charge density matches close to exactly.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_by_distance(CDCs, dCDCs, :DenDen, ylabel = \"Charge Density Correlation ∑ᵣ ⟨n(r) n(r + Δr)⟩\")\nMakie.save(\"charge_density_correlation.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Charge-Density-Susceptibility-1","page":"Crosscheck with ALF","title":"Charge Density Susceptibility","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"The charge susceptibility shows some larger errors but still matches fairly well. The errors we see here are generally smaller than what we saw in the integrated Greens function.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_reciprocal(\n    CDCts, dCDCts, :DenDenTau,\n    ylabel = \"Charge Density Susceptibility ∑ᵣ ∫ ⟨n(τ, r) n(0, r + Δr)⟩ dτ\"\n)\nMakie.save(\"charge_density_susceptibility.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Spin-Density-Correlation-1","page":"Crosscheck with ALF","title":"Spin Density Correlation","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Like the other equal time correlations spin density also fits almost exactly.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"fig, ax = plot_by_distance(SDCzs, dSDCzs, :SDCz, ylabel = \"Spin Density Correlation ∑ᵣ ⟨s_z(r) s_z(r + Δr)⟩\")\nMakie.save(\"spin_density_correlation.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"examples/ALF1/#Spin-Density-Susceptibility-1","page":"Crosscheck with ALF","title":"Spin Density Susceptibility","text":"","category":"section"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"Like the other susceptibilities, this shows some larger deviations than its equal time variant but no qualitative difference from ALF.","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"lbl = L\"Spin Density Susceptibility $\\sum_{r, r^\\prime} \\int_0^\\beta s_z(\\tau, r) s_z(0, r^\\prime) e^{i \\Delta k (r^\\prime - r)} d\\tau$\"\nfig, ax = plot_reciprocal(\n    SDSzs, dSDSzs, :SDSz, legend_pos = :lt,\n    ylabel = lbl\n)\nMakie.save(\"spin_density_susceptibility.png\", fig)\ndisplay(fig)","category":"page"},{"location":"examples/ALF1/#","page":"Crosscheck with ALF","title":"Crosscheck with ALF","text":"(Image: )","category":"page"},{"location":"DQMC/scheduler/#Update-Scheduler-1","page":"Update Scheduler","title":"Update Scheduler","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The update scheduler keeps track of and iterates through various Monte Carlo updates. Currently there are two schedulers, SimpleScheduler and AdaptiveScheduler, and five (full) updates.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"note: Note\nThis is a DQMC only feature at the moment.","category":"page"},{"location":"DQMC/scheduler/#Schedulers-1","page":"Update Scheduler","title":"Schedulers","text":"","category":"section"},{"location":"DQMC/scheduler/#SimpleScheduler-1","page":"Update Scheduler","title":"SimpleScheduler","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The SimpleScheduler keeps track of a sequence of updates and cycles through them as update(scheduler, mc, model) is called. It is constructed by simply passing a sequence of updates, i.e. SimpleScheduler(update1, update2, ...).","category":"page"},{"location":"DQMC/scheduler/#AdaptiveScheduler-1","page":"Update Scheduler","title":"AdaptiveScheduler","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The AdaptiveScheduler also has a static sequence of updates, but allows some of these updates to be Adaptive(). Any Adaptive() update in the sequence is replaced with an update from a pool based on their relative weights. These weights are derived from their acceptance rates with some lag.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"An adaptive scheduler is created with a sequence of updates and a pool of updates, i.e.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"sequence = (update1, Adaptive())\npool = (update2, update3)\nscheduler = AdaptiveScheduler(sequence, pool)","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Additionally there are a couple of keywords to configure how weights are adjusted.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"minimum_sampling_rate = 0.01: This defines the threshold under which the ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"sampling rate is set to 0.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"grace_period = 99: This sets a minimum number of times an update needs to ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"be called before its sampling rate is adjusted. ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"adaptive_rate = 9.0: Controls how fast the sampling rate is adjusted to the ","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"acceptance rate. More means slower.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The adjustments of the sampling rate follow the formula \\begin{equation} \\frac{(adaptiverate * samplingrate + \\frac{accepted}{total} }{ adaptive_rate + 1 } \\end{equation}","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"note: Note\nAll schedulers wrap their updates in AcceptanceStatistics. This wrapper keeps track of the total number of update attempts and the number of accepted updates.","category":"page"},{"location":"DQMC/scheduler/#Updates-1","page":"Update Scheduler","title":"Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Updates are small or even empty structs used to dispatch to different update functions. They are assumed to implement name(::MyUpdate) = \"MyUpdate\" and a method update(::MyUpdate, mc, model). ","category":"page"},{"location":"DQMC/scheduler/#Local-Updates-1","page":"Update Scheduler","title":"Local Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Local updates affect one site at one time slice. In order for this to be on a similar scale as global and parallel updates, local updates should come in full sweeps. ","category":"page"},{"location":"DQMC/scheduler/#LocalSweep-1","page":"Update Scheduler","title":"LocalSweep","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Currently there is only one local update - LocalSweep([N=1]). It performs N standard sweeps of local updates, which means two updates per site and time slice each in DQMC. (Two because we go from tau = 0 to tau = beta back to tau = 0.) This update returns a float corresponding to its internal acceptance rate accepted  (2 N_sites M_slices","category":"page"},{"location":"DQMC/scheduler/#Global-Updates-1","page":"Update Scheduler","title":"Global Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Global updates affect not just one site at one time slice, but most if not all sites at all time slices. In other words they attempt to adjust the full configuration. We currently have the following global updates.","category":"page"},{"location":"DQMC/scheduler/#GlobalFlip-1","page":"Update Scheduler","title":"GlobalFlip","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The GlobalFlip() proposes a flip of the full configuration, i.e. pm 1 to mp 1.","category":"page"},{"location":"DQMC/scheduler/#GlobalShuffle-1","page":"Update Scheduler","title":"GlobalShuffle","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"GlobalShuffle() performs a shuffle(current_configuration) to generate a new configuration.","category":"page"},{"location":"DQMC/scheduler/#SpatialShuffle-1","page":"Update Scheduler","title":"SpatialShuffle","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"SpatialShuffle shuffles only the spatial part of a configuration. This means that if two sites are swapped, they are swapped the same way for all time slice indices.","category":"page"},{"location":"DQMC/scheduler/#TemporalShuffle-1","page":"Update Scheduler","title":"TemporalShuffle","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"TemporalShuffle shuffles only the imaginary time part of the configuration, meaning that the swap occurs for all lattice indices the same way.","category":"page"},{"location":"DQMC/scheduler/#Denoise-1","page":"Update Scheduler","title":"Denoise","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Denoise attempts to align the configuration in lattice space. Specifically, it sets each site to the majority value of its neighbors (including itself with a lower weight). Note that this update assumes configuration values pm 1. Also note that the new configuration is solely based on the old, i.e. it does not take changes of nearby sites into account. Because of this the update may not always push the configuration to a more uniform distribution.","category":"page"},{"location":"DQMC/scheduler/#DenoiseFlip-1","page":"Update Scheduler","title":"DenoiseFlip","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"DenoiseFlip follows the logic of Denoise, but flips the resulting configuration.","category":"page"},{"location":"DQMC/scheduler/#StaggeredDenoise-1","page":"Update Scheduler","title":"StaggeredDenoise","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"StaggeredDenoise follows the same logic as Denoise, but multiplies a factor pm 1 based on the lattice site index. ","category":"page"},{"location":"DQMC/scheduler/#Parallel-Updates-1","page":"Update Scheduler","title":"Parallel Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"Parallel updates communicate between different simulations running on different workers. Note that these simulations must produce configurations of the same size, i.e. have same number of time slices and sites.","category":"page"},{"location":"DQMC/scheduler/#ReplicaExchange-1","page":"Update Scheduler","title":"ReplicaExchange","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The ReplicaExchange(target) update requires a target worker, and it requires that worker to be in sync. Specifically that means if worker 1 has a ReplicaExchange(2) followed by ReplicaExchange(3), worker 2 must have ReplicaExchange(1) as its first replica exchange update and worker 3 must have ReplicaExchange(1) as its second replica exchange update.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"The idea of a replica exchange update is to propose swapping configurations between two simulations. The exchange is based on the product of both of their acceptance probabilities. With C_i the configuration of simulation i and w_i(C) the weight of simulation i with the given configuration the acceptance probability is given by","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"p = fracw_1(C_2)w_1(C_1) cdot fracw_2(C_1)w_2(C_2)","category":"page"},{"location":"DQMC/scheduler/#ReplicaPull-1","page":"Update Scheduler","title":"ReplicaPull","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"ReplicaPull() is an experimental parallel update. Instead of synchronizing with another simulations it pulls a configuration asynchronously and uses that for a global update. This means that there is little waiting on other simulations, but configurations will be duplicated.","category":"page"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"This update cycles through a pool of connected workers. This pool can be of any size. Each simulation must make itself available for pulling via connect(target_workers). The target_workers should generally be the workers the simulation wants to receive configurations from. When a simulation reaches the end it will automatically disconnect(target_workers).","category":"page"},{"location":"DQMC/scheduler/#MPI-Updates-1","page":"Update Scheduler","title":"MPI Updates","text":"","category":"section"},{"location":"DQMC/scheduler/#MPIReplicaExchange-1","page":"Update Scheduler","title":"MPIReplicaExchange","text":"","category":"section"},{"location":"DQMC/scheduler/#","page":"Update Scheduler","title":"Update Scheduler","text":"This is a MPI version of the replica exchange update. In this case target is an MPI rank. Much like the normal replica exchange update simulations need to be paired such that they request updates from each other.","category":"page"},{"location":"DQMC/fields/#Fields-1","page":"Fields","title":"Fields","text":"","category":"section"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"In MonteCarlo.jl fields describe how to handle the interactive term(s) in a model/Hamiltonian. Currently we implement two transformations, the Hirsch transformation and a Gauß-Hermite Quadrature based approximation of the Hubbard Stratonovich transformation, each with a density- and spin-channel variant. ","category":"page"},{"location":"DQMC/fields/#Hirsch-Transformation-1","page":"Fields","title":"Hirsch Transformation","text":"","category":"section"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"The Hirsch transformation applies specifically to a Hubbard interaction U (n_iuparrow - 05) (n_idownarrow - 05) Each number operator can take the values 0 or 1 which allows us to rewrite the term as either 05 U (n_iuparrow + n_idownarrow - 1)^2 - 025 or 05 U (n_iuparrow - n_idownarrow)^2 + 025. These two cases are the density- and spin-channel respectively. The next step is to is to introduce a bosonic field x such that","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"e^UDelta tau left( n_iuparrow - frac12 right) left(n_idownarrow - frac12 right) \n= frac12 e^-frac14 Delta tau U sum_x=pm 1 e^alpha x (n_iuparrow + n_idownarrow - frac12)","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"or","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"e^UDelta tau left( n_iuparrow - frac12 right) left(n_idownarrow - frac12 right) \n= frac12 e^-frac14 Delta tau U sum_x=pm 1 e^alpha x (n_iuparrow - n_idownarrow)","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"For both of these cases we define a positive U as the attractive case. The constant alpha = acosh(exp(05 Deltatau U)) in the attractive case and alpha = acosh(exp(-05 Deltatau U)) in the repulsive case. Both of these can be verified by expanding the sum over x and going through the different possible values of the number operator n.","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"In MonteCarlo.jl the first case is implemented as DensityHirschField and the second as MagneticHirschField. Both can be used with positive and negative U, though alpha may become complex. This will of course influence performance. Furthermore the density channel is symmetric between spin up and down, which is used to reduced the size of matrices involved.","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"See Quantum Monte Carlo Methods","category":"page"},{"location":"DQMC/fields/#Gauß-Hermite-Quadrature-1","page":"Fields","title":"Gauß-Hermite Quadrature","text":"","category":"section"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"In this case we use Gaussian quadrature to approximate the integral generated by the Hubbard Stratonovich transformation. This is a more general approach than the Hirsch transformation, though we currently only have an implementation for Hubbard interactions.","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"We start of the same way as with the Hirsch transformation - by rewriting the our interaction as a squared term. Generally speaking we need to arrive at exp(-05Deltatau (c_i^dagger V_ij c_j + C)^2 + C^prime). Using the Hubbard Stratonovich transformation this becomes","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"e^-frac12Deltatau (c_i^dagger V_ij c_j + C)^2 + C^prime = e^-Deltatau C^prime frac1sqrt2pi int_-infty^infty e^-frac12x^2 pm x sqrtDeltatau (c_i^dagger V_ij c_j + C) dx","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"One method of solving this integral is Gauß-Hermite quadrature. With four weights and notes we get","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"frac1sqrt2pi int_-infty^infty e^-frac12x^2 pm x sqrtDeltatau (c_i^dagger V_ij c_j + C) dx = đrac14 sum_x = pm 1 pm 2 gamma(x) e^sqrtDeltatau eta(x) (c_i^dagger V_ij c_j^dagger + C)","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"where gamma and eta give the weights and nodes for a given x. For the density-channel version V_uparrow = V_downarrow = sqrtU and C = 05 sqrtU, for the spin channel V_uparrow = - Vdownarrow = sqrtU and C = 0. These two cases are implemented as DensityGHQField and MagneticGHQField. Just like with the Hirsch field these two methods can create real or complex interaction matrices depending on the sign U and the Density case makes use of symmetry.","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"See ALF Documentation (Auxiliary Field Quantum Monte Carlo section) and https://arxiv.org/pdf/2009.04491.pdf","category":"page"},{"location":"DQMC/fields/#Performance-and-Accuracy-1","page":"Fields","title":"Performance & Accuracy","text":"","category":"section"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"As a rough estimate of relative performance we can look at the runtime of a small Hubbard model (6x6 square lattice, beta = 1, 10 000 sweeps total):","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"Field Type U = +1 U = -1\nDensityHirschField 6.8s 23s\nMagneticHirschField 51s 17s\nDensityGHQField 6.2s 22s\nMagneticGHQField 46s 15s","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"As you can see the runtimes are relatively stable for the repulsive Hubbard model (negative U). This is because we either have to include spin up and down channels or work with complex matrices. In the attractive case both of these fall together. With a density-channel field we make use of spin symmetry and work with real matrices, but with a magnetic-channel field both of these slow us down dramatically.","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"In terms of accuracy none of these should technically have a big advantage over the other other in a Hubbard model. However this doesn't generally seem to be true in practice. In one model we had issues resolving occupations accurately with DensityHirschField and found that spin-channel fields do a better job of resolving most observables. The exception here are spin densities, which are resolved more cleanly by density-channel fields. Overall the MagneticGHQField gave the best results. ","category":"page"},{"location":"DQMC/fields/#","page":"Fields","title":"Fields","text":"In general it is probably a good idea to simulate a smaller system with all the different field options to see which yields the best combination of performance and accuracy.","category":"page"},{"location":"DQMC/model/#Models-1","page":"Model","title":"Models","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"In MonteCarlo.jl a Model describes a Hamiltonian. It's primary purpose is to collect paramaters from different terms in the Hamiltonian as well as the lattice and generate a hopping matrix for the simulation. We currently provide one model - the Hubbard model.","category":"page"},{"location":"DQMC/model/#Hubbard-Model-1","page":"Model","title":"Hubbard Model","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"The  Hubbard model is given by","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"mathcalH = -t sum_langle ij rangle sigma left( c^dagger_isigma c_jsigma + texthc right) - U sum_j left( n_juparrow - frac12 right) left( n_jdownarrow - frac12 right) - musum_j n_j","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"where sigma denotes spin, t is the hopping amplitude, U the on-site Hubbard interaction strength, mu the chemical potential and langle i j rangle indicates that the sum has to be taken over nearest neighbors. Note that the Hamiltonian is written in particle-hole symmetric form such that mu = 0 corresponds to half-filling.","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"Our implementation allows for both attractive (positive) and repulsive (negative) U. Note that for the repulsive case there is a sign problem for mu ne 0. The model also works with any lattice, assuming that lattice provides the required functionality. ","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"You can create a Hubbard model with HubbardModel(). Optional keyword arguments include:","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"l::AbstractLattice = choose_lattice(HubbardModel, dims, L) is the lattice used by the model. \ndims::Integer = 2 is the dimensionality of the default lattice (Chain/Square/Cubic)\nL::Integer = 2 is the linear system size of the default lattice (Chain/Square/Cubic)\nt::Float64 = 1.0 is the hopping strength.\nmu::Float64 = 0.0 is the chemical potential. (Must be 0 if U is negative.)\nU::Float64 = 1.0 is the interaction strength.","category":"page"},{"location":"DQMC/model/#Creating-your-own-Model-1","page":"Model","title":"Creating your own Model","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"To create your own model you will need to inherit from the abstract type Model. There is a set of mandatory and optional methods you must/can implement:","category":"page"},{"location":"DQMC/model/#Mandatory-Methods-1","page":"Model","title":"Mandatory Methods","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"A custom model needs to implement these methods to function","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"lattice(model) needs to return a MonteCarlo compatible lattice\nnflavors(model) needs to return the number of unique fermion flavors of the hopping matrix. For example, in a two spin model this would return 2 if the hopping matrix is different between spin up and down, or 1 if one sector is a copy of the other. Internally this is used together with nflavors(field) to optimize spin/flavor symmetric systems.\nhopping_matrix(model) needs to generate the hopping matrix, which includes all quadratic terms. (I.e. also the chemical potential.) The hopping matrix should only include as many flavors as necessary. If the hopping matrix contains two copies of the same matrix, one for spin up and one for spin down for example, then it should only return one of these. Expanding it to an appropriate size is handled internally.","category":"page"},{"location":"DQMC/model/#(Semi-)-Optional-Methods-1","page":"Model","title":"(Semi-) Optional Methods","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"These methods aren't strictly necessary to implement, but may boost performance when implemented. It is recommended to provide these if the defaults do not apply.","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"_save(file::FileLike, entryname, model) should write model information to the given file. It should also save the lattice via _save(file, entryname, lattice) and save a unique tag. If this is not implemented JLD2 will be asked to save the type as is, which makes it hard to load data when the model type is edited.\n_load(data, ::Val{Symbol(tag)}) loads a model from data, which typically is a JLDFile. Note that saved tag is used to dispatch to the correct method.\nintE_kernel(mc, model, idxs, G, ::Val{flv}) should be implemented to enable measurements of the energy from the interactive term as well as the total energy. \nchoose_field(model) returns the default field type for a given model. If this is not implemented a field must be passed to DQMC.","category":"page"},{"location":"DQMC/model/#Optional-Methods-1","page":"Model","title":"Optional Methods","text":"","category":"section"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"hopping_eltype(model) = eltype(hopping_matrix(model)) returns the element type of the hopping matrix.\nhopping_matrix_type(field, model) = typeof(pad_to_nflavors(field, model, hopping_matrix(model))) return the matrix type of the hopping matrix.\ngreens_eltype(field, model) = generalized_eltype(interaction_eltype(field), hopping_eltype(model)) returns the element type of the greens function. This must be compatible with element types of the hopping matrix and the interaction matrix.\ngreens_matrix_type(field, model) = Matrix{greens_eltype(field, model)} returns the full type of the greens function. This must be compatible with both the type of the hopping matrix and the interaction matrix.\nparameters(m::Model) should collect the parameters from the model and lattice in a NamedTuple.","category":"page"},{"location":"DQMC/model/#","page":"Model","title":"Model","text":"Also note that you may need to update the measurement kernels. More information about that on the measurement page.","category":"page"},{"location":"DQMC/Introduction/#Determinant-Quantum-Monte-Carlo-1","page":"Introduction","title":"Determinant Quantum Monte Carlo","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"Determinant Quantum Monte Carlo is a Quantum Monte Carlo algorithm for fermionic Hamiltonians. The general idea is to use the Hubbard-Stranovich transformation to simplify any term with four fermionic operators to two. This comes at the cost of introducing a bosonic field which is sampled by a Monte Carlo procedure.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"The minimal working example for a DQMC simulation is the following.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"using MonteCarlo\n\ndqmc = DQMC(HubbardModel(), beta = 1.0)\nrun(dqmc)","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"This will set up and run a DQMC simulation at inverse temperature beta = 10 using an attractive Hubbard model with a two by two square lattice. Of course this example is not very useful. In practice you will want to modify lots of parameters and components of the simulation. We give a brief overview of the different components here. You can also check the examples section for some more involved and realistic examples.","category":"page"},{"location":"DQMC/Introduction/#Model-1","page":"Introduction","title":"Model","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"The model is a description of the Hamiltonian. Currently MonteCarlo.jl only implements the HubbardModel which includes nearest neighbor hoppings, a chemical potential and the Hubbard interaction. One aim of this package is to make it simple to implement different models, though currently only Hubbard interactions are supported.","category":"page"},{"location":"DQMC/Introduction/#Lattice-1","page":"Introduction","title":"Lattice","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl provides its own lattice structure inspired by LatticePhysics.jl. The structure is generic, meaning that it should be possible to implement any lattice with it. Lattices are currently part of the model and the HubbardModel should work with any lattice. ","category":"page"},{"location":"DQMC/Introduction/#Field-1","page":"Introduction","title":"Field","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"The field defines how the interaction is handled, i.e. what Monte Carlo configurations look like, how the interactive term is interpreted and how updates work. We currently implement Hirsch fields and Gauß-Hermite Quadrature fields, both with a density- and magnetic-channel version. Any of these choices works with any choice of the Hubbard model, though performance and accuracy can vary.","category":"page"},{"location":"DQMC/Introduction/#Updates-1","page":"Introduction","title":"Updates","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"Beyond local updates we provide a selection of global and experimental parallel updates. Like models, this part is designed to be relatively easy to extend. Most global updates just generate a new configuration and call another function to accept or reject it.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"The updates themselves are collected in a scheduler. We currently provide two types of them - one which simply iterates through updates and one which adaptively favors updates with high acceptance rates.","category":"page"},{"location":"DQMC/Introduction/#Configuration-Recorder-1","page":"Introduction","title":"Configuration Recorder","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"We provide an interface to record configurations during a MonteCarlo run so that they can later be replayed. This interface also implements functionality for compressing configurations.","category":"page"},{"location":"DQMC/Introduction/#Measurements-1","page":"Introduction","title":"Measurements","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"We currently include measurements of the following observables:","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"Equal time Greens function (and to a less direct extend time displaced Greens functions)\noccupations\ncharge density correlations and susceptibilities\nmagnetization in x, y and z direction\nspin density correlations and susceptibilities in x, y and z direction\npairing correlation and susceptibility for generic symmetries\ncurrent current susceptibilities which are required for the superfluid stiffness (this can also be calculated more directly)\ntotal and partial energies (quadratic terms and quartic terms separated)","category":"page"},{"location":"DQMC/Introduction/#DQMC-1","page":"Introduction","title":"DQMC","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"The DQMC struct represents the full simulation. All the components above are collected here. It also contains a bunch paramters, such as the inverse temperature beta, the time step discretization delta_tau, the number of thermazition and measurements sweeps and more.","category":"page"},{"location":"DQMC/Introduction/#Derivation-1","page":"Introduction","title":"Derivation","text":"","category":"section"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"If you are interested in the derivation of DQMC you may check Introduction to Quantum Monte Carlo Simulations for fermionic Systems, the book Quantum Monte Carlo Methods or World-line and Determinantal Quantum Monte Carlo Methods for Spins, Phonons and Electrons. The first reference is most in-line with the implementation of this package.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"If you want to go through the source code, compare it and verify for yourself that it is correct there a couple of things that should be pointed out. Most educational sources use the asymmetric two term Suzuki-Trotter decomposition. We use the symmetric three term version for increased accuracy.","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"B(l) = e^-Deltatau sum_l T+V(l) = prod_j e^-Deltatau T2 e^-Deltatau V e^-Deltatau T2 + mathcalO(Deltatau^2)","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"This change is however no trivial as the first or last element of the B matrix/operator needs to be an exponentiated interaction. To get this we use an effective greens function, which cyclically permutes one exponentiation hopping term to the other end of the chain. This adjustment needs to be undone for the actual greens function, which happens in greens().","category":"page"},{"location":"DQMC/Introduction/#","page":"Introduction","title":"Introduction","text":"Another thing worth mentioning is that depending on the choices made at the start of the derivation, matrix products may have different order and indices may vary. The first source should have the same definitions.","category":"page"},{"location":"examples/triangular_Hubbard/#Triangular-Attractive-Hubbard-1","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"This example implements the model from the paper Attractive Hubbard model on a triangular lattice. This also serves as a cross-check for the DQMC and a few measurements, such as pairing correlations and occupations. ","category":"page"},{"location":"examples/triangular_Hubbard/#Simulation-1","page":"Triangular Attractive Hubbard","title":"Simulation","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"In the paper simulations were done with 500-1000 sweeps and Deltatau = 0125. Occupations are measured the same way as in MonteCarlo.jl. Pairing correlations seem to use Delta Delta^dagger rather than the Delta^dagger Delta + Delta Delta^dagger given in the paper. The latter is the default in MonteCarlo.jl. To have the former we need to explicitly pass kernel = MonteCarlo.pc_kernel.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The first figure is done with interaction strength U = -4, linear system size L = 4 at beta = 2 5 7 for varying mu. The following simulations should take about 2 minutes.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"using MonteCarlo\n\nbetas = (2.0, 5.0, 7.0)\nmus = vcat(-2.0, -1.5, -1.25:0.05:-1.0, -0.8:0.2:0.8, 0.9:0.05:1.25, 1.5, 2.0)\nl = TriangularLattice(4)\ndqmcs = []\n\ncounter = 0\nN = length(mus) * length(betas)\n@time for beta in betas, mu in mus\n    counter += 1\n    print(\"\\r[\", lpad(\"$counter\", 2), \"/$N] \")\n    m = HubbardModel(l = l, t = 1.0, U = 4.0, mu = mu)\n    dqmc = DQMC(\n        m, beta = beta, delta_tau = 0.125, safe_mult = 8, \n        thermalization = 1000, sweeps = 1000, measure_rate = 1,\n        recorder = Discarder()\n    )\n    dqmc[:occ] = occupation(dqmc, m)\n    dqmc[:PC] = pairing_correlation(dqmc, m, kernel = MonteCarlo.pc_kernel)\n    run!(dqmc, verbose = false)\n\n    # for simplicity we just keep the whole simulation around\n    push!(dqmcs, dqmc)\nend","category":"page"},{"location":"examples/triangular_Hubbard/#Processing-Data-1","page":"Triangular Attractive Hubbard","title":"Processing Data","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"After running all the simulations we need to do a little bit of post-processing on the measured data. ","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"N = length(mus)\noccs = []\nΔoccs = []\npcs = []\nΔpcs = []\n\nfor i in 0:2\n    # Measurements are saved in a LogBinner from BinningAnalysis by default.\n    # Taking the mean (std_error) of a LogBinner will return the Monte Carlo \n    # average (error). Occupation measurements happen per site, so we need \n    # another mean afterwards. \n    _occs = [2 * mean(mean(dqmcs[N*i + j][:occ])) for j in 1:N]\n    doccs = [2 * sqrt(mean(std_error(dqmcs[N*i + j][:occ]).^2)) for j in 1:N]\n    push!(occs, _occs)\n    push!(Δoccs, doccs)\n\n    # pairing correlations are saved in a partially processed state - a 3D matrix\n    # where each index corresponds to vectors between sites\n    # y_{i, j, k} = ∑_x ⟨c_{x, ↑} c_{x+j, ↓} c_{x+i+k, ↓}^† c_{x+i, ↑}^†\n    # The vectors corresponding to the indices i, j, k are returned by \n    # directions(lattice(dqmc)). To compute the pairing correlation of a certain\n    # symmetry, we need to apply the weights corresponding vector indices j, k.\n    # For s-wave symmetry these weights are always (1, 0, ..., 0) (only vector 0).\n    # To match the paper the index i should just be summed over. This is \n    # equivalent to a q=0 Fourier transform.\n    _pcs = [sum(mean(dqmcs[N*i + j][:PC])[:, :, :, 1, 1]) for j in 1:N]\n    dpcs = [sqrt(sum(std_error(dqmcs[N*i + j][:PC])[:, :, :, 1, 1].^2)) for j in 1:N]\n    push!(pcs, _pcs)\n    push!(Δpcs, dpcs)\nend","category":"page"},{"location":"examples/triangular_Hubbard/#Plotting-1","page":"Triangular Attractive Hubbard","title":"Plotting","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"With the data in a processed form we can now plot it. To make comparison easier, we plot our data directly over figure 1 from our reference.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"using CairoMakie, FileIO, Colors\n\n\nfig = Figure(resolution = (800, 800))\ntop = Axis(fig[1, 1])\nbot = Axis(fig[2, 1])\n\n# References\np = pkgdir(MonteCarlo)\ntop_ref = FileIO.load(joinpath(p, \"docs/src/examples/assets/triangular/tri_Hub_ref1_1.png\"))\nbot_ref = FileIO.load(joinpath(p, \"docs/src/examples/assets/triangular/tri_Hub_ref1_2.png\"))\nip = image!(top, -2..2, 0..2, top_ref'[:, end:-1:1])\ntranslate!(ip, 0, 0, -1)\nip = image!(bot, -2..2, 0..2.5, bot_ref'[:, end:-1:1], transparency=true)\ntranslate!(ip, 0, 0, -1)\n\nc = HSV(250, 0.6, 1)\nfor (i, (ys, dys)) in enumerate(zip(occs, Δoccs))\n    band!(top, mus, ys .- dys, ys .+ dys, color = (:red, 0.3))\n    lines!(top, mus, ys, color = (c, 0.5), linewidth=2)\n    scatter!(top, mus, ys, color = c, marker = ('■', '□', 'o')[i])\nend\n\naxislegend(top, top.scene.plots[4:3:end], [\"β = 2\", \"β = 5\", \"β = 7\"], position = :rb)\n\nfor (i, (ys, dys)) in enumerate(zip(pcs, Δpcs))\n    band!(bot, mus, ys .- dys, ys .+ dys, color = (:red, 0.3), transparency=true)\n    lines!(bot, mus, ys, color = (c, 0.5), linewidth=2)\n    scatter!(bot, mus, ys, color = c, marker = ('■', '□', 'o')[i])\nend\n\nxlims!(top, -2 , 2)\nylims!(top, 0 , 2)\nxlims!(bot, -2 , 2)\nylims!(bot, 0 , 2.5)\n\nCairoMakie.save(joinpath(p, \"docs/src/examples/assets/triangular/fig1_comparison.png\"), fig)","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#Other-runs-1","page":"Triangular Attractive Hubbard","title":"Other runs","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The paper has two more versions of the above plot for system sizes L = 6 and L = 8. These show significantly different results.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"For L = 6 we use mus = vcat(-2.0:0.25:-0.25, -0.1:0.1:1.1, 1.25, 1.5, 2.0) with the same parameters other than that. The simulation should take about 5 minutes.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"For L=8 we use mus = vcat(-2.0:0.5:-0.5, -0.1:0.1:1.1, 1.25, 1.5, 2.0) and betas = (2.0, 5.0, 6.0, 7.0). The resulting simulation takes about 30min.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#Charge-Density-Structure-Factor-1","page":"Triangular Attractive Hubbard","title":"Charge Density Structure Factor","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The paper also investigates the charge density structure factor as a function of reciprocal lattice vectors q. In general structure factors can be computed from correlations via Fourier transform. In this case it is not quite as simple since MonteCarlo.jl implements langle n_i n_j rangle while the paper uses langle n_i n_j rangle - langle n_i rangle langle n_j rangle. As such we need to implement our own reduced charge density correlation measurement. First we need to figure out what this observable looks like in terms of Greens function elements.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"beginaligned\n\tlangle n_i s n_j s^prime rangle - langle n_i s rangle langle n_j s^prime rangle\n\t= langle c_i s^dagger c_i s c_j s^prime^dagger c_j s^prime rangle  - langle n_i s rangle langle n_j s^prime rangle\n\t= langle c_i s^dagger c_i s rangle langle c_j s^prime^dagger c_j s^prime rangle + langle c_i s^dagger c_j s^prime rangle langle c_i s c_j s^prime^dagger rangle  - langle n_i s rangle langle n_j s^prime rangle\n\t= (delta_ij delta_ss^prime - G_ji^s^prime s) G_ij^ss^prime\nendaligned","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"Here we expanded the term into creation and annihilation operators, applied Wicks theorem and finally used G_ij^ss^prime = langle c_i c_j^dagger rangle to express the term with Greens function elements. (We note that expectation values of two creation or two annihilation operators are always zero in DQMC and are therefore dropped.) For the attractive Hubbard model, greens function elements with different spins G_ij^ss^prime are zero and G_ij^uparrowuparrow = G_ij^downarrowdownarrow. Thus the full expectation value is given by","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"langle n_i n_j rangle - langle n_i s rangle langle n_j s^prime rangle = 2 (delta_ij - G_ji) G_ij","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"which needs to be implemented as a function and passed to MonteCarlo.Measurement to be used.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"function my_kernel(mc, m, ij::NTuple{2}, G::GreensMatrix, flv)\n    i, j = ij\n    4 * (I[j, i] - G[j, i]) * G[i, j]\nend\n\ndqmc[:CDC] = MonteCarlo.Measurement(mc, m, Greens, EachSitePairByDistance, my_kernel)","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"In the above, Greens is a greens function iterator used by the measurement. It yields an equal time greens function to the measurement which is eventually passed as G to the kernel. EachSitePairByDistance defines which lattice indices are passed to the kernel and how they are saved. In this case i and j run through each site index independently and the results are summed such that we have one value per unique distance vector.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"With that measurement we can now compare to the paper. We simulate with L = 6 8, beta = 8, mu = 0 and U = 4, which should take about a minute.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"To match the paper we simulate L = 6 8, beta = 8, mu = 0 and U = -4 with the new measurement. This should take about a minute. After the simulation we compute the fourier transform at various q with","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"qs = vcat(\n    range(Float64[0, 0],   Float64[pi, 0], length=10),\n    range(Float64[pi, 0],  Float64[pi, pi], length=10),\n    range(Float64[pi, pi], Float64[0, 0], length=10),\n)\nys = map(dqmcs) do dqmc\n    result = zeros(ComplexF64, length(qs))\n    vals = mean(dqmc[:CDC])\n    dirs = directions(dqmc[:CDC].lattice_iterator, lattice(dqmc))\n    for (j, q) in enumerate(qs)\n        # basis, basis, directional index (on Bravais lattice)\n        for b1 in axes(dirs, 1), b2 in axes(dirs, 2), i in axes(dirs, 3)\n            result += vals[b1, b2, i] * cis(dot(dirs[b1, b2, i], q))\n        end\n    end\n\n    real(result)\nend","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"examples/triangular_Hubbard/#Magnetic-Susceptibility-1","page":"Triangular Attractive Hubbard","title":"Magnetic Susceptibility","text":"","category":"section"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"The uniform susceptibility featured in figure 7 of the paper can be reproduced more easily. For it we need to run our simulation with a spin_density_susceptibility(dqmc, model, :z) measurement. The result will again be in a partially summed per-distance-vector form. The q=0 Fourier transform follows from simple summation. With L = 6 and betas = [1.0, 2.0, 4.0, 5.0, 6.0, 7.0, 8.0] this simulation should take about a minute.","category":"page"},{"location":"examples/triangular_Hubbard/#","page":"Triangular Attractive Hubbard","title":"Triangular Attractive Hubbard","text":"(Image: )","category":"page"},{"location":"legacy/methods/general/#Methods:-General-1","page":"General","title":"Methods: General","text":"","category":"section"},{"location":"legacy/methods/general/#","page":"General","title":"General","text":"Below you find all general exports.","category":"page"},{"location":"legacy/methods/general/#Index-1","page":"General","title":"Index","text":"","category":"section"},{"location":"legacy/methods/general/#","page":"General","title":"General","text":"Pages = [\"general.md\"]","category":"page"},{"location":"legacy/methods/general/#Documentation-1","page":"General","title":"Documentation","text":"","category":"section"},{"location":"legacy/methods/general/#","page":"General","title":"General","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"abstract.jl\"]","category":"page"},{"location":"legacy/methods/general/#MonteCarlo.lattice-Tuple{T} where T<:Model","page":"General","title":"MonteCarlo.lattice","text":"lattice(model)\n\nReturns the lattice of a given model.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.parameters-Tuple{Model}","page":"General","title":"MonteCarlo.parameters","text":"parameters(model)\n\nCollects relevant parametrs of a model into a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.reset!-Tuple{MonteCarloFlavor}","page":"General","title":"MonteCarlo.reset!","text":"reset!(mc::MonteCarloFlavor)\n\nResets the Monte Carlo simulation mc. Previously set parameters will be retained.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.run!-Tuple{MonteCarloFlavor}","page":"General","title":"MonteCarlo.run!","text":"run!(mc)\n\nRun the Monte Carlo Simulation.\n\n\n\n\n\n","category":"method"},{"location":"legacy/methods/general/#MonteCarlo.Model","page":"General","title":"MonteCarlo.Model","text":"Abstract model.\n\n\n\n\n\n","category":"type"},{"location":"legacy/methods/general/#MonteCarlo.MonteCarloFlavor","page":"General","title":"MonteCarlo.MonteCarloFlavor","text":"Abstract definition of a Monte Carlo flavor.\n\n\n\n\n\n","category":"type"},{"location":"legacy/manual/showcase/#Showcase-1","page":"Showcase","title":"Showcase","text":"","category":"section"},{"location":"legacy/manual/showcase/#D-Ising-model-1","page":"Showcase","title":"2D Ising model","text":"","category":"section"},{"location":"legacy/manual/showcase/#","page":"Showcase","title":"Showcase","text":"Results: (Image: )","category":"page"},{"location":"legacy/manual/showcase/#","page":"Showcase","title":"Showcase","text":"Code:","category":"page"},{"location":"legacy/manual/showcase/#","page":"Showcase","title":"Showcase","text":"using MonteCarlo, Distributions, PyPlot, DataFrames, JLD\n\nTdist = Normal(MonteCarlo.IsingTc, .64)\nn_Ts = 2^8\nTs = sort!(rand(Tdist, n_Ts))\nTs = Ts[Ts.>=1.2]\nTs = Ts[Ts.<=3.8]\ntherm = 10^4\nsweeps = 10^3\n\ndf = DataFrame(L=Int[], T=Float64[], M=Float64[], χ=Float64[], E=Float64[], C_V=Float64[])\n\nfor L in 2 .^ [3, 4, 5, 6]\n\tprintln(\"L = \", L)\n\tfor (i, T) in enumerate(Ts)\n\t\tprintln(\"\\t T = \", T)\n\t\tbeta = 1/T\n\t\tmodel = IsingModel(dims=2, L=L)\n\t\tmc = MC(model, beta=beta)\n\t\trun!(mc, sweeps=sweeps, thermalization=therm, verbose=false)\n\t\tpush!(df, [L, T, mean(mc.obs[\"m\"]), mean(mc.obs[\"χ\"]), mean(mc.obs[\"e\"]), mean(mc.obs[\"C\"])])\n\tend\n\tflush(stdout)\nend\n\nsort!(df, [:L, :T])\n@save \"ising2d.jld\" df\n\n# plot results together\ngrps = groupby(df, :L)\nfig, ax = subplots(2,2, figsize=(12,8))\nfor g in grps\n\tL = g[:L][1]\n\tax[1].plot(g[:T], g[:E], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[2].plot(g[:T], g[:C_V], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[3].plot(g[:T], g[:M], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[4].plot(g[:T], g[:χ], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\nend\nax[1].legend(loc=\"best\")\nax[1].set_ylabel(\"Energy\")\nax[1].set_xlabel(\"Temperature\")\n\nax[2].set_ylabel(\"Specific heat\")\nax[2].set_xlabel(\"Temperature\")\nax[2].axvline(x=MonteCarlo.IsingTc, color=\"black\", linestyle=\"dashed\", label=\"\\$ T_c \\$\")\nax[2].legend(loc=\"best\")\n\nax[3].set_ylabel(\"Magnetization\")\nax[3].set_xlabel(\"Temperature\")\nx = range(1.2, stop=MonteCarlo.IsingTc, length=100)\ny = (1 .- sinh.(2.0 ./ (x)).^(-4)).^(1/8)\nax[3].plot(x,y, \"k--\", label=\"exact\")\nax[3].plot(range(MonteCarlo.IsingTc, stop=3.8, length=100), zeros(100), \"k--\")\nax[3].legend(loc=\"best\")\n\nax[4].set_ylabel(\"Susceptibility χ\")\nax[4].set_xlabel(\"Temperature\")\nax[4].axvline(x=MonteCarlo.IsingTc, color=\"black\", linestyle=\"dashed\", label=\"\\$ T_c \\$\")\nax[4].legend(loc=\"best\")\ntight_layout()\nsavefig(\"ising2d.pdf\")","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is a package implementing classical and quantum Monte Carlo simulations primarily for solid state physics. Currently the focus is on finding a overall design for the package and verifying that determinant Quantum Monte Carlo (DQMC) is working correctly. As such the package may still go through significant changes and the documentation may be outdated and incomplete.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Note that classical Monte Carlo is also not a focus at this point. It is probably usable, but a lot of the adjustments made to DQMC have not been added to classical Monte Carlo, or have been added without thorough testing.","category":"page"},{"location":"DQMC/recorder/#Configuration-Recorder-1","page":"Configuration Recorder","title":"Configuration Recorder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"Sometimes it's useful to keep configurations around, for example to perform new measurements after the original simulation has finished. This is especially true in the case of DQMC where simulations can take weeks to run, but measurement on their own are relatively fast. We currently offer two objects for this purpose - Discarder and ConfigRecorder.","category":"page"},{"location":"DQMC/recorder/#General-Interface-1","page":"Configuration Recorder","title":"General Interface","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"Any AbstractRecorder follows an array-like interface. Configurations are added via push!(recorder, mc, model, sweep) and can be retrieved via getindex. The recorder has a length and implements isempty. Furthermore it can be iterated, saved and loaded.","category":"page"},{"location":"DQMC/recorder/#Discarder-1","page":"Configuration Recorder","title":"Discarder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"As the name suggests this recorder simply discards all configurations. It is used by default for classical Monte-Carlo simulations.","category":"page"},{"location":"DQMC/recorder/#ConfigRecorder-1","page":"Configuration Recorder","title":"ConfigRecorder","text":"","category":"section"},{"location":"DQMC/recorder/#","page":"Configuration Recorder","title":"Configuration Recorder","text":"This recorder keeps track of compressed configurations in memory. On creation a rate can be specified as the last argument in the constructor to reduce the amount of configurations saved. Compression relies on overloads of compress(mc, model, conf) and decompress(mc, model, conf). For the available Hubbard models these simply transform from and to BitArray.","category":"page"}]
}
