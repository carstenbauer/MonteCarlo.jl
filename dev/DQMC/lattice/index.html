<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lattices · MonteCarlo.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MonteCarlo.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">MonteCarlo.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">DQMC</span><ul><li><a class="tocitem" href="../Introduction/">Introduction</a></li><li><a class="tocitem" href="../model/">Model</a></li><li class="is-active"><a class="tocitem" href>Lattices</a></li><li><a class="tocitem" href="../dqmc/">DQMC</a></li><li><a class="tocitem" href="../recorder/">Configuration Recorder</a></li><li><a class="tocitem" href="../scheduler/">Update Scheduler</a></li><li><a class="tocitem" href="../measurements/">Measurements</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/triangular_Hubbard/">Triangular Attractive Hubbard</a></li><li><a class="tocitem" href="../../examples/ALF1/">Crosscheck with ALF</a></li></ul></li><li><span class="tocitem">Legacy</span><ul><li><a class="tocitem" href="../../legacy/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../legacy/manual/gettingstarted/">Getting started</a></li><li><a class="tocitem" href="../../legacy/manual/showcase/">Showcase</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Physical models</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../legacy/models/ising/">Ising model</a></li><li><a class="tocitem" href="../../legacy/models/hubbardattractive/">Attractive Hubbard model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Monte Carlo flavors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../legacy/flavors/mc/">MC</a></li><li><a class="tocitem" href="../../legacy/flavors/dqmc/">DQMC</a></li></ul></li><li><a class="tocitem" href="../../legacy/lattices/">Lattices</a></li><li><a class="tocitem" href="../../legacy/customize/">Customize</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../legacy/interfaces/MC/">MC</a></li><li><a class="tocitem" href="../../legacy/interfaces/DQMC/">DQMC</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-8" type="checkbox"/><label class="tocitem" for="menuitem-4-8"><span class="docs-label">General exports</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../legacy/methods/general/">General</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">DQMC</a></li><li class="is-active"><a href>Lattices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lattices</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/crstnbr/MonteCarlo.jl/blob/master/docs/src/DQMC/lattice.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Lattices-1"><a class="docs-heading-anchor" href="#Lattices-1">Lattices</a><a class="docs-heading-anchor-permalink" href="#Lattices-1" title="Permalink"></a></h1><p>Lattices are a generic component for both quantum and classical Monte Carlo simulations. At this point they are part of the model. We currently offer a couple of directly implemented lattices, an interface for loading ALPS lattices and an interface to <a href="https://github.com/janattig/LatticePhysics.jl">LatticePhysics.jl</a>.</p><h4 id="Available-Lattices-1"><a class="docs-heading-anchor" href="#Available-Lattices-1">Available Lattices</a><a class="docs-heading-anchor-permalink" href="#Available-Lattices-1" title="Permalink"></a></h4><p>We currently have the following lattices. Unless mentioned, they all include nearest neighbor bonds.</p><ul><li><code>Chain(N)</code>: A one dimensional chain lattice with <code>N</code> sites.</li><li><code>SquareLattice(L)</code>: A two dimensional square lattice with <code>L²</code> sites.</li><li><code>CubicLattice(D, L)</code>: A <code>D</code> dimensional cubic lattice with <code>L^D</code> sites.</li><li><code>TriangularLattice(L[; Lx = L, Ly = L])</code>: A two dimensional triangular lattice with <code>Lx * Ly</code> sites. This lattice also includes next nearest neighbor bonds.</li></ul><p>Additionally we have <code>ALPSLattice(file)</code> which loads an ALPS lattice from an xml file and <code>LatPhysLattice(lattice)</code> which wraps a generic lattice from <a href="https://github.com/janattig/LatticePhysics.jl">LatticePhysics.jl</a>.</p><h4 id="Implementing-your-own-Lattice-1"><a class="docs-heading-anchor" href="#Implementing-your-own-Lattice-1">Implementing your own Lattice</a><a class="docs-heading-anchor-permalink" href="#Implementing-your-own-Lattice-1" title="Permalink"></a></h4><p>If you want to implement your own lattice you need to implement a couple of things for compatibility. Your lattice should inherit from <code>MonteCarlo.AbstractLattice</code>. It should implement a method <code>length(lattice)</code> returning the total number of sites.  The more complex lattice iterators require a method <code>positions(lattice)</code> returning the positions of each site in matching order, and a method <code>lattice_vectors(lattice)</code> returning D vectors pointing from one end of the lattice to the other along nearest neighbor directions, where D is the dimensionality of the lattice.  If you are using the default models you will also need to implement some way to get nearest neighbor directions. You have two options here - either implement some traits and fields or implement the getter function directly. For the first option you need to implement: </p><ul><li>the field <code>neighs::Matrix{Int}</code> with <code>target = neighs[neighbor_idx, source]</code> and <code>has_neighbors_table(lattice) = true</code></li><li>the field <code>bonds::Matrix{Int}</code> where <code>(source, target, type) = bonds[total_bond_idx, :]</code> and <code>has_bonds_table(lattice) = true</code></li></ul><p>For the second option you need to write your own <code>neighbors(lattice, directed)</code> where <code>directed = Val{true}</code> returns forward and backwards facing bonds and <code>directed = Val{false}</code> considers those the same, returning only one of them.</p><h4 id="Lattice-Iterators-1"><a class="docs-heading-anchor" href="#Lattice-Iterators-1">Lattice Iterators</a><a class="docs-heading-anchor-permalink" href="#Lattice-Iterators-1" title="Permalink"></a></h4><p>Lattice Iterators are to some degree a backend component. They specify and often cache a way to iterate through the lattice. They are mainly used for DQMC measurements, which frequently require specific pairing of sites. There are currently three abstract subtypes of lattice iterators, each with multiple concrete types. Each concrete iterator can be created via <code>iterator(dqmc, model)</code>.</p><p>First we have <code>DirectLatticeIterator</code>. These iterators return just site indices, e.g. <code>(source_index, target_index)</code>. The concrete implementations include:</p><ul><li><code>EachSiteAndFlavor</code> iterates all indices from 1 to <code>length(lattice) * nflavors(model)</code></li><li><code>EachSite</code> iterates all indices from 1 to <code>length(lattice)</code></li><li><code>OnSite</code> also iterates from <code>1:length(lattice)</code>, however returns two indices <code>(i, i)</code> at each step</li><li><code>EachSitePair</code> iterates through all possible pairs <code>(i, j)</code> where both i and j run from 1 to <code>length(lattice)</code>.</li></ul><p>Next we have <code>DeferredLatticeIterator</code>. These iterators return some meta information with each site index, for example a directional index. They are used to do partial summation. The concrete implementations include:</p><ul><li><code>EachSitePairByDistance</code> which iterates the same range as <code>EachSitePair</code> but returns <code>(dir_idx, i, j)</code> at each step.</li><li><code>EachLocalQuadByDistance{K}</code> iterates through four sets <code>(1, length(lattice))</code>, returning <code>(combined_dir_idx, src1, trg1, src2, trg2)</code> at each step. Here the directional index relates to three directional indices <code>(dir_idx, dir_idx1, dir_idx2)</code> representing the vectors between <code>src1</code> and <code>src2</code>, <code>src1</code> and <code>trg1</code>, and <code>src2</code> and <code>trg2</code> respectively. <code>K</code> restricts the included number of bonds between <code>src1</code> and <code>trg1</code> (and <code>src2</code> and <code>trg2</code>). Note that an on-site connection is also counted here - i.e. to include four nearest neighbors you must set <code>K = 5</code>.</li><li><code>EachLocalQuadBySyncedDistance{K}</code> does the same thing as <code>EachLocalQuadByDistance{K}</code> with the additional of synchronizing the direction between <code>(src1, trg1)</code> and <code>(src2, trg2)</code>.</li></ul><p>Note that you can get the directions matching the indices from <code>directions(lattice/model/dqmc)</code>.</p><p>Lastly we have <code>LatticeIterationWrapper{LI &lt;: LatticeIterator}</code>. Generally results from <code>DeferredLatticeIterator</code>s will be saved in a vector, where <code>values[dir_idx]</code> is the sum of all values with the same directional index. The wrappers are there to further process what happens to these values before they are saved. The parametric type of them specifies the iteration procedure that is used. The concrete implementations are:</p><ul><li><code>Sum{LI}</code> tells the measurement to sum up all values before saving.</li><li><code>ApplySymmetry{LI}(symmetries...)</code> tells the measurement to do sum directional indices past the first with some weights given as <code>symmetries</code>. For example you may use <code>ApplySymmetry{EachLocalQuadByDistance}([1], [0, 1, 1, 1, 1])</code> to generate s-wave and extended s-wave summations for square lattices.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model/">« Model</a><a class="docs-footer-nextpage" href="../dqmc/">DQMC »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 12 August 2021 09:27">Thursday 12 August 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
