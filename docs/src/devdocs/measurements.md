# Measurements

## Measurement type

Measurements in DQMC are represented with

```julia
struct DQMCMeasurement{F <: Function, GI, LI, FI, OT, T} <: AbstractMeasurement
    greens_iterator::GI
    lattice_iterator::LI
    flavor_iterator::FI
    kernel::F
    observable::OT
    temp::T
end
```

where `observable` is the permanent storage for measurement data and `temp` is used as temporary storage, i.e. for accumulating data in sums. The iterators specify which greens functions, sites and flavor indices go into a measurement. The kernel is a function that takes all the indices generated for one iteration and returns a measurement value for it. We'll go into more detail about the latter components when describing the call tree of a measurement, as they match up closely.

## Grouping

In order to efficiently evaluate measurements, we want to avoid recalculating Greens function unnecessarily. Therefore we have a grouping step at the start of the simulation, which groups measurement by their greens iterator. This grouping is done by the `generate_groups` function in "flavors/DQMC/measurements/generic.jl". 

## Call Tree

The call tree for measurements starts with a call to `sweep_once!` in "flavors/DQMC/DQMC.jl". From this point on, all functions down to `kernel` are implemented in "DQMC/measurements/generic.jl". Each stage handles one of the iterators of the call tree, with the final one calling the `kernel`.

### Greens Iterator Stage

The first function in the call tree handles `measurement.greens_iterators`. A 
greens iterators can be:

- `nothing` which implies that the Greens function is not necessary for the measurement and thus none is passed to the next stage.
- `Greens()` which produces the equal-time Greens function and passes it on to the next stage
- `GreensAt(k, l)` which generates a time displaced Greens function $G(k, l) = \langle c(\Delta\tau k) c^\dagger(\Delta\tau l) \rangle$ to pass on
- `TimeIntegral` which implies integration over imaginary time, evaluated via a Riemann sum. For each element of the sum, the Greens functions $G(0, 0)$, $G(0, l)$, $G(l, 0)$ and $G(l, l)$ are generated and passed on to the next stage.

Since `TimeIntegral` also includes summation, we prepare `measurement.temp` at the start of this stage. This is done by the `prepare!` function. Similarly we end this stage with the `finish!` function, which applies normalization to the values accumulated in `measurement.temp` and then `push!`es them into `measurement.observable`.

### `measure!` Stage

This stage only exists to be compliant with the measurement interface.

### Lattice & Flavor Iterator Stage

The lattice and flavor iterators both produce indices for indexing the greens function. You can find details about what each lattice iterator does in the  lattice docs. The iteration implementation is mostly in "lattices/lattice_iterators.jl", with some of it being in the measurement file. The flavor iterator is a simple value, range or vector, typically generated by `FlavorIterator` from "flavors/DQMC/measurements/constructors/main.jl".

For each iteration, these iterators will produce a set of indices for the lattice and an index or set of indices for the flavor. These are then passed to the kernel, to evaluate the measurement for that configuration of sites and flavors. The result is then added to `measurement.temp` at another set of indices specified by the lattice iterator.

### Kernel

The kernel is the final stage of a measurement. It essentially represents the Observable after Wicks theorem is applied, where expectation values of pairs of operators have been replaced by elements of the Greens function. On top of that there is some code to efficiently access the different matrix types present in MonteCarlo.jl

---

The point of having all of these different stages is to make measurements more adjustable. For example, one can adjust the lattice iterator to switch between getting a Matrix containing every $\langle c_i c_j^\dagger \rangle$ or getting a vector, where matching $r_i - r_j$ are summed.

## Restructure

For some of the more verbose lattice iterators it is helpful to reorder the elements of the Greens function for fasting indexing. This is indicated by `Restructure` and done by `restructure!`. After this, the Greens function is indexed by with a site index and a directional index, rather than two site indices. Flavor indices remain unchanged through this process.